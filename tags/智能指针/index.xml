<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>智能指针 - 标签 - Ramen's Box</title><link>https://blog.lxdlam.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link><description>智能指针 - 标签 - Ramen's Box</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lxdlam@gmail.com (Ramen)</managingEditor><webMaster>lxdlam@gmail.com (Ramen)</webMaster><copyright>本站所有内容基于署名-非商业性使用-相同方式共享 4.0 国际协议（CC BY-NC-SA 4.0）给出许可</copyright><lastBuildDate>Tue, 24 Nov 2020 02:16:42 +0800</lastBuildDate><atom:link href="https://blog.lxdlam.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="self" type="application/rss+xml"/><item><title>Rust 的包装类型</title><link>https://blog.lxdlam.com/post/b63a9600/</link><pubDate>Tue, 24 Nov 2020 02:16:42 +0800</pubDate><author>Ramen</author><guid>https://blog.lxdlam.com/post/b63a9600/</guid><description><![CDATA[<p>对于一门对内存控制足够精细的语言来说，值类型与引用类型的区别是十分重要的：值类型通常意味着较低的拷贝成本，通常来说，这样的类型被分配在栈上（当然，对于 C/C++ 来说，我们可以在堆上直接分配一个值类型对象，如 <code>int</code>），而引用类型则通常分配在堆上，我们需要用一个包装过的对象去维护。</p>
<p>在 Rust 中，值类型和引用类型的界限在语言上提供了很明确的区分，而为了避免 C/C++ 中用户可以不受限制使用裸指针的情况，Rust 将很多裸指针操作都包在了 <code>unsafe</code> 块内，用户使用时必须对这种行为有足够的认知。当然，当用户需要使用指针，或者说引用类型的时候，Rust 也提供了 7 种包装类型来帮助用户更好的管理堆上的内存。</p>
<p>然而，Rust 官方教程和文档对这 7 种包装类型的介绍有很多容易混淆之处，同时网上的很多文章也已经完全脱离了最新版 Rust 的功能描述（如很多文章仍然描述 <code>Cell</code> 只接受实现了 <code>Copy</code> 的类型），导致很多初学者学习时容易产生迷惑和误用。这篇文章是我在复习 Rust 时重新学习包装类型相关时做出的笔记，希望能更好的帮助大家理解 Rust 的包装类型。</p>
<blockquote>
<p>本文写作时的 Rust 版本为 Stable Channel 1.48.0。</p>
</blockquote>]]></description></item></channel></rss>