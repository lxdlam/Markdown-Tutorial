<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>邱奇计数 (1) - Ramen's Box</title><meta name=Description content="Ramen's stuff box"><meta property="og:title" content="邱奇计数 (1)"><meta property="og:description" content="让我们来谈谈抽象。
什么是抽象？几乎所有程序员都听说过。不就是把一些对应的实体抽象成一些数据结构啊，算法啊或者设计模式之类的，然后写成代码呗。
但是你真的懂抽象的威力吗？我们只有数据结构和算法等抽象吗？能不能不使用任何数据结构去表达一个二元组呢？
这一系列短文有3篇（可能），我将从Python的基础入手，带你简单入门Lambda表达式，然后走进邱奇计数的世界，见证函数式编程的高阶抽象能力。
准备好了吗？让我们开始吧。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.lxdlam.com/post/2d31b5ef/"><meta property="og:image" content="https://blog.lxdlam.com/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-03T23:37:02+08:00"><meta property="article:modified_time" content="2023-01-04T02:01:57+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.lxdlam.com/logo.png"><meta name=twitter:title content="邱奇计数 (1)"><meta name=twitter:description content="让我们来谈谈抽象。
什么是抽象？几乎所有程序员都听说过。不就是把一些对应的实体抽象成一些数据结构啊，算法啊或者设计模式之类的，然后写成代码呗。
但是你真的懂抽象的威力吗？我们只有数据结构和算法等抽象吗？能不能不使用任何数据结构去表达一个二元组呢？
这一系列短文有3篇（可能），我将从Python的基础入手，带你简单入门Lambda表达式，然后走进邱奇计数的世界，见证函数式编程的高阶抽象能力。
准备好了吗？让我们开始吧。"><meta name=application-name content="Ramen's Box"><meta name=apple-mobile-web-app-title content="Ramen's Box"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.lxdlam.com/post/2d31b5ef/><link rel=prev href=https://blog.lxdlam.com/post/975c3b4d/><link rel=next href=https://blog.lxdlam.com/post/df74bcdd/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><meta name=google-site-verification content="UA-92306989-1"><meta name=baidu-site-verification content="092774cb717e6851abd2d7fc55835b40"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"邱奇计数 (1)","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.lxdlam.com\/post\/2d31b5ef\/"},"image":["https:\/\/blog.lxdlam.com\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"Church Numeral, Church Encoding, 邱奇计数, Python, 函数式编程","wordcount":4136,"url":"https:\/\/blog.lxdlam.com\/post\/2d31b5ef\/","datePublished":"2018-04-03T23:37:02+08:00","dateModified":"2023-01-04T02:01:57+08:00","license":"本站所有内容基于署名-非商业性使用-相同方式共享 4.0 国际协议（CC BY-NC-SA 4.0）给出许可","publisher":{"@type":"Organization","name":"Ramen","logo":"https:\/\/blog.lxdlam.com\/images\/avatar.png"},"author":{"@type":"Person","name":"Ramen"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Ramen's Box"><span class=header-title-pre><i class='fas fa-star'></i></span>Ramen's Box</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Ramen's Box"><span class=header-title-pre><i class='fas fa-star'></i></span>Ramen's Box</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">邱奇计数 (1)</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://blog.lxdlam.com title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Ramen</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/><i class="far fa-folder fa-fw" aria-hidden=true></i>技术笔记</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2018-04-03>2018-04-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 4136 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 9 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#0x00-基础>0x00. 基础</a></li><li><a href=#0x01-零zero和后继函数succ>0x01. 零(zero)和后继函数(succ)</a></li><li><a href=#0x02-邱奇化tochurch与去邱奇化unchurch>0x02. 邱奇化(toChurch)与去邱奇化(unChurch)</a></li></ul></nav></div></div><div class=content id=content><p>让我们来谈谈抽象。</p><p>什么是抽象？几乎所有程序员都听说过。不就是把一些对应的实体抽象成一些数据结构啊，算法啊或者设计模式之类的，然后写成代码呗。</p><p>但是你真的懂抽象的威力吗？我们只有数据结构和算法等抽象吗？能不能不使用任何数据结构去表达一个二元组呢？</p><p>这一系列短文有3篇（可能），我将从Python的基础入手，带你简单入门Lambda表达式，然后走进邱奇计数的世界，见证函数式编程的高阶抽象能力。</p><p>准备好了吗？让我们开始吧。</p><blockquote><p>注：阅读本系列短文你只需要简单接触过Python和初中代数水平即可。</p></blockquote><h2 id=0x00-基础>0x00. 基础</h2><blockquote><p>为什么选择Python？</p><p>Python使用简单，语法易于理解，Lambda Expression虽然比起函数式语言很弱，但是应付邱奇计数绰绰有余。</p><p>而如果使用Haskell，阅读者需要对类型论有一定的了解；而Scheme又不利于测试和阅读。</p><p>权衡之下，我选择了Python。</p></blockquote><p>一切的开始，我们先了解以下做Lambda Expression。</p><p>Lambda Expression，在程序语言中我们可以简单理解为匿名函数。所谓匿名函数，就是没有名称的函数，多为临时使用而创建。</p><p>在数学上，一个Lambda Expression是这么表述的：$\lambda x. \lambda y. \lambda z. x^2+y^2+z^2$，它其实和如下的$f$相等：$f(x,y,z)=x^2+y^2+z^2$。这个表达式很好理解，$\lambda$意味着一个函数开始了，后面跟着的$x$是它的第一个参数，然后$.$，这个点号代表求值表达式。上面这个式子实际上是三个参数的级联应用，也就是先应用$x$，再应用$y$，最后应用$z$。我们把一个函数$f$应用$n$次表达为$f^n$，也就是说，$f^n=\underbrace{f\circ f \circ\cdots\circ f}_{\text{n times}}$。</p><div class="details admonition question"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw" aria-hidden=true></i>Quiz 1<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>$\lambda f. \lambda x.f(x)$是什么意思？</div></div></div><p>数学上的了解到这里就足够了，我们不会涉及更深入的Lambda Calculus的内容。</p><p>首先，我们知道Python的声明函数如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Hello, Python!&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span></code></pre></td></tr></table></div></div><p>几乎在所有语言中，我们的函数都是这么声明的。这么声明之后，假设当前的<code>test</code>函数是一个<code>object</code>，那么实际上我们是把这个<code>object</code>绑定到了<code>test</code>上。</p><p>这是声明了一个有名函数。那么有名自然就可以对应匿名函数，也就是Lambda Expression。</p><p>让我们来看一下Lambda Expression的语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl><span class=c1># or</span>
</span></span><span class=line><span class=cl><span class=n>add</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span></code></pre></td></tr></table></div></div><p>我们看到，一个匿名函数不需要<code>def</code>的语法块，直接使用<code>lambda</code>引起即可，后面跟着参数列表，用一个冒号<code>:</code>分割函数体和参数部分。上面的两个函数都被我绑定在了<code>add</code>这个名字上，实际上使用的时候并不需要，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>sorted</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>3</span> <span class=o>**</span> <span class=mi>6</span><span class=p>],</span> <span class=n>cmp</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>cmp</code>需要一个函数，用于比较两个参数，这里我直接使用了一个Lambda Expression来代替。</p><p>之后我们需要讨论闭包的问题。什么是一个闭包？看下面代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>outer</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inner</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>inner</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># outer(15)() ==&gt; 15</span>
</span></span></code></pre></td></tr></table></div></div><p>这就是一个闭包。一个闭包实际上可以看做一个内部函数，这个内部函数捕获了外部变量。上面的<code>inner</code>函数中，<code>x</code>并不属于它，但是我们调用<code>outer(15)</code>以后返回的这个<code>inner</code>能拿到<code>15</code>，也就是说，内部的<code>inner</code>捕获了外部的<code>x</code>，然后再把<code>x</code>返回了回来。</p><p>理解了闭包和Lambda Expression之后，我们就可以开始我们的邱奇计数之旅了。</p><div class="details admonition question"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw" aria-hidden=true></i>Quiz 2<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>上面两种 <code>add</code> 的调用方式有区别吗？有什么区别？为什么？</div></div></div><h2 id=0x01-零zero和后继函数succ>0x01. 零(zero)和后继函数(succ)</h2><p>现在就到了正式的邱奇计数环节了！</p><p>让我们首先考虑一下皮亚诺公理的几条内容：</p><blockquote><p>I. 0是自然数</p><p>……</p><p>设S(n)为数n的后继，则</p><p>VI. 对任意自然数n，S(n)为自然数</p><p>……</p></blockquote><p>从这里我们可以知道：自然数系统的其中两个基础是$0$和后继的定义，所以我们的邱奇计数也需要从$0$和后继开始定义。</p><p>在皮亚诺公理系统中，后继就是这个数$+1$。例如$0$的后继就是$0+1=1$，$279$的后继就是$279+1=280$。也就是说，我们需要找到一种办法来描述“后一个”这个关系。</p><p>在邱奇计数中，邱奇选择了一种十分聪明的表达方式：函数的复合。什么意思呢？就是函数$f$应用$k$次表达的是自然数$k$。那么这样实际上表达一个数的后继就十分简单了：我们再应用一次函数$f$。</p><p>也就是说，假如有$k=f^k=\underbrace{f\circ f \circ\cdots\circ f}_{\text{k times}}$，那么$k+1$实际上就是$f\ (f^k) = f^{k+1}=\underbrace{f\circ f \circ\cdots\circ f}_{\text{k+1 times}}$。</p><p>解决了后继的问题，再来考虑$0$的问题。我们从上面应用的角度考虑：$0$意味着函数应用的次数为$0$次，那也就是说，无论我们给什么函数$f$，$0$始终返回来一个和$f$无关的值。$f$本身需要一个参数，那么……我们直接把这个参数返回回来即可！</p><p>这样的表达方法下，每一个数都是一个高阶函数，接受了一个函数$f$和一个数$x$作为参数。</p><p>那么，我们的表达就很简单了，首先是$0=\lambda f.\lambda x.x$，这是一个接受一个函数$f$和一个参数$x$的高阶函数，返回$x$本身。其次，一个数的后继就是在其身上再调用一次$f$，例如$1=\lambda f.\lambda x.f\ x$，$2=\lambda f.\lambda x.f\ (f\ x)$。</p><div class="details admonition question"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw" aria-hidden=true></i>Quiz 3<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>$4$用邱奇计数怎么表达？</div></div></div><p>下面这个表就是邱奇计数的一个简单表示总结：</p><table><thead><tr><th style=text-align:center>数</th><th style=text-align:center>邱奇计数</th></tr></thead><tbody><tr><td style=text-align:center>$0$</td><td style=text-align:center>$\lambda f.\lambda x.x$</td></tr><tr><td style=text-align:center>$1$</td><td style=text-align:center>$\lambda f.\lambda x.f\ x$</td></tr><tr><td style=text-align:center>$2$</td><td style=text-align:center>$\lambda f.\lambda x.f\ (f\ x)$</td></tr><tr><td style=text-align:center>$3$</td><td style=text-align:center>$\lambda f.\lambda x.f\ (f\ (f\ x))$</td></tr><tr><td style=text-align:center>$\cdots$</td><td style=text-align:center>$\cdots$</td></tr><tr><td style=text-align:center>$n$</td><td style=text-align:center>$\lambda f.\lambda x.f^n\ x$</td></tr></tbody></table><p>那么，零的代码就很简单了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>zero</span>  <span class=o>=</span> <span class=k>lambda</span> <span class=n>f</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span>
</span></span></code></pre></td></tr></table></div></div><p>这样我们就把$0$表达了出来。</p><p>现在我们来考虑后继。后继根据上面的讨论，实际上我们就是在外层套上一个<code>f</code>即可。</p><p>怎么套呢？我们考虑<code>f</code>的作用对象，考虑$2$：$\lambda f.\lambda x.f\ (f\ x)$，里面的$f\ x$实际上就是$1$，所以就$2$是$f\ 1$。从这一步我们知道，<code>f</code>的作用对象是上一个数，所以，后继函数是如下的表达：$\text{succ}\ n =\lambda f.\lambda x.f\ n$。</p><p>转换成代码其实就是很简单的一行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>succ</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>f</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>f</span><span class=p>(</span><span class=n>n</span><span class=p>(</span><span class=n>f</span><span class=p>)(</span><span class=n>x</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>这样我们的后继函数就表达完了。</p><p>两个简单函数，就能把整个邱奇计数法的基础表示出来了。</p><div class="details admonition question"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw" aria-hidden=true></i>Quiz 4<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>用Python代码写出来$4$的邱奇表示法。如果用 <code>succ</code> 表达呢？</div></div></div><h2 id=0x02-邱奇化tochurch与去邱奇化unchurch>0x02. 邱奇化(toChurch)与去邱奇化(unChurch)</h2><p>上一节讨论了如何表示$0$和后继，这一节考虑一个问题，我们怎么获得一个邱奇化的数呢？</p><p>首先很简单，假如要把$0$邱奇化，我们直接返回<code>zero</code>即可，也就是说：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>toChurch</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>zero</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><p>接下来呢？</p><p>考虑这么一个情况：$0$的后继是$1$，$2$的后继是$1$。那假如我们需要获得$2$，我们其实只需要获得$1$的后继即可，而需要获得$1$，我们只需要获得$0$的后继即可。</p><p>这个情况其实很明确，就是一个简单的递归，从$2$递减到$0$即可，那么<code>toChurch</code>就十分简单了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>toChurch</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>zero</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=n>succ</span><span class=p>(</span><span class=n>toChurch</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>假如遇到了$0$我们就返回$0$，否则返回$n-1$的后继。代码十分清晰。</p><div class="details admonition question"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw" aria-hidden=true></i>Quiz 5<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>尝试把 <code>toChurch</code> 改写成尾递归的版本。</div></div></div><p>邱奇化解决了，接下来我们讨论去邱奇化。</p><p>实际上我们考虑两个映射：</p><ul><li>$0$的映射：自然数：$0$；邱奇计数：$\lambda f.\lambda x.x$</li><li>后继的映射：自然数：$+1$；邱奇计数：$\text{succ}\ n =\lambda f.\lambda x.f\ n$。</li></ul><p>那么互转怎么办？我们用$0$来代替邱奇计数的$0$，用$+1$来代替邱奇计数的后继函数。</p><p>$0$代替$0$并不难，直接让$x=0$即可，而$0$的后继就是在$0$的基础上应用$+1$这个函数即可，所以我们直接令$f=\lambda m.m+1$。那么这样我们就构造出了<code>unChurch</code>的过程：$\text{unChurch n} = n\ (\lambda m.m+1)\ 0$。</p><p>Python代码也就容易得到了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>unChurch</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=n>n</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)(</span><span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>到这里，我们邱奇化和去邱奇化都解决了。我们来试试如下的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>unChurch</span><span class=p>(</span><span class=n>zero</span><span class=p>)</span> <span class=o>//</span> <span class=o>==&gt;</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>unChurch</span><span class=p>(</span><span class=n>toChurch</span><span class=p>(</span><span class=mi>198</span><span class=p>))</span> <span class=o>//</span> <span class=o>==&gt;</span> <span class=mi>198</span>
</span></span></code></pre></td></tr></table></div></div><p>成功啦 :)。</p><div class="details admonition question"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw" aria-hidden=true></i>Quiz 6<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>如果我把 <code>unChurch</code> 定义成：<code>unChurch = lambda n: n(lambda x: x * x)(1)</code>，那么 <code>unChurch(toChurch(100))</code> 会得到什么结果？解释你的结果。</div></div></div><hr><p>第一篇就到这里。</p><p>相信你到这里已经见识到了邱奇计数法的威力：我们并没有使用任何数或者数据结构，只使用了最简单的高阶函数和参数抽象出了完整的自然数表示法，根据一定变换可以和自然数进行互相的转换。</p><p>但是，作为一个自然数系统，不能运算有什么作用呢？</p><p>下一节，让我们来分析三个重要但是基础的运算：加、乘和幂运算。与此同时，我还将提到如何使用代换模型来讨论函数的展开形式。</p><p>本节Quiz答案如下：</p><div class="details admonition tip"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw" aria-hidden=true></i>答案<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><ol><li><p>$\lambda f. \lambda x.f(x)$是什么意思？</p><p>这个表达式接受两个参数，一个是函数$f$，一个是数$x$，返回把$x$应用到函数$f$上的结果。</p></li><li><p>上面两种<code>add</code>的调用方式有区别吗？有什么区别？为什么？<br>有区别，第一种的调用方式是：<code>add(2)(4)</code>，第二种的调用方式是：<code>add(2, 4)</code>。
区别产生的原因是这样，我们考虑第一种表达：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>add</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span></code></pre></td></tr></table></div></div><p>这里面是两个嵌套的Lambda Expression，第一个是一个参数为<code>x</code>的匿名函数，这个函数内部又是一个匿名函数，内部的匿名函数捕获了外部的自由变量<code>x</code>，然后返回它加<code>y</code>的结果。</p><p>第二个则是一个有两个参数的匿名函数，和普通的函数一样。</p></li><li><p>$4$用邱奇计数怎么表达？</p><p>$4=\lambda f.\lambda x.f\ (f\ (f\ (f\ x)))$</p></li><li><p>用Python代码写出来$4$的邱奇表示法。如果用<code>succ</code>表达呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>four</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>f</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>f</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>))))</span>
</span></span><span class=line><span class=cl><span class=c1># 使用succ</span>
</span></span><span class=line><span class=cl><span class=n>four</span> <span class=o>=</span> <span class=n>succ</span><span class=p>(</span><span class=n>succ</span><span class=p>(</span><span class=n>succ</span><span class=p>(</span><span class=n>succ</span><span class=p>(</span><span class=n>zero</span><span class=p>))))</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>尝试把<code>toChurch</code>改写成尾递归的版本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>tcHelper</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>n</span><span class=p>,</span> <span class=n>m</span><span class=p>:</span> <span class=n>m</span> <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=n>tcHelper</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>succ</span><span class=p>(</span><span class=n>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>toChurch</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=n>tcHelper</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>zero</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>如果我把<code>unChurch</code>定义成：<code>unChurch = lambda n: n(lambda x: x * x)(1)</code>，那么<code>unChurch(toChurch(100))</code>会得到什么结果？解释你的结果。</p><p>结果其实很简单，是<code>1</code>。这里考虑一个问题：<code>x</code>是多少？我们考虑<code>2</code>的情况，展开得到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>lambda</span> <span class=n>f</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>f</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>))(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>*</span><span class=n>x</span><span class=p>)(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>我们把它应用进去以后得到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>)((</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>)(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># ==&gt;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>)(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># ==&gt;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>)(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># ==&gt;</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># ==&gt;</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到，即使是多次调用，总是返回$1\times1$，所以无论$f$复合多少次都只会返回<code>1</code>。</p></li></ol></div></div></div><p>本节的所有代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>zero</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>f</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span>
</span></span><span class=line><span class=cl><span class=n>succ</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>f</span><span class=p>:</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>f</span><span class=p>(</span><span class=n>n</span><span class=p>(</span><span class=n>f</span><span class=p>)(</span><span class=n>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>unChurch</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=n>n</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>toChurch</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=n>zero</span> <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=n>succ</span><span class=p>(</span><span class=n>toChurch</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># tail recursive</span>
</span></span><span class=line><span class=cl><span class=c1># tcHelper = lambda n, m: m if n == 0 else tcHelper(n - 1, succ(m))</span>
</span></span><span class=line><span class=cl><span class=c1># toChurch = lambda n: tcHelper(n, zero)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Test wrapper
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    1. zero and succ
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; unChurch(zero)
</span></span></span><span class=line><span class=cl><span class=s2>    0
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; unChurch(succ(succ(zero)))
</span></span></span><span class=line><span class=cl><span class=s2>    2
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    2. unChurch and toChurch
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; unChurch(toChurch(0))
</span></span></span><span class=line><span class=cl><span class=s2>    0
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; unChurch(toChurch(198))
</span></span></span><span class=line><span class=cl><span class=s2>    198
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>doctest</span>
</span></span><span class=line><span class=cl>    <span class=n>doctest</span><span class=o>.</span><span class=n>testmod</span><span class=p>(</span><span class=n>verbose</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-01-04</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://blog.lxdlam.com/post/2d31b5ef/ data-title="邱奇计数 (1)" data-hashtags="Church Numeral,Church Encoding,邱奇计数,Python,函数式编程"><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://blog.lxdlam.com/post/2d31b5ef/ data-hashtag="Church Numeral"><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Instapaper" data-sharer=instapaper data-url=https://blog.lxdlam.com/post/2d31b5ef/ data-title="邱奇计数 (1)" data-description><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/instapaper.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Pocket" data-sharer=pocket data-url=https://blog.lxdlam.com/post/2d31b5ef/><i class="fab fa-get-pocket fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://blog.lxdlam.com/post/2d31b5ef/ data-title="邱奇计数 (1)"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://blog.lxdlam.com/post/2d31b5ef/ data-title="邱奇计数 (1)"><i class="fab fa-evernote fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/church-numeral/>Church Numeral</a>,&nbsp;<a href=/tags/church-encoding/>Church Encoding</a>,&nbsp;<a href=/tags/%E9%82%B1%E5%A5%87%E8%AE%A1%E6%95%B0/>邱奇计数</a>,&nbsp;<a href=/tags/python/>Python</a>,&nbsp;<a href=/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/>函数式编程</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/post/975c3b4d/ class=prev rel=prev title=SICP笔记(1)><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>SICP笔记(1)</a>
<a href=/post/df74bcdd/ class=next rel=next title=开始使用GPG>开始使用GPG<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.109.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://blog.lxdlam.com target=_blank>Ramen</a></span>&nbsp;|&nbsp;<span class=license><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>署名-非商业性使用-相同方式共享 4.0 国际</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-92306989-1",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-92306989-1" async></script></body></html>